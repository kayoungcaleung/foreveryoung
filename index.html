<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4423104cbe77a278f80805e5d7885cf9b12d3ea0ece84c1b956bb073fd4f5ccf4b0dee190a0e16ffc399865ce6feefcb7b34d65e2db821d96eaf0fa98d6bb76e26dcda6c71ace409954bb16e5a2b4f87f47345b76a2e15b8c750009cbf5587fa3337292e47bdd566ef0093cbd82b67344e91726a1e4967b85b9d8c012001093b1c37d0366fe31bc0aaaac27ee39d0fd55f10d11063a9e58ee9fde2d3b1b98e42443301a5045f8207b234645dfc150cc6d430f1155063215da096a23d6e61cfd69fc3e37ddb8de41027e0ac3ce429adfd9784954c374d30c17b8e44e0e9eb16808d71d5444f5e76cf95de6bd6355c5ee7a09c3c9418817f396ac07f3fac21f831b29dc6cd5ce7661e2f841f792c2d5a080459dde271e6c9d481bbb47a3a0168a77c5d3e271372692b7012ae1b197d334f10d0b28461cd0de612dae0fcdb0f950cb64cad95613b61ddd2132f3cd572a3f508626e89758a6c0417c51f07d316adfaa80c2f154b92e2bd5573a884f749c0748e76fba331687d431362a6f0599d486cf2b27a375146078bfda1ac75463e3b4f52c2fe9005ca0c07ded5082ec79a03fa8d0dd0ff69ccfea3994ee764f3de6815e809fd14f368945b708de56cad033262d3556cc8d9e166dbc3c64c3ec6e02a86334b5773f8a3bc22d5981361bd0ad4fdc138d76b734e464d5085d62650521c87961df675c47a269d3d98386aec1e7adfb99d6b54e97b1d971b46a9aebc2de4bd6baec93ac8a4684d21ed8af4b29175892f46edcc45277efb1a759c247e9a5fd90437a4607d75939921ef4ba18200e90a8b1863d6e63ef76c53d1a9f88ced6ec1f03d7a6eeaf2c079cbe499c88af0ea8b0df9a58b6a1ac341a3a128d84ffce4c912961986458f7b107045fc3b6e90aaea6b1711f5304bffddd15d964b8c488fff6f7197fb4a6af9dad5eb54b8c28c13b46d5d74280a1b915df3543d1d133d324bd8af4ed982c5d146245b47ab4f6b2d63cd97c07ae0e7ebe3964344432444a9484864b5904d5b64f0a6f875dc7939a02201caf13afa156a1c4df65ae500cd6d6dbc8188141df57122151e2f3f8b8d7952eba6c41b77a10ae2e7e90a8bee51f6bcca012f04901cfbfdcfacb756f40728ffa9dc9606e8951451940b9c5afea42677bbe0ba93428fb178ef288293d902f094535124698354b36d730fc4ed84f76a4c98006a19e9e4c3fde0740991dbbcb944836ca3369607b0a18e024741c54a5deab40a23ea0006067dce9b22d92fdfd7e4e713c500a27e175affec0a6d53672f94d8eedad67780db78db383a78c19c470d54e6d35c3a46c19d328d21377175bc6a4129a9ac8111e7766b73af870098c973238b500087d6b6c9245dc2457e0e4b03df656c606b02fdfcbe375805f24eb65f7d4f2bbf7458f0d37cb2bf3b3bba87fa066c5d9bf3871039e76211d41905dbf79cd72f9423d0da7b06abdde0be0ca959ed45771ebff5c670f16f761fc81904e853233470ac0dbd1de1018cd6eeb3134a9812cc4ab788184256c6689c3d5cd7915f21f93eb9ca392b70ea5ae6e34d9ffc9a46edec3efe10e9b333dcac46ca03e959ac789103f5aca779b27c2a7dde39eed07d1649f87ef859e2477b87fce69777dfb305f9700a472c50574abf9357e11b9c15ae07d437e85e52ba2c5d9d5c6432424de3419335b67604c665741c49abf87032021f03a1965d5de54aa6695d432619cd9a872f3962bdcbc651f4d6ab24a5dc2f16dce7932e2bdf8d955d145ca39930780503b7fea4fb92a3c17c80a4f16e2d14cfb280c0022eb534b87b085110a5067831f64e5ba8c3f480dc8de03a7da7abb206f31e0dec105fd434f1454afb2dda572ad60eae922127706b46a5005b20c22282500e14ff020fb7b1db32eab2986d7a6ea811180d21ebb7b17a6799cf6cb68ddf951de340502858473e381b20235b7c5cf99210c108a933568849441bb41d4b40a9ae6e18b5d5b2608b251c82d3e97c3aed6239cacf321abea7bdcfbceb419ad6c223d4ba9420cbd991939d53a8412a0368b446ea19c5de79fc7d084ff979767982efe21fa315856affb1d9f20e1f4ddc252ce90b1066639028c378ea47ba5f2750c788d806947d9cd701f70c2e29f32349bc3448c09cc552b1be156e1f7e968c03e21052c0b91a50b30abb557de7d360e00c9d448858d7f219b33e0e1105cc97a58d713273147fce4391f358204bf020d5cea1f70663a69606d0b2438caba5568af4233aecb5ed90bb51c7909a4a2f70bbd7930dfb56274da2f1b25a1d6817392fd425cf88ede8968602b73d0db3904ecbd83b3421b2542a57ce9bbdb12005111cc0fe1e94b72cc01e3f099953567b9171e0b28446de53d39574676982cda42b56ddc937d93ec7abcf43138f2249702499c659e6915c089212b847d5904ae56ab7488edad5c016f22ccba18731303cc8195a0193ca9f3ad19b6415c6b30b1f832cc829601c2b9965bfbe7e92dd010d38a9a6a7391bbc370b1f4c84dafe6ee604f5bdb16380adf566799a35706a06bc6dfd85f9a1a948e088f5100b54b46a54f345547c52cc9dae9be9c7ebff7b18777cfd1efad7987470fb24266f48fc189af0498bf7ec65a04968a17fcc0a192bf0d64d62fda1dba5ccb432e2f31d126658c88bcf8426512ae5cba7ec03763357f45c6611a298885574a630c506624a3c7ed1392158bb73e9c418ba032e6be65128cd96bea1ca07180302de5a0a192511fc333fcacff9f2f2913d7e5d9066b6bcd2065034cf60f069c4c0b570263f06c86325ad963fb0f53242a4409cfc8d3d230bc9015f6160b4b3c71164ccdb6ccff2e401e7a53124a53e8b76cd7bc499313b35d6cc05e77d5f072217273ddec577ba13f15bfddc1173625c449ff71d3dab78443bfb20a8004f1dfda31bed31ff6ce43a85b37aa466ce12d2668d451758eaa610309c7660d607e010bc7863cf1e0c9a570c32809d3335b6fb4cccdd08e3809afdd722547a5fc847f4ff92f282e0ac700e829e08fb71415189d67037f2c77e96ec724bdfe06455f6f411855c1315a1cbcbd4e262e5c2a2656d6d53704a34edeaa8049193a7b20a2d4f6414751f5a9bc2967a9df46677ab7bfddb88f6fe31ec7e98b1d8f5234567b3dfb1f699d06adb11290cd510a11a3822226a0cea57258787b8a36841cae6476aa35b17fd9461e4fdf2463896accaf3078c28d2d384efab359ebd6aa363f4c42c4cf74347101028a1b7726a1db1cffaeed6bf1aef826c9ec70a9fca290c63f373cc282cc2926ba2b8662a0837fe4e6db6bb37b967dad749103d61a427df759121b5dace0d9ae3597fdaf11b08f9684e33e0d10ff2062086945734d53b9d7404720cfc5bae00559b0216638c8701fff0a530d242863058a6c257fe4b640b9061c459612172277881b7802eeeb51147a0dadd702b855683e6794be2300f4ffde8466ec61a9116a22c4f94504c978a208bceb633f3291d98237a069f5c7f72c03931771e700469f9897401526ed396e229cfc1ca53d996300d7045e51ab30a1cdb3f8a4b6e8a8bade5638a7345f07394ed41a28e8c9cef12908de431c82d49bd57a124c855add36277474037fa7fc8995e64f21ae9c4e1cba524d28ad27a9d068d2c136eabe825979bc15f0a28c2153860e0b0f488d10758470633b7c72e8f7acfb31a5af974e7ded82054c33d83ace67fb812a0bd166be988925fc3de5f04be0dcbab9892aef55b8462c4cfeca222f7908932f6a5d196d5640a8953d79179312a0775ce6ce5ea14935a0db55e32e4823164f98a3c0071fe242367b43c96a3fa198a213e87ea1cd9dba877b5306ba546a5b970175242bd7b363fd80d7e2c8ba6ec49912641ffe979ac72454180e932322bdf1d2f6bd5f70cc7e8ca828b5f26b5b24189f6092965679e3ee070e2c7289509806ab43a5d6c05a83600e073d3071839f272fa57d2f29c7c771ca7ca09f1ddb84211ea182a2de96496cb38c81716a520989922506736acec384b55fb947a1c9ee6c7f8125dbf54516312cee4c024c084d2a63405c8e82961db044488ae9aa053bb1122d98573ce17f669f4b4adb48d1dde747967601134cf7f50350461ff75e3f625579c685c8a4587598e55d33d994b02636882720686521a1215ee14abc48e0b9f648e64650d8ed9ccfa85234c6308830f6d2e3471eed6a39adfe8c178afa18759b593b3e305bb65d79ee2297c11c9ea2583789f4617c454d2e1f4dff76fcf2956898c6850bb7902606b784c06c40f18eabf9c640eff8838b2241ca83f21a970d2ca3e9bc45b65dac70081908d2a3a3993a5b1e02e2276bbcf2ce25a378aa52f0c67c3e36e94bb76342b157c4f7cad9d0a8b8fa846684b4268eb6d5f8eb65487f2a565ce716cdadf3de6d08827f3c7a678470072356e30769759a971c1434974156a68d3a364c9633ec547ab44cd5229cbda83725fde3364f4086a21ebbdcbcfb5da108ad0ddb8f8555d543e4d4f882b87b3d292d1f1fb4baa1750e3decc8d0bdcf61daae9e76757b54f134dd849b1af95f5de6ed2beb2b0a8492963b3356bfa1ef5049d9f5c44c5117fcafca7e53d661bdbe1b7c9abe4bfb4954de0668eea32fd90ec6944042d2945bd89d614529a49b99f33a522e16dc8e8b18eda48b2bd21d0d368461daa2984a5b5ce58e97df9015ca18bacf9f919468fe4ed3d3b972fa4e15c0e326b9c3342e50ea32baa0aa40c6afca93af831687ed8061a2646862fe0e715469121a7dcfb56beb3faef83bd8d78011f208b75fb519c226f68593c87bfd9268a22d4fc16e2ffcff17bf1fdbe09da512496af39e842e8eb11446f1aac3e1aa619458995e914e49ec38538c8c3155c91901ccb3eac685d0f01f2a748334507c331e774856cff5ca4d44ffc8b1a52beec07719b9f9c069dd9a1ad95d1cbb64365847bb4cab78828ee1278a82cdd27733ba5f3144b6da2d18a67c90c836dc2b4e24cf8ab4053be035b4276ec4c37ff919299388816b53e303b0370d41a06b9a5444844fef26766ad26c1e2309cda4192d0b3faa50a43d10cab595ee745b8aacdf6f9a092aa084221ff88a95a4d9b0c64072e0d856a7666192a22635426974fc91b71c9a8fd3d697e5d343bf4941dd2736a972ee79680303337eb212f43626c957db9a6fc20ef7fb2d96d0b16bbe741cb3b63df428b024db1022d60829135cf3f8c6c26e916ad0e970c2da88664cacfa282f501f3550270e6146d5a24d3b0d4f645cbd5fa2238115cd5420786fb6dcf0d21602d4f93210e458dc2823cee9133cf253784a37d29a7401cf80f4c3726ebfcf51e89f5a8bdf22a23b1a52576132ebc4f2a67b9cb57eba8b05c817fd9aa6d692f708c316207b4fb32f7961a90fa9453c6d4f69caa5c7485403a7ae0071cddd3027117af80f9c86cec19e79172d5fee810251cd9a42b13249fba9a006b0615af0d18a1319948b933357369330fd248f270b5e710b594bccd50a0c46b76ce104463153dcf4ea5779370397a33181e4c5bb6dbfbb5ffb531383d3c0647a46fad23cf09b9016d717c1b726579155c3f1c8b67044bb18d5e8b922fd52d977fed93510f174dd16f65bd70b386be79618bdbe60c2f992586a7a9965002cf9b917a895e2a9596a2c0e122774c1baefbaabb95290f5f3cf93be8c64a0d9cdf5697309bd17ca78f7cdfa80ba37c2768c59d7ee4cbc59509098e775d42d572a83020cc3031424492ee5abf05c9fc09cdf0a733db4b1de4fd7b3d99626d87de8b1ef15a53e8f748cc78ba94048e1a7b12f98745e52254af9d8ea1a4e6d20fb5b61ea195dc03d165319f5f92c0e7f786aa68b8105af37f240d547d58ea544797a45146451c96365750a686ff134fca7d9fd2797593cb4eb9316b9efe45efe698e85017d44de65a1f8e6ae8a4920964fcfe81bea6bdb28bef51039cc5f708cb530e606546f7779849dc117adbfef59c4c533b7cae1db9c6e6f492bf7e309f1686d78d8ac17a009cec25bfeae074306bfb4691ee829d8bab82c92bde8701bff4a378b121783cc2ec62f922ddde8b0fdf61b86602e1d6eb778bbad7b8e655a5a99cb509e3045bd17b11736d68fe6a04e001d367a1fe56d39faad02d9bc1627e50139189eb0c939a55fc85c88ae69f07b430c97a2a9cf6c824da1b8f1f84af01b933b46f5b97580ad82e1efe3969bb473a3e287c0c6db3134358c51af9ade0bff9839d66bb6d5b00a6841bc178c0dc053c6d4a59c162ebc0eb9f10dee58c80d8410a48a4a8f9bf28de3565c1d4d4544c2815819ab98754919243df0b44a4f00570744d19ad4ca625a3116e88c24295059d4ccff821d62a6bff2aa63c8da724cb35948a3dd26950387cb4e6e41d139ffa5a3772bbb7fe93ad3de2151600fa0dd160177eda4aa8e24ade9e9107a68bf85bd0f12cc41fe384cb16611d2a1c97325c2baae030d55545de611e0b0ffc16ae69c8749c49a0651db3040aa2b6b12157bb886ba6e87b5b866312dd72ee45c29b919fd22d3f1783f1e9412b39e8ca7d91e8043e540a5e339d5865bbf5e0b46342d6063f476f7082cd62f383c80fe305b1859838ba1df1704e443cc91ba9f6393d780dfd76f91ab1900dd045a34b79aa285173777febf6a8c71b5bbd62e54a899596418c3ac3226ffe9158fe6b564a072155f05c9a902fee5e4e0497ec249a27cf68ba825f17d30d6b268c6d63bac91eac73230ebfcb7c1441c32d08a6b82cd760c7a8b7992cc95878c202743071cb06e89f3b16c2be1a8b237e92c22ee4cb2561dc1ef641481a952a95613eeeadb188d5c6583a70ffb74f701e77579697d0c2575c5afbd17e3f4c7845f433c0830feeef6088035891872848d224d8fe63513b89b1ee0db495dda2c542c3c52fb663aa46c55b7e5f33faef41814df3bc1ce25b381ace6db16ba7b99d31f33705a7bacf62fb0aaea6f8d5f9413ef792ca387b143ee976ac4e11e95b0ed04b7f7042d34d2e856c87ffb0ed4415d62d052bfbedb90cfdd096dcd997b58a1cb9c6e326717c5016b969b128bd1a4ab379f276fdfc677c4e3239a0e05f5a535301b5edd561ac9c67936dab761000b8796e11e4e892b9325ac8ec3740242c59a2d4b05981e0b0e4d472385cf4c4ed6434f10326f73c3f8366c129267b2660dd5246538ef94b6abbc06d1469bce41cfd96f14c85a6e6bd7ff5981aec24318226650c9a5269e1b9c9361d5ec2c6f28397ae6db1e261a00901383d45d6565aba40971a739794ca4e7188d2272389a1fb10836f83066bb13cafa8a256802de39d0baeae7ff4da5fb9d2cedf7fc04eec3a8f41c35aa09259f2c63b493fe7471232029ce26c819a047c649530dd1f5c623190625aea0644d753e0ad20ad5be273f1fd3db64c86f657e18bdb18164c76b9e53efdbf7f030612bfa725c8a8a0bcb1042ee24565c74e2d71c3963f9e4b29dde56be18ae2d2f3c213a13587f815b9c0f44c526d965f2195245d77bf29d954a1f95f91606d1896bb2ac0150aec12e8894c5257f3e5fb1151aa366766a703192ae4e9279833ef0a83872d5524b5433d633ae4efef10e00e597119f964bbe2fd96150a169f293149c6ff9e68b21080276b3328a92ce3704a762a5c6514e0c74b8545fbdd0bec31ebd3e0fa8c3b882e7c5fb045fc34aad3be8060af15c538428ec0306968aabd7c52944db82173f8f6d946edc47c6716deb23e6864e01eebfd6ed856662359e3aaf6af175937aa507a61e8812791de538f170dd79157c64f4836a198dbee2713973f0192272b362b7d8c8cbb76fa6f6008a82f68e069bf232cae083add25e4e6719d96564f7dae70b8543f4f35c7210d45890fb555efd36885f3019d178a9854803d820a665ee9fbb6007cb91c28de6e63904d24c67365b52961d6716359b9485ea08a5c5cf5d047614788d93e9fb9c762956912389c18cdcecfb95a0d26ee657187023457098a51a5edb90401c4fa1db0e468439be706075feb7295887581083e6f7a95c910fbfcdc23e573cd78caf9ab71bfda2e1eb10e2019716be5da154a2fb8f8b3883d762d2681c49727a660cf61ab1ebf02a50351c203de832102bda8136eeea1abc81076a3517b08fcb116838a45fb040fe49e4fc44bd49e3503263a5052d97a03840c47e66fc2da5898eb5b440733d4f0f64f185aefb1c8ba1ec04f132ef1a7e272eacd6d94b7495a62ece3bd478bbbeefefdbabdb48cab55f44a5164c09e10b8b2feea606675c926a96ec08920da497ca582fdb762f666245a6ab60034123f640f5116cd0fbfd35536f3a35f0e7c269ddce3dbbe1ce192a3996b1377845e08f6d198eff9390f5bf78f22238e6ea6d98eed811f94e9c6b8a534a03737b8ca51ba06addf9b28f280794ce0cbe95350227f771ed33977df95a2b787f8d243357656b5993127e9ffd6b5d29e0c1132bbff16dcaa09bf5ebc6d7c992c4daf63d5746a14768b311682cc58cd4f0a7f43852fbbc618887e2525c19b1f322caf7f48b4b5e6b629302a7e68d1e4d6c87647448aaf7165761bbda231b02f3cab703db779bcabcd27f6413fc1a0aa829ae0aa4391abd55f9497be385e5ed4a7223109af797ed6b8281e9abf030bf6123d18b2926d1994a54d36b6e2a4ec9a0207a47ae86a65a1895cdfb4ea6a835ef1bc51eeac32ac1c2fb34bd8678d4e1faf905e0c71b53733decf21c799f455b078a827a3d20c7145eb327a4a13a7c21b35a6adf37a0202f41a0ab12969ee3aa9cc6dfe21b90d2dc1a685de7c0ef9b42ab3d6b3667d8c104727986a7901d767e26401a198a5db56cae6e2a8e88638fbbcb3d448db427eabe0a6fda19a1e46291790e2c7e1eaf54297af18200d32d0b77bb3eeba2ad108d83045c0096ae6c35070f78cff3c19aa57a23bafbe544f5575ad240edc288adc334f3663407b51b6446d62679131a6b06ad91a40dca53fa53ab8d86b247b72abb21e84a6f8598b450bd90cb84ca3705fa1ffbffe05fb61dc06495671cf32fe262a04bb72fe1b32a3e62d7ed6d139013dc3ab0f1902c40d9d679580b23f1da0256ceb33dbe29e74854bf7285b1c816684c1b7be24163831de354d95c3c1546c13fa0e5647375ff8d112385dd294e822f39515e127ad25af49b8a0e0d67f19673bbde6c2ecd9aaabe89ac258537542f5f5dc429d52057055989647b343183287c0665fbdb9e54c9f71e5a09aa38bcd68dbc955eb17a8d76f926546048046110d7588198c9fa867ffdb6217eaea966e154463eb33f15aadcbb6ba980d02dee2a3be0be0dce4feec2490a0d09ac11ad120b5a1abac74fc6f5b5a8860b46c0fa45999e356416371203db5cc9adda663b580929a7cbc52d771788268e4ef167751af92f4d0578bc8d2d8be8b644eff537cdf643e244cdb5b192eddd92472f217058a64dbcdc0c686832e818af4095edb5ee6bbe1357ebf74a8b20d8fa0eb6fc94d2e33675b450d5d7325df6474a09779e8763904b022caa37fb8c30915553aee79fdbbd3b63800d77c7572b3f8214f6d38fc5e688275554681c27678fdc8b5568635409686289b04a3020b8a48b8eefc89275597e6a48ea0b8dedff1bb91e242ca4f3f9c8e7200cbf2e39914ed8688230b3b64ecb3b47c1ee8420098081e6740fe0eaa372fffb4abb1a9c080fce19d9e907e255209f2507f10e7b858e16e1c61ec7cf4aa17e8a9a575185abbfc15ea367a806c2ab7fb0f81493d6c82ae2045353006a5ebab8e62aa17a5c992b4d3cf46879bf2d20933d8fa25b3232f38f454ce50203cdc9cc3cade9ce360ce38cca2d5fdb64ad93fc7f841daa7aa93c703c7d637a98bff3a768d956d10f214da91185a8a7608473d67101b736a5a1c7ecb141cd4e8f7b9fb4fe0dfc92788e447e9ab2e636b78d7c5d8124e91caecbb1dd64180b3ba9d1318cbe98c046421bcb6725e36f85e3f1d567420a9c5e72d56ca070840cb61a72e0f312ea097b0233bfc4b0e24bd57582a1751a65788dc70c70da5d0c64f9039824b9eb8e2b38a701a8c0911650136a29284ff2df801bb3e9e89a701468e5b57a3b3e9cafd015371ebd8c5b9ede264fca1cec8166abf74bc434e2b8cb154eaa87a5c5ba766a813d4c8b6037c1cd8029b51a177662712236dbdc86cf78444b0dea4605d6b06bd4a341629cd0cbdbd1ac319ef7c115f746ba2610da5c4770ea87965abd5a60fad957918677a365e2a3eca74192c093a440ac5b12540b82c04ae27cf04c6973f5ca8162214668051ec4bdba465c23226a463eda1a804c22243b7cc533709af8d0e0a7b15e7ce233ff0ec68906e090cb8317ad9d5eb4b0aa90dc4e3d67706421985d3516852c471a8fb533b37729d6ef36cd599f9b49d096a4c09f4b615b8c92cfd2b36957cfb0f582b45c9abba957f8e026c2d8d50e345137eb6150f36721c95b80e826a03d900e5bd10951344f1798e666d31de32b7683d280277bd34e8bcb7a6445a852745d781e292bfd9bd969254dc8d8168d0eff999986b78d29e0d405dfd0a4a5ab1db6dde856468a78e43fb3aa339a6eb964b7ec1950b5bc7659965f701d3e6560f0df21b559a723870c481ecbe3b48699da7ff795748de122697f02f95221160a5e98567122029191b1af30521228a0e3066b524ea49d0617e893cb28eb295ccdaa7af3e5a3e4e1853d0df5ab79055b17186fe74dfb1e929c9faa021ab2fc239fe2925207454bc5990b7c6230518d392c103bce1225bdd395266b46c4b29170860222dcd68e8a2f4361e3baeab22d3ba80ab8ed5f5dbe63faed0db3c60c0f707287bbc3c866a1d928b1aeb2e10852f6119a65f880741d64a4a4c0209616d01632388a6cb2f11fc7c56ede0f8f42ee997899e08af616f243456c6357b9181b40ece4378c43162eb96a01b3c3f029b76bfd429657775d055725b2fbba519af36398dea5b19f433c3847ea23b443b82c89aa707d9d54ce6fa9b56effab8f808bec00631df39fdbab7eaa27694b45d71d3467bab456486104cae15aa312a4c94180975e567ff3c1ff2c13ad232b6f5a8dd0ef741791b115dc81759ccc5ff835a50cd4c09f88fb72c4f7efeeef47e3d99938b118112085844107911f947278900cdf93971396d8f6745e305ce83eaaf0de4da2d4e681526cfc3aac0df7156737f314795b2564e25ef5c645c8ee4078314ddb86edd4537e65576b1a6f6eefaeb776e83cd2d787508c2330ff8b2294549ee5ca8ed6ddc90a98e41a51c62c33a0d7443990c9033ca90cdca7b53565e2ad481c7b975e3d957df7f5ba66921b0f38eb3761a5caf604bdfc4ecfdf62686a5fe83e794f5fff7ce1297635dd1b6470613ee54a2f8dbb1d755baaf81de87b11fd5e297e586e3dba6c7c6a5f5d8078d2993c7c0903e5d26441c3f39308a41e1abad507ebfebe5b78bb7934ad4ca0c6ede1aeb85754e64bc113d4ec5904572adcac94f365b23b7b729007250cb1004fd755eec138a57a9f6e2e1db5069582a4f2c87a530d889ed4a248563e36f7e0ecec28fd01ec621b2317f7b87ea0f9fcdfdd3421dc983a268163c8d9d3a7b2d84eb0b0ab04acaee469cd8d3994fc3a531b74ef2c406a44638ec093637621f16e898afa1a1661925a462a628ae5ba3df6e4791ac32f4815707cf18bd409fcecbf12de87c9458cf1f250f2e0a5be123fdac734ee927502ca65c8184461fb23951ef474f985386f7ce06e83f0bc248b6d7e5b3034deb7f82671d04615af73abb314f56cf6c8c3cff15817273ad0fe70841df0c0b10daebcda03b5d0960ee901f053ddf1efb643abb092ee7b7c52199b7049161693a780adc9ab53b55d11e69a3397fe954b5acb0f87d9751366751bcf37b059e7b76b03e7fee4439c915814a2770ac0b8100afd7036c5c821c4de0fa4a36a4c81818a5412c6b2edd6c81403e023b160d17a717f1f1091998188066bd6f41f327f64ea2b7e2f0b64ab35b6cdfe150935a324aab44b0b008463acec954c5e216d1c4678ad45177d165a7a753a51e5f5091e17adf7db1003017ed4f3d8074fd2cd776936e0a21439baf35c7e44a4cbbf6305781f80fc15be22a77f2959784964dd23419d7472c2f233e185dc90404ff8613e78c1289825461d5ab6456263f388857c52dfff708c339a4127f9a62afa8c6a8468963c42e783a89e034f97c156e9f34f1cba4b14b4a9f173f5e3ed520ff4651d102d7a94b117da75ec9e482aab7400c94821b6d52c423bb5161d5c1efc7e043b1cf1e0188ea66b3455ea212e607411a02c9038fb1554133ec997aff85db4cf7190fd0a610c04a7229c385097f1bfd485422364cd3108e81bc1005c80b46dfe4225c0674a9898019b86055539676a9fbce23e5cf8fb0aca01ba8bd8998b190b88b746732d791218a71b3cc54632baf7c4192912e54d7c8a8574d2f1fa29c29b5ee5168f3f4053e36a18a87e0030ac377f4971d7ba647d907f31fe2b40926614aefc2c513a133f1d15994759a2c9a34aea365719c072caebecfeb2aead2376da4ddb8a498aa0c4b86eade1a396383fa6e45f4409929c4d20e945cc7c998bda04256e5a4705c19739d31b88b2aeeeb90221cdac99d70921a031928fad8b1cf9d525c9f18163dfed42fddc3a1a8fafa4a6f2a5f81ba5f5215be7a867aa84a9d50a988e2c0a00218f284b029bdc16475e31c84ce98c7c292f75dd5be3f9f19cb3ffd49d2f62612cdce2ba2698cb35555f2f2d4ae0ffc3ca3bdc71e2dc379fc7bead306f67f22d79478615e7f7eb739ea311987a4e34c0d33bc8f82da583a2b2710a9fa561f9cea7af4691c90196b61e59da64236c1eccf3a98130a84ff4b034fdaebabb7ddc187683e85c612bd6ad9a0424c6b121ab3b79987c71930dada5133b393a414f84e7151a6896d7d1e6f3a400df7b3c9fcd05360ef88adb9a06fed77ebe28b0e03499856a349322c4ca20d0346d5453d8acb58a1145965b16ca1d7a1c0e90180c95c452dd9a2fe8f999593f26e29b361e0a34f2520e8a0886d8be20171f5f6741fe6fe5b1e82d131211e4cd76ac566002d603166d588155096830bdc2c77621489bb07f3aa96111a9ce1d547ae2cef474b1eb31acb5e4ccee55e1858153c519d03e3157eddb21e482745dfc368fa902f2d466c98e77c1c563ce7ec81287cb25cd4e0c1a9c559a4572dd7f51604af48c97c204c03d97638c55c1bbdc190b4073a027e29045c0847cfab72999b25c6d70e728d6f1b13730f52b91b71cf38a0bb2ffcdf58713ed3a1afd1df93d3358ef0bf09e23af94967acbbd4c68547a02b6d3a6a711be1083f2062bb613d83cf8b60c56c9c5324ba7389356f66bb03ba678131714b3c8dd408380baf816f0846e4d7227a64ab63762c0dd80c4642601d3c99d7c65e280511ff837a5eb7765b35971d0702874b63cf7d400f594f333e3d108a3348d654b298797db0f531be526951c60f2876e973466caccd329c87f3f0ceaa15e319d5944f6cce0e9b25df56eab37297c9c0a735c8525be7313b5fc1ee368000761e81aae68d1eff8763a2d3bdecfb73f01961852499a413b7c3c7fb69f5000d0a9ad55e92db7fb8213d8cd8661bf5aca3210c2e64d8a08c2fac2e6547cf48e8328b60d64c697725d57507034fa5aa04bcb758cd7a092e750320033fa90ebafd8e4caa329238574377f6799080a1b697f340e954131f3f93e20451538c2f7f4e63003cc5ee7ea9353ef52df6686664661b20cb3baaf36ef26a8a9f16b27643db9bfc53f64abbc4c235182080743f1e3024a62acb398334faa022bddc9f007bd5566d0b6ee15355f8a5d0b4fdcb6056cc95ca3f04644b8d3502e9b681699703caedc8d52bf37af5713b523a25d9bbe26482112636aa89f1ce4e2a74d589cc988572334aa0964bd95e377e16c822cc3759ace1d9f0a81fc0a6ff422c325872ca5d69194f4ea6c898d6e27ed197cb7d0798118fa0f66e84ad57c5a64c833f47a9e94daaacbbb99dfac41890265d0111f5d261ce45debdcb70a4da729291560a09fb5a5d3e4cf0299c06ba9965b96d4ea42e8b25ac2f9ec5c25230674503be5de2fd4b49acf3df2bb2fc96e7cd8963733319a96b1786c57f51add6c1d40414d82b3328e0ed79b939e8d5be36526d5e657440472f1331aab4a9983c3614c62d933740ca15dce0d4b178900abcd8ac55ffecac096c1f171796900dd8f579e0261fab8dd19cbfa9ec414baec1c62b177457f45b251925d052d47a80e37a0532025e3d082b3b588fb1822bea5d70f2c9b711f005f0dfb35057e0ff7662ef2d3b60cf02f11738c0eacc2dde29efc8f0bec8deb72fe04fd9974f5d344e62e462ca34ca8f1d4b4417c105d180adafb6f1465ee6e2c82199d7113731f9779f280078cce8858d3e037f6b2797c47995d58abc0ecfd1938b07b4a69250dfa988ad9ad33d8267eb68895bac44c6336e210b0471263e1b0fe4b5f5ef005773413bffb5c16efddfbab57a6c0c684868c1042f1d547115a7b44798340a7c60a431e4d618d5189f260e01e2d8aefbe59965154b9cb13cede579c4b2d4945ef02776d29d3e7ae3fdd44c6479ffa2c85c22b1e12d48a6895bfbdb21194f7939531c9eb3b1a6d28363776136661d280caa795cc55b7b71aa6c0bd0b3dd6d1e3da08d7d2c48a8e6f11cfb6280490f2a89ebabdc363eff03acfd6f6f0ca3f1d3089809c2199d1c2472bae396340283f4bf28f452c9491ea3d2a80418e870bc5588b56b41d22b5d2091a06361d0192a48a035822f1b2434cddfb2663777d835bb676c4a5ec9b127612bf4b5655cd37ff1c6be0b123256d1d08666ca72d2d04f2d9d9afe7636938b6a8a1e569cf3558455ed45c6a57d194c64efb3bfb83b93f7218b004e219b657fb8333c582e91e8862a9fc631afd869554ae09c717e5fc5a979b499c2ebd11e86156bb6cde7e5dd10a9048f295b12899691ce355aa31c6ff86ed9ead5a19773fa4c049958d869d92d5e5250f2065a27360cbf1d2e44b2052c18d0861e279a66374fad4fbc9b76ce46194d9a6e9b9e26fcf3f6682e2032aeb47a9fc54065837dfbb7ade66713c36ed09c212dae13ce6eefa188fd221d5a1796001a0e6e4f37e926ccd624f007aefd1cbe4d52569d1968742b80ed5f708a4e0099f958beacfbcbfc9ec86f7d78abbd9045b88044ba555181b07cbe1a3c559b5dbb56f0ab0ec09f6ee30612ad27b0b78a92c4539fd32f1b67d770066f5fbe19518f6f4436b2fd0ffa33c874034773d1af4cd5add040f758d1618dadde3b07c371e0d2c75ad077b544ce5e89ea66c30512c768bb30858f3c9264b0553b91330a5b9a5e9e2d3bd69baca2aad20b1b06c677c481f0548afe80fc4e3f58eff773132971124ef415a9755f6520da25c3d7d67489de181a17ff012e4dd510441477ea79c0c3a9443dba9d1d08983dbabfa511c9a104455c2c7a44b98fb2b31193fb491b5d4f906e8c7754ade46d3f5d69c39bc5e6b233049ecdabe5f35a36dad518c7b86289809306241fd1216da984abba5f45ada195abb72ea0c1c577b564ac5b3db32755ed5087883fdec2246188981adfd21850c6bb7834e1d63382e2d6bdc7385a3d8af05a1642e88deed1a11bc82f8e4a8903556278f46de316b45ae14097ea946c3a4369b0bb70da9bb69f3d7eb87806804ecb00a76493bdbe3a661178f5fb3f2ac082ce7de25638a81a5ffc58a32f47935b43e59fe01f6806569c4259105ad0ba3ac3769d87fa36b003bce613e09563280e0bfdee668a4b75ebe7d01122e3c8ab4db080e322ba89ef0f0c17009bad9d35ecb22f1a9f54dde7c0f2dc1fd97d514142830cc261b508affcec6a9155680788a262595dbbf564cbfe847ba4c8fc5256e4c489ef464d155f5552eef6c91897b734f26be34ecf7a7c1ee8863a93363df63cfef0be0c5ed841b6690c65cc27e8eee10cb98473c9c8fc9d599dab07bc378dfa202b831023591484a053c4997bc70eb2862d5559c2e993fd5ea1635bda9c86cad7f204676193752d462ffa8955a1c7d90921abe18f86af1c33a831a4077801980633240fc8625d6123692b2ff282dcfb9528f2c3f0eb585c4419032b86082c5a0424cbe870aff11f6b7ca0d72d43b84754ecde74d7d0cc15e8117c751758b4dd3a33396c8ad8d9c9f936cd4cfd7fd0237e8fbb5c3fe65b06abde86257021bb914f9db735ab6e823703190aa1c6aa269484bd36a20874746b21683273f2c0b06d3f102c9439e10193a5ad88b5cdbac4aa6cd6883c28c183523446f513c807407abf11498f99be6d558e909c49fd9e1eb68b87df5cdbb7e0496aa0af366f4abbf6c0326383e63e49301329bcd2fc3c1c5e7380ffc4b1959dc37ac5f5fd279b3f09799bd8df3c91dee41675d6a59bb96278a4fa61592b98dc15c50a4fd0587bf7663cecb2d9c98cd0ec71137e8b80a0ea8cf7754820697a9531c9c7f0ddc9945a9e0e798a15dad56423d81f4f0ac27cccf3a14aa18a4538ffc5a41468ad07e524495d7be2e6ec0d368604f3f9072ef63750812c11cee565a180c95f48f59933a23ce2d9582a1b9936bea4d6bde40c3f0d9f3ab00621738bf263dc715d4e7daa82749d1fedcbff3255913de174825864064d6b36108b93651dd994a8256b3829813aed68739e49cd7a9e37781de8223ddedee8693e8d48c0d6458e4e3dcdbee9013aee09a98f90e37b095a4112167b2f7e725ffa4ffb7e40e07c56155a6d3c83844fe172da9167baabd7b0f0106b38dccc149628e308ad3e28c3451ba8bf5c6ab4bdb961ea3a8a9088daf38d90c24b58b7982fc54bc171518827209e8c82409844211bccdee82d27a362a57942c88e753bdac907d7fe9752f3e80ff4f1e35d178a7a8175a772b44575aa02d17f4bdb9e2a21d182d11c4a755025b334242590a675401a82a7e332c4e923d00540b606c684e972c0bd00521d0e4a314fd755b9595a55425e6734516a707928ec10f500cc336328917a1297d385ed222d7a7e9002d4377b161266874c8dc29222aa03d83be43d5e9ec60041843feac422979e9fc35777d09448d5d78dbfd08884621bb79774ea24456c3c4c761d4662fe05396cc66880885d762dd903f839aa6668b043129e7b36cfee577ec6677fb8b66867e2ef5bdff0fae7cc18c1612ed9876740cb657953eff7082cbd74975e9a6df4b4ed0103c4c1f747564a104a143501cd7bec77855d9ff29fd6cfcf08b41ce678e9a302c4ace9fd278b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
