<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>This is a test website, use the password (not so young at heart) to enter.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a81543bfc47dfb6e2bb1dc1c892a28351a032f5ded80e0ac2b7f55da2a9671fad1ff51c12ad62568712e7f4c43260e159795bfdf7f7dfd57750fdb82d20089621c850456bb809c7eece42c8fafde016b74c87c2ec7507bef52185887688c2101c834fc55122cf3957b2b1caaa49b7df63d87efbe46f5adeb73a8866febb03936aa771c40c5d3a311ff7b59267c2b9269530ae790bc55bb5032ce4de62df6707b488cab5d5f01e3f4d61da18ecbc80fd8c53428adf60d6993c4997a32fafcaf79e1fbc840aaf479cc66beebe8ca7cf4c8f8a297c8410306cf24159076b647987f54b05b8989f98b12bb0554a79ddc9d7941874dc961df44758f5b540ed590c54096c47edd15cc613f852fcd93aaae373766a99028282c2979af115df304dd697a165cd3ac1c20d3dc688e99e3222f2f3fc2b5ba63765333a00b47b29d167463df451f2bdea32e26bd1df1ffd21764ce9b8cee90841b5d9627d5b0856e309496c70dde6db8df9969d704fad863b8171e8667e54839e48185989227d551f839e846d6fd868190060924d5685a50e7d20edae49bbe83e43983590ab9d93a8ce734dba952807fe797c3d65712ef83658aee75d2ea8c6c25608f4108dcdbb78498e5edf9fa7878061aaecb7d46cdd72093f4a47ebb46de85d51da6b30f49596cc97893d386f8a0196eb4b126ba2f0fc254cb955e1606483ac996be79b1b0c121376dae0f4106d9acef81ab8b54e76bbcd4d14b80fb31b78f77f61acee896786ff2ab1565bc0b637633c4e3d321a5e8b46eac4e86e071b173e580910baaa9a87d76def08c1ef7f6a0afeafc78710d071741d91b2502218cec891aee82191ac6adf9ebf0c73c759619b0ae51e225b306b4973c1277bdcc53b9a1e309f2a32903f96c92ea791ee17b1ee399d4308d4a4c365cba67b2b31a59588686dc9df687ae4faf1fde721e7f4959f3f3ee8874a21ee7710b61f50e500681c0a7f35f45754327f22c510de692b658489ef3b334aca2942c5d3c188f3f150911e008fd5dfdc7fd3f660bfbba92be7e770edf2e79d80dd3d982ec00224f0055c7f8e791498a0888a7d44538c9452e0253182cca63a86de203347d5dcf46f8dd141b658924697848e83645f5c58a4c67101e8102101c8eb6a5d6bc30993ba0bf5e9c2a8f2ee528556edd3129a9053224dbe0d3e95ddd5d65ca3db4dbded6b04fb2772431c723d9e9ab9afc24ef78dcf7f7834181e7a8ff1a842be32bb575e8cc6d676422f5543baf83a3d69d21332c8209db01c0b972743f6dfa4f6e825223f879e2769009105f09c2d857db1d9b243eee17d55013e8356f0e42ee8d5b385bde6b5a09d802e39effb41e3c52900a4d5d05967efeb8212141756ba518d169ba4cac91b1437d86f76f7e85ca514c20e747dad807bf034426705bd7bfb622f8f86fc33a6c1841178079bf1a15ede04220560dd2ffe0a4053f3fcc736487593ab4d425d1280bb143f35836710803dd93af512ddb30cfd6dc4f995e834ef04fe160ab988a5f1d8e1ae39fe5bdfc68dc9ebbc96f71fd5675b1b72eaeda81dada7c0a88938ffefc82dc60d965ce06bc9b530b6a78f7265acf23e1c40976396a534c0c8f01ca9e1a8151e7c11fddb3546f13ccfcd3038ee5ed0479d45efd7500a72ea3bce37f9b35b9c13e78e4907411d8a83d2c097e44e87d0f9024c981be6f54df0e72aa2fb7a72f0694c63c31bb1abc85ba40ca46cd099d9218294f3b4d7e3c62e791876a64321fa544e9d3d8822440b3e5c86a73bf4b9aa4f318982bd7e7e09d194ed18909fcbfd8a38e38fe61fe2e4e849047596ab70c8e031e1f13f27cbc0605f399583333096f92d6546e8eb6f744ccc4abcf0d4cb549279b98ff2ea18876a128b0552bcf8aaec7c6405f30c51bb3f092ac03cabb14832e584081174883a48b34109d9bc1601bb8eb08ed90a92759847750de98ef120d799877b8ad7d116f658403f098888a5569e2fb60eefc227a8446c1778cc8ce402fb30efcb6e2252e7ad7ddcb4076afaaa243c5b9b690e52681dc15009a158b8c87018b9f887aa102a1e51e491827661f57817948ca9fd17119c31bca68d158c27ab66c72f1b5012a7897ca529094bb982ca1be2b906261cc812625380df54e0eab0f56b36a9aa44ef980699bcc1e084cbc7c0d847fea2f2cd7b9409ef7f55c931ff7183bafc01d71b854327f9e0274f379d21123cb65019b2172b78468b4fb560c26a697639052fd6b3ce77d562b983068eccad7855623d4d7d76508edced7dd5dfe740661e63df9c0d75cffda188c88af56464b54bbe691213a4b4faf88909fc015fc76328183a4fbfc0b8f75004c4014a335ef9e614f50e37cc59a332d193e3cf2cd3f6e33667d8ef469b730bb9c970bf82fff1a3b4d8aba2ecca223143c17cb56711711e97f6db99b4d262434b4f550c1e542dc7ad10b43108ee882a2715f53e774becda30389aa93387b1e5775c46ce39bd0f58046e28b13e0c6d4132451b0ca865e7808f524b0d1863f33115ab1699269f4df67eb07d91b424c21a4712b4a337a93c314487fe7f0e413bbf5b47da3a972e81b35eaeab8c1779ea4b26a10626faa027cb3e617cdfa1a8486b02acbccc9dce5cb7465d06ac8dee2f1081f8984fe2133e49ddef185058cf834e828d1c652fb67ab02c171746caf09e492ca7bcfaba5ed26cc494bf0464ff8afecc3b3b9657972df41ce20e1523f1509550e090de0f6fda66ba7cc6327326f7c763fbbec139a972fc4631fda56843432122ebdac35fc3b1c69c734901fe50824a443ee9b762e3da4e7d62c299df535a5d5e109c2587f5d7f39b11dce9d876ac78aa558253bfa7521bb343048bafc9355ce6d9ade166ee31cd5c49869f20e27dc9d0832d56926d8c47e137d4331c6e8d04fbd56b0f29879b682ce3bf085cf0906285f33d951fe1d59e640d9a0b2f63f39e46a22421c94761022c059e38269d81399ef9f776c1d934ddeb4891e8161b7f619d9455383b88a8e96b90ebce357cae37b2f7da757c53bc0fde19931c067788be097026015ffd19e7073de1f33fe2d7066013af7693db51b540e9831a148bfbd640db0e93b5fe84b16aee693ace4d2fe88f4e6014ea1038e05d08f1e8cc06c0cca15d1b4e9240aac4a74060098af53c94e7daad2f472e787b99c65b78c75cffe00f4506ee24cc42e7528a7e56aa8caab68c99c1f7c3f29789961a7e7d894f655677923a41bed13872cbb9dd49c7911a68c3a9b3dff878fcd264d6ebcea54b5a3744437716d0b96f3cce53b91c318108315f130a1f1e4540f37003db3a5bd4def81236d393a96e05257b49c872d3a7318632799b46417397ed5b9cd1152424cc49ff6d01bf2692ba0dc88ae9457cbb5a788501404b95a728ac147f62494bd7833394ae43055784a89bcb40290c58e1ac17b9635eb8941b6159af28ef68d7b22567c9076e5955fce413e00a196e40ac47230a15cd3980ccf4731d047bc51d99cc229c15eeb3104ecc437a7ca26e9697220335db247a6513c1299779597fadf979d581f7fc08adfbc1f56207eac5038cbbb7b668767f1747d258f880abcf5f244bcedfc8366f23459d605f44d092c4844f6a1f305961a5f1da0f538b8b0d54a3ae5d5cb6cc4977a1ca29587938ef2e7d7c7fce79a02362d67fb374661da1a1f933bc1ff02be50f3d41ecd51b6a9dfcb3f991d69e24f46b82d215ddce904d5d7a920a144e638a273f39ff13429a67178a96ca883a27f9139826c98c2fb3c56b840f961713a444a1bbc2def14f4e978b03dadca16aff8ac154c0fa60bde35c56ca2bac064b7dbe79dc82b1da3327c3afafc45b79f186a5fb9791cce58c402152eb39ed1efcd5b3e111c7955016a494f1269f410c46a54f4ece240cface5b60131d08ac255c6e646ea42568a4d2be48e6442ed3f93d7e5ad47f4f4c630a6bee569ddc57a95af82396c9fadcb8e4ef84d052e9ac496f88273832f37912b3505ed34e4c9b8d070d478187c9388d75527f49e49ecfbd1e3634b6c1efc7621c300bcec903488495c01b77dff33f2b404a7b16ff108381dc1b0d0391ff37b1db637942278e5e15933068de3479f318fb536516bd270373ed0bb7fb1e7375927493f9c0f64969c418592ba49ff9a7600a05a422fe9bea5fbd9f5f49d1de263a024940a9525c00b5e95dbf3d1d3ab2af9c70805294b7dd40c91c5983a3ffa56caf9873e6057e358ab818845e358cc5f56d911f2117d31f2bee6bc46f1c39ee1bda7664b5ece3b52093e24ac3179a1ddacfd3bf91511f59b99f01a6bb9148a77bef66292bebfb70f43daeef3dbdab3be01dd44453c2fa899f50166eb3be63eb595ef39cacd0a02e0d40b7742b988110c58b00a5049a4582ceda05ce0f0d15ed9ee1589886a85165edcf9d39a0085c8a8043e6971a048dadce72fa230bbf791b24b2582812efafd6e1e6a4307a1d11c55a63c8990e0d2efd47cab430d5ffa4662f6d47c7193acaa88f35fd4158b5457e4f18dca5e05f8e7c28588b8618295c9b63c51b2b9ed6888b5fa017a7e40186f40a199577b67d28eaa834e4d30148033423fbeb028c89ca046a4df18fa16e0daba715d242188f00946a8047e20bfb845d98d94a864abb784d66caf72854539351172196189af67a2c65866c4f63bbe29f67333dc8de27262bdfbee4570d4eb1ff0a1a5b2fcb1e5f837ea9a81b28c1f0a2bc7c0b45c2789301b45d8d0055ba415ded66172e708ee9a0e3408ecdff7544c9f534b75944479b9d6ce1f0eef134764946699427d1443447c0f04a49de1b0484cf3624bcd38388531c528a9deafcf55ee620dcc76ef32337c7ad14afe1b72d41c949d7642af8f454b6ac6016d71dd94dc8fe86bb15bc562bb433c7b8b63486890346bc0ca67f735b9bbbc63a39c158fb3f69b4c95998fd777c024c70d1a3b3ed15ba6ed21f290d41b203bdb4f381ba96cc5a549fb1020daac08122d1d8d10bd815ef855d42afb6120237888638567fa0f8c7e3ca46c78b4bff67f02ee1b48fb47bf6d240dd383a4076145072a1c272ec2676c18065287eebffb6debdbb2b5996d66c50a8fb37e18d95e71d7de6c91e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
