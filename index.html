<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72456c8b7cd3e4cefc7900d0f3a9da9f485450d8f5693135b149873e720c3ee7c6768fdd4b0970713183fc453389b5f46562857e488b8c63e0088fc0da9b38cda72d134b350df647280dc097d3bc5c10751b7dd6076c7852dd15b11a6e29922c37b46bd455a2cbeb305083e25fb17a0339f50fdef7be55a0de0a4fd1ef3794f7fe6412c60840f15379c01246d3cc15b3282d22d7bc8a2c22187b27fa6a4038817c61257123091235c5ca39188d4858f79e5882490cf8087c38c1a9ee2b578c249c4e8c8decbb4be6390ccb0fd42143cded440492d5062d61665e90de764bdcfdcb8eb9e43aa68eedd4049d2a85e55cc62ad67a1f97e8bf921a011bceb733cfa1cc5718091c5e79e847976ad1bde9e07a6f3dfbf86b4985ff136a28b283a51badac30e1b6366db1bcbf03c9ff16348fd4fd98bd95dc1ea92bf336e9bcfff7a3c949d6fbe84f634ee9cad1c389103742152e0be1effee0ffc1ff08a7e48d908a99696097f87b74111993b2ef412eb79fb316280ae5ba5a017e2ce540ad577daaef1b567cf04ff22f5a86a33fd37af4d99df1c6109d7bd1e222b4af9824dc9666dd2e845d02de55c66b2acbb9354545b61b8028366e97ebcd5634c78a1dcf29ea2b5c9d7bf736539157118ba9a7ba4f38fa6a21615f10c18cc49a47834dc366eb78ceb14107db8dbe030c76ecc2723ee379753ab09eebf0878b72b412894093cb540224e903710a2eeda3cd1c20c9d4360cf75b71a9cdbb72850a3c7a6b72160bcc08cf1f36c876a0548610ebfe2139df53849a835fde3611b144a8b2ffad684bef3bab885b373fac897eecbc88b79759ece010a4ab4a3296a522d38c2b00d6ef23d418d41863edcd717bd62b3271a9ce35a466d85c9f4bedef457ad0417eec4951954d180af004af2667a12333a9ef8af8cd85658636f38167640871801e3c3909d506d12b9d9a676f59f71b599b19ae50897ae8191f1835d757f8ed9f7ab406b8e722675de152e65380ce561b804fee453b1eadc8d051bc71e9ae72aab7426d018b45facc68bea6b149d4db2cb330293185615ef4d0f0f479748bf4de8b93b86d24988bff97f907c0a34f287f3744caa7e166ee0587fdf15d4ae3c5c15809b00b85bf69b7d39cbc4918433a013d4d427049beca067182304dcb43623b3044c71f7869f005f77c100e0b7cb9aac72f1e6f5e8ae5cf43527527e00763605f39372592f3bd6b5dec48c154ab3977f3eec79ffd2d066f1ee96db0a27e7d09a8d285814769118bdd48973584ac50c7177c7a40c5a0cdbda685b701b4bc41a602c4eca2928ed39ec02f6d183322c7f2a8b52b5eedba6def815408feb78446a861feb5eb8cefd63b00480b6be44bf2e57f14b0af19dfb2804dc0209c1e16d7c0b886da9338290f04073a3691c298b0fbba8f781082c52ab41d8059159d24dd72814165d6f524e0a86bd2d09472c15022acab972165ae922266a178e476888c3d7e76607dc8859b08a126f61b9b7981c93bbb7dabb861278ba4762b3ba1e18b10ee4dd44fe42765a9648220c70449d81188a96f1e1e46745c3efa8aa4e7d6c5b9c7dd89e4b06efc1b17808fc22af38f2b6147a2669a8b94fc8177b0494b7f3e0e641c706dc573eee8386a8e135b253ebbacbc11ee575f9980bd4f748389d79e2b212084592ad8093f131ffedcd8a0df97d181bf658ebafdbc620dd6f9d3b6f105d98c20e70c96023d8604ba2659ef411eeeb44bd4273a50b34aa05639a0ea7b80df9c69afd028df63ca46f6fe332a09494da6fd64454b6650fc43bc6b27cd81328ca4b7699f37ca02a29afe42c75d0d8b6ec3f87f06652db1f3fb8edb8fc49cdc12079cb0268ee34053e3e47356f5ebb83a88de6813fbbc767f0ba2d76c39c2875671d8362e1ec94542fa06cd057dbdc9ca1104da513de18517f8c74bb4121c324726bc1d5569df556703283aa89abc9cec81ecfa4fb18111bb256b25695d511c04078911ec91e706d413ec89d136c2159926a970d3c99ad1608cfe85b09ffb320cf12f74df6a6fdc4149a75ff23501d8473efaa1151734ce949757ffc4a8f5872faa7462039f3db8ad3ada530162d619d38b0e6709088cc9ed0587c4b9eaf28f38b9a3a14d1ece83756dc7c4ab8c03d3aab30389ac250e9c24eb2935707ed96826c252c54917fa45aa80dace1fa891d27b7021b2d136f00bb922d8cfcd4ca389dc91a32eff9ba9b406723120c293ceadde4717ce04ab28ea6864db7aa707b146aec5f15ce4877d70dfa51f5a0e84938279673198c794aa80289360464acb3dc50d4669dd3fce05558afed6df4efefd4a62664cf93bd03afe62ae814013424be0d58eef7872d3f8ceeed79e1cffc4c517db11356f4b60ff4f2db3392239919d3163791a7b6fe33f1831909deafeddc06247c87d95fde6ea5c1ecae53cadc176c5ed685665373be622f5623beba1581e40025663c1d7ca1279a814808349d57b64212e5b630e3727c452569c2e35a8faca8ac1e5b261f3c427d8d247f5363d0259999d38582b01c7de465b5e02e1f004e984043bf438f9d3656e21d2a2211f8273020d5c8a06eeea6503f1876f579660108908be0d4461aaab94ab1ecd22305d6a2905e57fa35d0f16adaad22e1afc0093d7f2c05b444e895d3028585d1a81aca6df60e966afcbed3a0dbf5096da9cab3be86c0035dc1183b33b13fea499a4449ec3572f1fe59c0d7d5144767b97c8c17bfb09574076cbfd33a7078f03b59a575a3f25d27f96ae89f22eac1bd45c3f957297c35d71f7b90533029e1eefe280ed284ae3011f0c9ef277f8af74d4476050208b42a25657e3237d629ecd3d1c2d47a6e3d4ae3e48f450a1c5f0ca0a5e8e7373c43beabe407bc94d0e4577a65dca966eebbe3d623e937498f39b0a391afe63f4da0fdf848acdfb3abb7c84e4472617d7b493b7c79e79ffc2dc60211e55e8c9de4f3f24db7e5112de90ab9ee9451143e83ced45214fcd97c524402986e44c8446cfdc71dfda5801e147dbe87cfc0605b8da8ae2ab37c84d4b0ebf1033de26a9ad4b93fcace2a8477c37d83ab2a8194073bfc26779f94ff9b0bb3ff0f4c4efeb329893be6d055ee267fd324b0992c1e6fa7a113ee1f2b40535eeaa949a38ce513b39481e1b14bb45ff1f47c2f1f8bd52d2f22e22280dee67360631caf4c9937c16f73955454ba22d76837ba8833a180ddeb87e724d25365d7977431f7481f143a8a3977fb2543cc4917ffa1e4cda25271df0ecebdc2263dfc005e042f5902f4caf7a68f746629ebe67f046da60b76ef247c3913662e55a5679e2f117b7fac2e7bcb7f06ace158bbd905d326dfb2b1fa9e502a8c27b47179c01079995c18a8fa6685e6109935098d1c128c26179b95bf87db0a2c3d64f9558c2a69d5c11e370f6febba159262ecde8aca4151326eef4530879be3856533b340eebdbbd18de4e4277c5879ae93b6ef020a1b0732194c401782085c3aa205095a28d66fb7df47285b9e8f9fb3c1726525356a7903f47ec62370ffb6db3ab83f541e15dff2323a5453d034203a35c4432357bba86907a42f668ede262809f8be46a593772ba23b1ed16a3cf3b1fc84e6e1e87715cbe8fffe3650d7ef0e499db62603914c80c86cbe8a726ee1c268e186e521c51643282afc9dbaaeb14b6e8f872dd100b8612a1332649d60ee84244f8082add51458151a248a0e04b94caaa9faf685971d08a44054c0859cb1f3bd38f87912d4498444f26f44faf60cbf3b69084300c1b02e8578fb2aedadd8f673cf223a514823fb312fb2288d2857a47c08774ccb44ebb5dc1c2c09d2a97c4abe5e538a6110c261bbd217d5ace3532c54efef70d647e654643cbe881fe705e44a2e2af64bec53ff08dede07e7c8af175f5075eed0e53ea8ad634180ebc93e6864bd02622715006991c2abb58d11054e478c436b747a73fd8da9e4bfe1a303a0dd176c7240e34cc191cd5902271cd2cc055282dd93441b76482d29a81cefd1ed3fc7d0f01fb3ebd1953c1b20144ceeb1b6b14112871d0597da0cea3934b635288d1a1464615d281f9348fbf7835f4da0dd4df4a2f0ae003505d80967b45546ade0aa95082921486f78f5648b54fc9e899a4dc94f28284b9df98845be1d88417cbb39ff2b088f3e6ef602e2271ce7673dc515257d4173adf476790b70666f783323e7a73dec1a9b38e4e5ac97e32b62cb67e9ec8a4bde7ecf0cd1ff1176ddec8da58fd33301c4c15df38ae324300cce552983824a5a75115ac45b037622578b268ebb82ef533cd90136d336d928dc4e22a6eb1663c5240a53bf483ab3232cff01210fe2f876672816c745c644f453b96eb91672ceedac2ad8a55d18fa6c0df8142da735fb269bca7c25461617b9ffc86bd976054562eb7d78901f4e8e865f7da4a434145c694e90e0d9de047b70d86c9a007747c1b26630c80fd0ed3d217966f70159125197e99246bf864afe51f3c35ef420d13a7fb358e421aef157e727297b89f982a4950b609aeef7c75a0ab23a9aad2132243bab142f3ca60a945039791f45fcba9585f8072f6becc0a37eeff09309a088f7588936e0a85a03f2d3f5152da4da751f2d801752b02b1ca90ba9d7de3e93cbaf1d17eec96c2998622741265817683757a41e5e95b95fd02c5306230c9df116fc723e67f8bd2ff0140be5daeab324e6d899d55c2775f6c8d99f3fc1a62c4926756fb3e4e5435333e4507276175ef6b778f5e1501ccd5ab52487fea7547093e88f6993f764420f7af02475be99642411a86962e6a677b64454b7e4b909fcd1db5a1941665c572ddc7f8600022a79294faedb59db00e9baa805f2bf024922aebf9c20722cad674be8decb941b40ddf90e8653de94753842e162400dfdab3d011bae3fba549579372ade7574f1682beb0ade3ca7788259ff482f1e4cfbb65ae5ed1dc979db2da1779abc9d859118902517a4fd018237f2a3bb737c4c8cca9e929bbf2e5ccfebfbe88c7fd1e0fe4d2780e8fa4d6d86201f81fd3e7eadd23130865f7e0870bcabdeb9e013fd26c176a95798bd6d3b05503cb2713ae88185ad5d8166a9e9496c3d4e19b66d1316d47cf0df550b22ee970f1a17f4f3578916d7f2ae5fb01d2f287112fbde70fb9276d9baa8e39f137f367c2efcf4ee041d8f1ee63495add58f13fe08bebf6240455fb3636a4e77acfb16c1d104344ab8ecfb2f1563155aae1173a848169c52fba20cbd69db76b0ac4832bbfd6094c6deef5abbd9d0d459f2ead1dc4720748c546c2afa2b3e3567234902f1d773b7323f5d40f08ca5f34cc78171f9798a997b92025a6d6c42b10791103fa8ca6760f12c33fb04c243b6981df197a83f06193eb5c585b521500dacd98295c3325d15f73e104103499e9f0254d47ffa2160665c611b06f9717960fc87a13573622fb392be15aba768f11384bcc76b3e374d9911c2309d2b692b1974413e3d70ce8062b1097a0b965a1b2732a07f5f1a629063e67e17da83b6f77100ff264542e19f1f41d24636a4505f3db9b326f0d5d15e2725b35979f0c3b26019d50ed5dbb48009713a36e4656affe271aed7d59ac28298a51bfb5b3a72169a2bb05328d3798dad362a2a3b1deab9f1d055c73bd128b2f7fd5a22c40036f43ab6c4788200ba0515d87ed3468b334ee8bc9ec8fa170ce7c7eeb457700179b86f8cc4cb1a8ce56fb942a28c7c0a40b91ee0735e779801e883258a6af1d308b4bb24ca7591830526587119211702cdb8ff8841d492a31ac3a7b9ba8a202a2b62a72eaf6c48bf2d69725f15a82c292ee0ddc34d41ef7b4e691d100ca6f4c7a8da2b72df5afa5b1584ca4df8c1f51621f679a485e5bd21c69db1179123d199e808180c48669ef3fd944ba22488a9811061e531938c59c5d03a23b30225cab46582f8d01b6146a5718ba10d8a3a249a780e36721a9c20fe45f0f9ce9adc5be3cf01cf916c8b00779b3920e3161d0d3d2ae4fff61224609e86a0cc46d71fe37ba590463f672ca0f455cd3da83d0af1f5305ebd0aafc2960cc741c2e7d8d8bc8e4d988048d2d1029590c1b0989632a9ca1364e8ed81e2a42cf215ec56e099b871a2b71237b1c90fef595f83ab33d9b4edfffdffa88ad2d880553fa148eaa00507dcbb98ca175a7ee28b888f61adf51267d8dd242e1b0bc49686dc9a9145b8485f3a7bc09b11f639af5a6baa58d7eaf16b37c807ecee58d6d2affb216180d76eacfeadce26a2650d9a05bf4c1c9d19e7353dc8a375c924302cd51d61a9f061650f9d19e455658b71f48330cbbafd28baff2166f4f96851b2851a68269b9901b107e8d7bae0722d372bfd096f5e2a2cf248aad2d6936033ef3a1e5259edcd40450f3f12e7dc72c8f63618cb440323c4016275f06f7beef29a91ff45f0fdf7cf762deac0c991e62a2c0f6bf39cb03f0e2bb0f2481b9dbb967511aa6868f207e7b70388461d5a5d474b314a31349177a1299deeb02f8d84ff881a78d55e5d451b522f65f353baa996d705319f2cb5392f68460dcbf8cb30866a81c5a3de826e49f1d3084946df339f2ddf106ce363b972f5d32519f2f61d453e1146864b6f2f4158986a4fb731f87aab498844e4243ae6d361d247e46a2194598ef6d7c6b0c4098958849307b2b1c847a08271c83e827667953b8463ee68a104c757952cf0611b0207decdfa313efaa3c930258c4729a4edb0ae78c52863a23c4a2ee7e61d7c68aa6e55156ec7fd7a288d92abe689d80d601b5298acbe7ebacea72e0367e3d67dcf56d71665e951db51240e54a9913023e07c078136a8b37c8fa55cd6f33fd72674dc54b919b96649825c747485966dd8ed3625d4d9e7546a4769edca05934ed70511f7c02b552db74ae9e3f0e22d4ff0f53ebf192ad8c59c214ad2c073e7f00da13cca35939e2f23f4bfcac36216289db1101d49b0372d7dd09cd85037b8f3bbfbc707b8e0aa3ec76aca8be318ede6102f88745ac6dbad435f15a8cad65944f146d48d81bac78f8f5fe73a92a2642747b3f386f18c11da6b8eb7a8fceb4975ed884676c6c53e15bb26fcf5af2ffe3e673653db5b7deb3f3f860728627e29c50beb335dc2078020f01d9b926b8664f02ad875b260847635eff0a2b63ff83b8f2df37a14952cce211a5fe4e0ec95548b7b8f5fcef4073344a2fecae04ee4f8fe8f59d45129ec24d6032cb75bfb27a62be5ceb9f4add539c2b56460014aea91bbd2f4b2b3d4a9b20050fe48ed1fbd0192a3526a301b5f52f95491247c07422da0bffcd493c9ac44990a37ba583ffbf9aae30d36bbcddf3820a1a56147d6b32332ad61c283281bb0b3ac0bbaa15e7ff46049e6e8e5f02ca742b420881bc5c5b1eac6f980601b774b9e8b69aee5efdd7f16344e0fa29174da0fb5c93ab5735ee88f3cc8617e96fd35d73396bc5864629c0ebbdc19caab868c00154e47040f2d74e02a503c53ddbcf7808180ac31a1d1c5a763ffc998f9582f47f31125bf72a3767d6c16cdc002fc8a786926a112d8ed5a2e7e3914b8ffebf6e7618a4bc6b5ed1598fd40989e0cbd2ad01e5fdd1f690208fd02ad02c9beb3b506ed2e3b209e0ca78d2d5a3ec5d2a65fdd48fb66d3c8766c34de97ad998a1b0c0ae636ec9d3d7c5baf334c225ee91e6f028896e3ee9836baa53bd7345b8bf9aef815b9844b5874ff6fb2aa3dfd3e66f56dc2ed1228f675adb744e047ded12e5586ab95d4e725c2ea6c17f3f0c5a75aad53764438e5ddc5f4c0b510f04b7684b4dcb507ce182b66733ace3e1cfb68db5ae0691b6652d5add548a294793ec747730109d36197fe3a26ede93b5a964c94791a46f8bc66801e6c4583e2a10b64ef299d883d6f187e857bf00cced80d488d9f9913d4a5fa68c17085c0a1ee20e91dca0efc5a2a67807f3377129a6fcf24961eef550316db8e09c79f18c0053c7b4fdfb11f1bc01e41015704b91ac47c8a010f6d51099c43fb6979e1ba6a723e3f59d075ed983a8aba41f5f0eff263c7b6beb76111f79c8bde92ee8f38da95b77a5cb9a76f61e5477c497ec4a7be25b6362facc2520d584b836b49959ea364f6c3b311ecc005b6cafdd02493d322040ce1848ea6a50b6a0768bb1097c293f06d9e030277d96d12c2906ca219e69fd1ba87cc1b0d3f86eb50bfb8f662e171f27f8bf68d82460c0b980ccaf1d155b2cf18d9b37da2719f7e59bd9fec00631b79a547dc05bd916875c644f792372c0ed6e9913eabd050180c18a85247efe819b694c633661538b2fcf1d04e697b7ef817ae9dea11a37bdd9e0f0071ee1c3bb540801085572d5fda69d5b3eea69e87cda0f44e9c082e796b3dfee2a4dc15d652d46aee991e6a69d6f9a28bd9d3e236f06483a5fb2f751e540febcddd5af6c7f588f32651a0476df9c178556c61b23e532064a623632028e3bddc9a5f4eb5e99aa0bd8ad1911fd182a92ccc58478f3720a80e8a1e4ddbce829952f0c767e59fb1aaedc8358363872b67a4ee6f675480529ef9e2c597b9adc22062ecc78e2052ec9006e119313e9339476111ee613a38f67a863963d5c9a342d05dd78558aba481831d81c397d92199f1247d73a5957802b32f67a986ed0afe626031656c41b62ef307d7c820515552d4df0d72b04042610e8506b641a66e3258328f7292789118d69aa1f621ef78c32fcf487b5a59042bae6fbbd878198c718a4171f785ef7e34aac2c772c2f6e5dad3503ed3c7ccce8f2be2554c42f6620c1f8831bbc4a7b3590031276c0b223a5cea974b13669ebad408e13e9347cfce44405349d9cefdaa32e2d14bd2b298e93d0def932ee7b3eeeb6f6e36a6f1449c9a89e9fe9f633861266fc75c8ddc297f38e6e4a958e4fc5b98fba29b4bf1034f58ab67a7564da598f6caf4da7ba80f38ac5f3817642b669381138a7b07c04f60fe08158741bc038c17359010da1fa9bc0963721b3535df8aeace8871e7dc69cb63443c0827d70c214742419b3fbf89f97f76963268b64cfb78cf7ffee25bd180d2654c84d851f4046966aa4979dee401946ad9a081557e978b9ed727e43d3938c6ef1da2234234ef80313134da9e65dc1c18814c8a7b5cef26d0fd29157d19b80fda708ef65d90b01a476151f8f3fa8f07c5aa23adbb5bfd916e3f0895e618974f76b05cb6a60c04123eedc53f65800eae86e0ef79f77b992e2963a8418fc7b9910be38f75eae16e35f4a889825c5759d42b62b177d1e9cf776e5d1301867d7b865b58317cb2a741c9bc07fd6e8fce42273d08da4db1c15620d867ad4b019d06ccc9f3999b00f0796f86d870ec598ea5179325f9fd2c4e06df425ea9752e60c5f9a0d018d7fae1d57ace8aff26f52b312512a34c660a1165b7821f49e7b62ab62be628c980ed6d36571f1b30d857a040dba6e67be51841e9f3c9b5c0f7e0dd91ad936486e620ca0eec8854b4f7ef7856b2c2d2dfd9fb84c7280b773497dcdfccc217ae3eb39f5682e9c408af11c92dbdcef0a0949e1e274a1e6c2446b91942b7e0b30a3f904070de7ca7d24b5ca249e913cca6b789499f90e24555d781b7dc3f2a7fabcd88a7930746d0a066e688937bc1ac1915b796c8f2af4f9ef6721453df191822f3d5bd9123fe76a920148f7c23595c0864c340a85196201d457075e1898b39ba70ed18d398f81cfb61264de39460d0f184f736e64f61cb1af04a081ece2299f5831d33b8ef0c923005fca48c831ccd1bdf2b17bbec4952c38faf7d80c14f5f5a22c101f2c2ed060f57c6529589144cebbf5711b54e1376634bda6e5fe52f1a2b97f6661cc71a663aa9a09875844fad6ce6aca5d81d966923f8c028b122a9e292fa33d0b53db52aaac7558369f632a0c19cac264ae714f0cb9e6fd3b8b004441e92c8e48b2957306d2e5e6434d8f1b7bfb6fda3ac819fd7a1a0d6d2207d51531c935b2a0b0172e35cb724fed4decf8ef343f70da7228cc6b81ccbba3d915141a758f48e2475b370493713e0512e94300f92c00761606530d5efdf98d242e19902bf8f5975eb4f7541a8d72683b2fb54b29839b1a8f49daec8b8d52a72657834c1533ab8f7a9336568005c9501fa8d7573e090fbbab11c5d5401ff93480988a7bc5e453113484949bfebf1ef8da03740638b7d82a24e98e4de5058cf69a94a9e08d8139b7f7cd75c7e18ed0877a7884c11978e3b572dbc4a81e5291045d8a5947e696e96eddfe22cf1242252db5c63687aa79b71098a6de81561eeb498e7fec3d2ad21ad425258e0dd0b9d4a83532416c83a5ede5566bb1b19188741076ccb7a0031b2821ba745119304cf892009aeb74aebd36ae5997a8ac414bc49684642f8dae360155c79eab47407c1ea8af788e9c2b32bdbaf29dd3f35b03cb0aee3da03b11b69cd2109fd08f3035fe5dd1091e3c0ee5110b61065dd562c770c17c8e0a9b7bb0e07476c8f9ea8b4ebec97667b0842dd7a0e3622679e999c005288edf27718d660aea446fdcaac5ee63c2d341ed2f0a2fbf8d1c9eec40d7580b98328a54e81611caf18f8cc787862e5b09046d7617137b597621a00b66a5d374f1b1999caec32c9a6d6ee2b2a38154587cdca5f09489386de99a95e64cd13a77571aafc1e056b8d0da495f1ed019ed3dc29d4406e16da995af371abbb7336dfa4ecaf49b26383c1ea7dc83cefaec2ff62404f829e095dadb7f878519827fd02e2f056dc79125bf74639024cc4054602e1bb4049eb0a428f4d99bcca2bf10105b801d8d2905b2cb80f3f51dd6ffc0a2c7f1461773af926444dd78fef6e632220d49cdb5be223949f58897894afe8e9215901c37fad935cc24ccaada17b563b5377a3efdb278d8002444088f9b47749c4ef7ec14aa3e7789882680f7b679118708e269fe32448d8dc512b69a6b40011770e45c540ce69d236445b495807566365fb1d96b8a9a5787d414b6c1d6e1acb403bcf2f6829a6afdc4e5bbeba467821d9cdb643073a06cba2c2f8bdcfd3bf5043b5efd97ceacdbedd7fb5e8850f4e67276cd947971cdbcfce8fe3849c7f7c30dedc5ad6c075ace234da67384fde5afb5ec02bb9fc84fea8007a937a4f6783d19b4b5ad9fa2803a1a10ab96a7202a0a0da9f7a67bb399b5d34bd46bad3b1228620d98fc9a3a62713d53cf590840182379605fb16abf41ee1b6bfeeb33fa215926eda828f4eccfb0f5fecc2d99f983f8588da827f03ff28bfb5badfe711adda9892c1140e42ec782a157eb58fbcc8d56758895fbad455e2f0ac142a022b3f7a1df1d7f470d433b3b41a4eb6176413e4641997138bf010fe2df24397b3782335dbd2d5c88d520d61c041ab02b233effbfebe8bbf795d4f46d65d320b8f8358f2c99cfe1bc1e5227c0a918b266cffacf4f98c2a5b8f87aa2265487012f564e968571d14b47b4733702a2b6b746ddf659bcf208b25157bf1417a8eaf4b41c46a24dc8f7b1347f80f099cdbc8a40323fead785726dcd6c4d73ac4c81d9babe9336c18221b3c20d3246a5916701d8a85a596de42c027de4c750be8b59a26358e72e2c9e52fb0b5e2ea9a4f02e82e1caeff80d8bb93b01de823bcfdddb2ba5fb0f8b3998c04a5bde81f0d8f9239718dca598b6a4a405129b4ac50c8e22057e18c918aa286cbf26da064a04fe60d490f2bd2cdf916fe5483ed54de133e1acc9f4a1048dbb39c570b81709d3859455bcc1f81eada2469cca01c14efc45e427b3dde637799f35d3d6e12e20a01b6f266c40430ca27a353884f52925df4ec13fe1a96f7873ba2c1b1fb9f4229e901cf9552e63e9210d9141ef36f7ace0326f689b938d8de5da1f14fcbce558a1fdd22d9f84eb045dc8cac01da3e9b7c555ed1cee6da1c475357c1ecd565e8d9aa285f532606c3498988543b865c3a2035e2e08cf0376d638e79d434789278b936c77405c34586cca0fe3ce38a057d85d65503690ae0cf0cf2c32632b85782cdcf4a040ea2e10b76d5b38a604ef00eed66752083c88e6ac191fabecee76da02896a4176dc4e1e982afbbfe8bd4f3c1550abed54e7fd9161a4eef850e98bbefeb428d829041afeab1fa9d62fb36b6f0541b9412265cd90becbf9c0c211b16ebc56095f63e8714c33f1248e9d956be910b0de1434d62008398b3c69c3fc6e1539aa01ddb0db2d48a6442dacd2bdd97e33563c803a8edaece0f16b7e1f0c6f43793f83b6ce5144a1271ff2460739c7791a32743520c89a84dfdb2c8844bf27960ccf03d94f989fe4b37e6aca122787afc0a5c8f3553b6449fc2ffcf8ebee869289c1cc9ec06c5d6704886b70aed655e237fc1b9ab8ef69a8e8270dbb0e6dd477a408c34522840dc48b011ed2c133c4aff499e5dd45f14c6b917990d791912a0512f30575010691b3b0310e46a3a4417f06a7d48f8119f787174919285223151cafae368c745a43a15b967ca3db1eea6f29baa224818c18226d9b95c1ae9c81d88147d342a68731c266488b468a3df07324761763c02cec12c0cb9d35f3fbd99ab7cab80fd2ebdee02536bbd02d8d071e43e67fc13f11a5f11316db9f90f9834650900c33ceda0a6a3b68893712641dbae6bbc8ce817dc9c9a60e7db117900d2e312a698305d2207c0fc501d9ba85a15a08c396eedc7819627740e2d7d953b53f267ddcb53dee16713a6061dd3b1dd3e3f1651686b9c25403b85397cd6912fe3faca7f567611d6f23f07e7884ac74e7497571ce54dd515de3f28b2ccd54ebf3021c7cd00433911e85ce63cce337ffe7abcfd3ecaf7c855c455079ac549f40ba9cd4ca4b6ddb0dd9599b9d072e2d0f6e325acb48354b62be9b0e4777ae1c8bed4706ffb0443d321cd108e48f0c8c854a4d5a52893739108bfcd78157d437f8fdc56819214ea619b4877d0c5e048b762665d6ee09242358b323b7ffd983b7aa29fedf6e086da579e433fd0498b7cc3dc799729b44c70a4a522e52ec5434367bcc5bc2d42a1fb7090eb74c11e09410aec55f857006196cf0da7bf10f4cd5e424ec5a3a4f239dcc02aad8c2b8255266a0f7b5839e681eb52788ed5740927be7a57e31fc83911290888331908828cd9076c2499639f43cd2101a754bf0d3c4d2f9760afe1b9f0265495edb0d576fd59d2eafa095b9cc3e5ea6bb7d7ccc512acbc58e3893252eedf1d8fd31b762205c794bf3c2cbca659b0cc9d4d0fa74bb269429ecc60bdef781d59556e9c9393ed1cda10eea610d73c224ed0bada830e9672256ae98a1b04ffab2e716e4cfcaa9b19c6bfae00a27c74146fd632ec72d3493dcf6f9034009c2b774b32b1be9c360d89ef27538461b3ff693d8ea0c2ee5f330048c4f94f39c2fea32baa06f31156d8a2a9c309f43404639545942359182f67370333bbf21391fc94204f472bf26cb63c91fb2afa46582a62609bd74f5715117c05a887b6128e0c0c048785dd16a242d1fb79ba5a3afdde9af53721ee40dd4d9f6d83ab80cfa6f221791af59a49487bdd5fb365d2241a5de7d78b3ac37e6c6e4b6960ffc53cbf1ae47179673d04ab40e1d8850d5d9302aeda6ec552e0129ad25e6fb3602ac70c75538d1c99e28baf58e302bfaf238653ffface46f9279837348d3fad8a23aab99d9f282a023fcb0b904ae5d6ae08a7df8c14c80386708c22eed476bf697408c09343ddf2b528c43d72f4b9638c378f11980402205de6cba5ef5fd43ff5d6331ad9e1dc39550772538fda1da50e7ee9781ae1f5e051d6d6a2e1990316728ba57873f492d24a70bb354239962cfa77aeb5337f3b6213537df68455586d4eb7950308c978bdf47f7eb4ac654630f2461248838eb9d8dd94885ed69e484909daf33f571d74672a289b36e52eaadb7866b92f4593f58d6d39f090f65c9b0ac1a3148a764a81177d7d827be9366f64089de32a11157353d6b0933a1dac9a23be16dd1d74b2b7793ed4cc7ecb67ddc71a15b5a48eb842bd82eecb86c765500f73cd4489a957caaf19acbcd1d7b4852b8aef2c8e73c6fc982ed2fa756e82c7cd540836a5375d301e8b8471ba5a2691c181e5b31b8ebdca488d6e477ff0691ad94403e22ea9dcf489c2a7178d164d7cdec27cfa0fb6a8546df69c139d00069887d95cc0e2ab114f812ddd2c65d385fad35251bdbe2fdb1bfe8a2fbafa7f9c5a685ff6a37a64149b37746bdb7dab7f2862473ed47c93b67e7fb5762122b54c2aa13ec4c9dab1200990ce5039fa434ed2c8d7bb9f8406ff4b76741bf61c7307286ecdea87bca4fab3a1fddfde31ed3fe262f066f727b0ce05b228a71837b357e8027147f8c0ead405074b9885aa392cfda1cabc9ea0a1ec029de1a1eb53626281933136a540eb95664c35bd3bba1b9b95d675e78ae74dc8ecf2dde48433c18f90a3ca77f338742f4673d41e0a6cbfcc7e695aba9315be9249a9d98a148d0b21dca25dc95aa72fa896cbefbc3fd3e822b9cad329cbbf98286baa071710b7ddb2c4babc1164c1d0742e894246c3f2f284e1610e5d3c585ce2d9983a267c4fd1dfb54ccc46f179264a67137e06994cc3d7e81c44838c937cd421d04f56603a3a343e8d3f71c345d95393c52bd64fda4c1330052574ab678d604c8b72854b621ed52de22ac2812194676b021b987959315d292a7a5d7a637f6ea3012805977d35ee357134ec1e9c2f755dc5f0e0df3c8405a3fcef69b358164ecf8bb519c4be7b1a9252894e527f40ba6b79c354fe3713d28ea94c2a693feebc7d2b0d11e695c01dbe9b973a8ec1216bf3eec874e1bba243f0d10108aa201a183e7cd36b51e805df62d67ed6f6e9901fe88d6bf05585da660acbee1a0fdd423acfd043b2bb0751e5927fc7cb7983e34ca065d84eecaa02218ca08c382f23e185469c4da8c858788ca28cd7f11fa2278ac93a895134c5ae47f8adc9201005ed1b700fa5f4aa4747c30a28007b05c489e7f59a0037015976f3fe38772bb588290777940a344e58fcf1becd5c6178bb72290d42d23a9b42d3e9e3528cf2d33ee2f4c95758b4d87117d01dd0bf452a48b322b0310011f392c05ba6f132a5b6bc7702655c544a8ac796d8a77c75aa1622b30c72c663709dfea7fa96de5ec53efb0695daae153c1be33390d2e966fd826e05b83572cacc516f7f3b3c1e79260ac2dec6cc6d4f5367f6c3e529151f29fd6fecef7b5106da93a31c94c4b57c4fe418d112e2f1c04e73cd4542d5d17c206e90f652c11972497c586e508a92d9cac6a5046174ea167387822d8daa6c5e1cb698144456656c73fff546814118743045848bd5eeba3d01f864c24ddae08e2cdea9e01adec38bfafe963d4bcccc32ac5aadb2dedeca043551a0442c9e261408c96f1baf8aa9a92acbd6b34aa9b6517aa2267229fb8f71eadb945a098ab38ba436aa31d56520c7287d9a32f1df3aa521bdb99caa5e31cb06cac4b50c5df59c863556562a194c0c3c170a06c24589d9366807be7f00be7b525aaa37199be1ee6d12897c64949d94e445586ef7ad9c8931dd4f22db8d98066fb265bec4e980c967cb0fc71539208dc0ce317be6dd6ed7fb19629aef5f41417b0bc3423d97488125ad2f7b0e82215b28f5133f0b1c56a4abd7f1e45d9775b39ced23e219bfa56737b6ecd25131bb28aa1bcc5dfece283e7163e2e3f07cfb5fc66fd9e8951fdb7945f1972e2336eb5b3e8e00d1cff1e48845a37594fd7c9f79a186521f15172123692510007c3f0ff0641c3a0a0a4304ae80f6054167462e95bf839e819119eac8af34794b777dda6fa739376e4f7f025e3fc1267113e96853a0f1845bff743a952e27f10d6067524b1d5a8d975a102e89385cf45819e5be91b3678f8bf7cd57ec1f3f1356796f70ec1e260adfbfac1ab6f488c2e6d2dc1b553067cba4b59eee0c5f81a7c1545a2cd2634f10d17b0b36eb4a9b970d988f0b557f4646546656f90adf56f62391473c0c93b1b4ca02a5140b49cd9628def215339b29d3b06e59ebfa08387228038c8a7e8fe7656cc38ea88c24563566e1c37f49abdefc7bcd6917fd357a9aaa51fce7fdd7374c0b101d83e98244e28ea960c7b8299b1fb8d4aa4416b29bbbe59b0409cc4b445454ed6dd24bd0e43d5445b92b1fe8b7a65261f39680808f1cbb334221641a5f68043db77c859d4fdbcccf2a9d1f9b8f7fdf203c5f3a543158092fa9afdbd7d3b46d181b0d1a9a7136ce97491c1d80cae286c97198590aa2e18f779a88cf97446e96813d1723cf547e295b15f70a0546f6ad7a808ef8c99b7649a07593dd7f34bad3da304a8184150f5280d952819cce70f43764103b22c23e168a083ea118e3ddfe01c795bf778fbb5eb046bc937c3f1f7739031940748941da7c75bf1c1f95b35ec47f5e3a4b57d0cde8541ddeb93931a5cf899d10911fa3bdea6bd80f1da57ec59dad3375a24064b936494d6ec59cb2dba667f79ebb43ff066eea5c9bf29e4a25ecb2a1e6715d8f9da74a69930d515538cfd4aea4e1613ee3396ee6e338e696b46222dcc8f94d0229b6b2a4b91b85a9d62316790c5df514799a4c120b4944356f21d34a6e27c6057c8420ad2658649a71f46dd8843de897f6436c143ba5f1f8a7fc642511e2a4083fe53868ac13ad03a8c62819bab33e881366847554f7a461cfebc1253286d4d21eb599d3e579e75220c9d3fb98d06b034ba253da92526ee546c59f403343c7728115958647665c196ce785291947f6273a333f0a09a00b39801cab922772d84ff4c47b544ea9d835f7f30514eb723d957add351a17783eecb9c2f4bf9115ec479a3400349c6df227a6551c45b551934a6f6e88b856fbf481a318635cb02116ee0984fbf453845b91cacb975466a474cfa44ade02f0da9af2515c070504872afc0c418df2cf130c4d6bc3a81a378dd6a030b957d0498932cca2570c09978f7e6b8a274e4aa85187484eb3104f3b980ba7b53e68e229d77eececb2bbe2bc37e9e29b16eeea5478a2e444bb63a6fccb6350ff982dac94058804489d313e4f922aaf73dbbafeb181c57534f13d524ae458495a8ecf63ea7f08e051957c118258f1310e94f355f8eca76364b604e39212ee4f065c6acbfb81d5ef912e747255aeecac740ff20ad1fdfcadf8bd0957d78608c730cf9793dbdad268bd9aab220f68aed57cc22934f6602783504bb0c01dc57b9316f0107abe047715311b4a8c3b9fe623149407d1fb26c242a8a7249dc2396391f7e3fb15985d48a4970144ad7eddc1a8aa5be5b7409e8de1fbd7d5dc73ab494607679d90fabbedf08707db656aeb5483149ff5e8218dfde64866aa143178ca77ac9fce1a93fb55741980935900632a746cd27e18d29c6a96cea663be98f5839bfa51c30d5cde3d980ef36809df7390f3fe83d23945c6a33113f57c9854a3ef4f98f68fba7297b718081b0c91522d617c2bd7e97ab44887fee3e32f1412312cd4cdd0066e2364c2a893e3f147baed86fc1c57ad6f590ddcdb8b29b08412ebac4f18d6a6887165ae179adf39fded9ca53be3f9b4b4cd485ec94b3df96515896a77f2a9897c3b8430de6dcb74e9fa751ffdee16bc952dee080c7b2dd78f1d7d67f78cbf3014859905101781fcd10879d2d550e6c51fadbcc4c5daccc1dedf366fc74dc879fd71dbe882cdde26afd81069b593746141237ea8b30720997405b3df82a420c8679362ab4aa4fdff3d0b0b80cd589863edd1beba6a42a1ffd16df6116b0b4ea394948675cdc8c84cc428415a1ea76cd2ca230bfd8f5d7000fc0ca5d07810c9c3fa4ac51eb7b1b04a4583126a120643fbcaa1df49ebe385fadff5a4bfb5299a7d79e452a3ea307276470600f8c3e34fa5d2d76a2d6343d9d6a0f97052a31d7286d784f8d871a5e5dfda814034e68fb0317cd8fb7bba16117f672c00688a62bb8c3694a714cf3de16df3746c95d42606eab29fdaa37522e008daa9d3381bc46ece389bd70d84f8ccdb58d17c047cbadbe34e8bd294e139f5fea6f14082798582e4c34d88c2d42f089b5727387acd165a23864792930a9d02a91ee1dbea39aa8dda728a7554d53551199b8fd035f9cd58104cf84358610b60657af7c7121f219db76b444550c30c631bfbd42483c491f1ed51903b1ef59d12516a89d30c612ce98c249b84367457264b47d8c40dd185e041f1e0092794462b4da66f3642ddad320225aa518a8e54757b1066ceedd87bbcf3c3dba9b703386b9d5687e4b11e8d6bbdfe6dc594deb467a6d8612d02854a31d5c86872677a3c751bb4dac2a0f3efad6e5653321e0b9ea229581ae8b2991b1e29ae97cc9c11bb05f180f07705b8ebdf27ff04fe46f2b7012f84b8835d29520c59f1c8c6f2e27ad97d11e6fc93cdd04d4f7b03c72bf922d3e9065b14daa1f530f093dd9af254ee361bb0f9a0d1bd93b9605bd3956bebbb612d10b8588aec31b7d6026b0f6e1fca6c98a0a96ccad5f4b1fdc565ad6287fb8e6cedaabc05e9301622d29a475d165d4447ecd65af7f7a92c287835068860b4f16f02ba1ad1ee7d2d3c283c270af65f9ac2274fb86dc2ead79252ca6e06a3782e34528a35011d9650439a0b680f43d9e4eeefdb8f88acf08eb31d8941154af0830587b8ddf9b0d7d53f41cacb6a4075b8275cffba1ee2578ce6c626b16f5294916a4a1f0b0159cfbd8a3b83c6f97ded9d347281046071985648ddb82e25bc6607aa2685636591e84841633c2991937bc27cffd0bb1931746378e69ba501d068f2d0ae8adb97f0b64c64acb23eadb9f4d99611f98e34c0f57d4639f53e9d24da8ab7fdc9a344ce5aa2787913e27572f0982fbd024382774ed209378ff29d4e61e315e9bdd7ac52faa36d43c05416b1e1b178ae44afdb15cce72b46673b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
