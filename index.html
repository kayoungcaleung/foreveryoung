<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a85f3bebea786f72ddb35ff7337125658b4c15a5e16474cb48aea3a05e3672e5c4f0804d60330d5365fe4e94698d6e211ef5d46937234c5f30f0d48105243df0d0b9a5e9e2451ad16ae6248f952ab8a092807727cdc5cf635b6b07206dd80b69316365cefb1441a09bec0ece644b2c9ffeedc0b9bd2fd32dc0d2bfedc96f15e3ebeb8f4d11d9f2b16c79f9703b7ad4f872f73a33fc56f9613a61235205ce0a9a859cdb7c3ee552bc3d8f750d2d402aaa20da8500a6c832b5577394a7bea313a4b58749688b6346390de43283f57d11b0e9a596a59a59fe3fac927729b87e0998618e9c3af7ab26998edccfe3949a24a88617bf0f1c46cc8f4d1ca5c7fd1ca58bfc1b00422a180ea8c0408337b399c271d139a9e03d72a4f1d66ac79eab9229d331daccf928042504107e3bbdc4641726768ae22a766ab823f70d0ee94f628a59bb280db135240e14748254bbfaa1b9ff2b6ab836f9783ac55bcc52db3c4d8774c5048c61a2791130bc93f51d4103bc8e5c6cc736a1f208152e24be6f6e0c7daae59d580b80dcea3d88b4abb4dae61df212cb319bd0c1133898c98777f84b2d00b5d9e8da97653a3ae7c42e88fed9176a25945bc4004cf6ba2795b0c7d2e64e508ff569ef8c7a1541fbc79c74cc39e23349f1e99fe3b8887e7722aab62ce245b17d1f1b2b77580a799cdca357731bc135d6273531b98de2ca50f55a9e65bc2b0d091b09bca45c7fcf0f0767b68ee3eb1650bcbaba0174826069382614c7cfc5646ed77e121970ec46fb2dad9e9237c4b47932205f144242dd24eed129a30e72990e9e666ebf94f9de2b0afd595af9a415ae4a845c90019e7a2d7a64203362d95181fb07ff1d191168368c32cfbf7dc63b2b309b2b1ba39368e7a8b7656a084148516752d7dae3dd8f74484c84d279dc7f32db595a8f5451939969928fae093e732768c51aad3abc7597fa6a5161cea36f4c8da74e8b4bbaf463edf341ae1582e296a438265fc918eaf82ada7d976421006235d74cbb1e4eab9be33e07e76302891ad848bcd5a319b01b26fbd852ca8ba497bed622bcc1a9ecb3f4ddc632cd39d8f32d94258985e26d158080f969a7a8a90d1f758714af4ab8db78e0f5cb362b1d74fd3920ef15d7bab6f1b83458fc10323a3d2bb4154d0730d3617af4468de51236b8647d5801f74c856ddeb162811b79a3faef2f576de8fe3f9189aeeae75d2f8b2d158324b7e431b3c7ad29c5d92073afb710e5f8e6dd1b5c295efcff0b450244c455176c6b7fad55b345a6ec1a7784579a02a3b9df015ee35ca99ab58e5edcce420f9028147463446abb2400bb7a77d80216b4c73187d5e2f4d755e9cdc50810e51c938c8d60a474378802981bad8cdd501dddd61eb4c25091e82c66eb0b9f1dc5d6549ac22c8c959cdb59a980d32b5b9ec0f8cd4021d497c633e7a4edb60015cfcdb4edffdb90f34374c8854d8aa53da8f82908db7feaff47dee2613ea3b7c1061a576d3bff1046040c97e213c1eec42a7a1c992b16cb27e11804606bed2ab132d0a50d60c12ae816b7e97087cd683ac0da1f6c975cf1c08411cfeadf39349517c95d686255e305d2d8be7f1ca4f4af0b1d5177f75106d7cd3af66f180bd072fa220a079e2fcce6e18c2eb447b876a75ba1429a93fdad5dbb7f21dd707cc11d9b8f7b1923fb0ef6f10a8ceaedd55f3289a180aff05b5b4bd6094ebd2a77ca9a0e47939b4032e9d84f9891c95ccb997cab8f18b820d1b7352eb25f0fb45ef53bd08c9d8a54f8ffc0bf32463c61772ea3bffcfb5a89664a371b8e81fac651a18538e4d93709f824338c21ff9e16f10d4e3d227f2986dfeea8c73fa3a43c10a7353eb9d345ed90cd0c5a9c39b429751bacf7e33ca6fb211507efdc004a2af1b1a2b913ec0fa4112976f7e6716f4e303e8a4c25146b29fb40dc5e6ff68f3c2aa82982301f9614c246c5dd1501c9dc03b1d6cfdf37b9a7e54e18f7548bdfea2a13facf2de58d9304b252adb8ccace156648d698400ae8b4f0c17c0e5ef9275fac1e524359599bfec3b735b96b3ae9c4a2ba01cd884a35fb4d209e9aeb2d83a49f837deeb66fa3ac942894fa8fea2b590dfd16f38167dc2bd4ad2a3268b711960cb2a8821a8a98f838572d0dacdf03373570b1a34b1908efc11aec5d7ef9ec69c637c7b6b8599c2ace98da9420ff3f05300fd9d79b63ac57b4465683773aebd9509c3affbd23ba4631e1d7736591e8615b76becff74d8edca9c75f963246a751c0850a563c17bfd47960562e1d03d2a2bd1538ea14595087a7db5d9a3e3a4fcb2496cc18a1648dc6211ac379e39003a68ef73d41fdf9e188b4ad9f9570a9ee100e85a0eba17d153ff6d456809b6f7ab3067ec3c1f3c5f4045bc4fcc8a2071d27dbad843c41c16fae8e441ff9ab8ff6f238a400531e8ac18a8619cb84c8dd5125c5d74e878436433a6d5b83e5eddefc45ac52be90e2dafe277a766cdeda600293756d3d0b234bec9a4048eb9dde2e3f9da3be07bf940961757ec2be2bd2f3babe1395cf17b641619d0464498d5814b338dd51ef4d7a3793995ef92292d70d404173bcc36a0dc617bbd79d387a9cc73e818614eb1d3422ff0fef106992c5fec53748bf59281bc81b468fcec685466ec26703a99600323c493b24cd7f9bbfe2441d9a39a4426bcb428fecdc69b919b639bd56fe49be1c31c098d45d29891596146e6b35e448c5bc3adc02f1ce38d3a338b8d7fb72f8b3a103551aade34b63dce842c5b325466b9e30d337fb29a93df63ca57324f534bb3b8f74806f5016d3878b632f56fdac33d69dd3293ee2ba3d089ddb87316140679b98e3f105e514971cfc68f671646a2864ea200d7754feac12c3da50c1d5f0e4f11d71e1f9a59f12fe9a414a33b722931448bf5a5ce326f227b03d0694157d2a04210a0d1328ab6cc6253cd322566d03f85e5d5a965e48f55fc66649bfa159a3535888bf7e283e1ef98f4721b412ce791f0858d4c0f6aa9719e6f1b779fa4c12ecc71c684f25ba2ec0e7d5d3b478256228f339ac0ac3c5b1aedec40da6c8f4c396108feb38d6d87f1b50ddb6cb2e7aa5fa82cdb6371dd09108411675d9b614a9644fc970fc529c0a48664058b275882518df29197761a129bbba1bb035a31e8f2ded6509f28ff689831af929107de51068f13888b127672202752707d9012ea18ba700c7d126f8bb5ec1f80cb9d83e1938c0d264234e1353578a3dd968e7705b94cbe85dad256ddef106512846c35b59da48127b751775ec5f1d1479cc4d50a063b8bde730be630075451c7245accea5777a50794cadc0d5eb01e949bae0934e2e03a3013ebd23916c8786352fda5b2b8bc97a6377d52fcf21142265d52da6e5fa0c8a7439b066ecd2317463a2e4e234bc2315f548758c2bda1e181172b1a56377f3ddf7a259727380b130d7ea73deff847283262525cbf86d28740d32d1208d97bd0bef10cecdc41ccdbebb809a63c0bfdc2e8f1e64c7830065ca652fa53e5b7c8822c657d92353c243443ded8ca1a667c0e6b5a0265620ee999fb7de3937c8683e9eb793f595afa4bef8573c8efd67e3e393e3e8e217c34dfe97ee727f1edb6384ded7bc233c7cff9de91ce86abf661a851c84e949d61e906ccc58a89eaf0f9ea1d690ccdb7f22f419d7d34839538acd27b8b15cdc9cc9952a02f55c1f86eab6fcd77d32b803df3d80dac186cdcbce30bb295640965d06dce47a3a95104005b97b24ce91fd63a1fa0e29b4ccdfbda7ac73dd248308fdcbc65e720af6120cef465599cf556252eecc70b9aa0c49583952ed9bf59af9831b9c651ba0ddb1324e438365a141fefae9e8a4f44e79ffd699d113faba02d3e7a11a00c50e01dd6dc0482c8cc830b3b13ca3a6f5f7effdd6b7d10b72d63b7161a006f772dd0f630d7655b502b5b1db2e8e516cbbbbf9ea6154aa4f74601a1a10dd11acd23a8afe8edefbfbb032428e14ca16e1a1ccd862731068e436fd64cc56933da9354818a67202893c044525e292166c8a8106fc37dd2dd7afae747079f61b7f84b40fac84a7afd05fe91f7db1c47ebd9769e98e9d2375494218b1dbba83933038dd92297c25f8039b3b0b92c0493ed2d36d4be26ed536ad5c15b7ffd8d57dfc2e49213b41f57cc28362feaa83e81a68a59d5224182333794feecc7185e28e8a73698019e343cd9486ae791fe5fc289269ca00851907822ab9d01294dab3fb5ac80ed9efe95f3ffd81a16bde9a52048f1a933723a13afe14f04b7169a17af150a1f95ea640d94c806afe03af83841450275ff61bec946828d3d234b5cebe067ceed360280d52d6aa16c06c3fd864b36673502a1a5d038d617761e265c83e5381c4ae96d8e71c6f02832eb665d4861c04dd5bd871b72faacacb58897ecd81358b93cbd5dd302275ed41122d7b9f4eb8cd9fe93a2fe97117b8021b78f243a6b59a78135f119e6f5f108cf0e9950adc836c99e6dcee13edcc4c3b9bcfc17f8c2481a80f549199ae8fe517748e41b71e67aba1b51c95fa78d585c4bd8cd47caa8691ba24cd3efa6989c02351568ff227188b566b0f7abe26e18b4ed57b19cd770c915ff86d3ecb995f3f6dbaf1c90fdb292bdaae949966eccf8674e436cefc99c44cbe4635a89bc98ac2739a7016d03fb8496a264a46045757881d4302e9fcb389e1122e7aa361958acdcdef32e738fc3a559ddbe4507a038518c6b1c939f4e17d9a952d17db2260aed46d50f695ac7f6ba59ca0e8c9404069ed3247720324213e5b0a77ba1a5fc8fad72d593b6915755f415d71db347b601f3da72f54b118bdbe46c028ceefc3c7cf860b781eb2197deab47f6d8e4ac947bf70f7943cbbb5247272f01d326a5a505cebbe80b2b140d307bb7c7b05d1856b0ccb06fa7dba43c5ecb011731b94118155ca929f6f3e182ab9a7001b1d3194122cd7f56d6e2b49ffe70909c160d77ebfd4fe613a73b52fd9a7e37b722ba90befa8b566c1e1ad8f69923fa1f34cbb212e93d0a93597475d80b643b9ea3a5aa6cafa6552ddef5f38e63dbf14c7a443426317808e8854da0e2906bea50e14dd091ef0cd3c8d8f8620a6d6ea86752093847944833be0863fe028a83d089383aecd74cc225ebc57dddeaa1a978d8fcad723189eef7ff5708806bf3bcfe6d99b78d2c281bb208c1884bb2a0803668f089fd89eea1cb42ea4b15363fd3d72af1c2c24ca82e5a5bfdd111d00999d53b6dba72ba02524a15babe52791b65acaa093a703226fdf63d028e7a9d169290cf24d6060aed594c28fb7e1b866e1bfc1fc4da45b2158072829c4206829f1fa264208c243bbe73dc2e4789d704554fb5da0c27caf06c4083719051290cf65880f7469f56c3a20c4cc51bdc50ad4a8f14ee77281cd04bfb2f04b63f76c1e27611f01052604f7deec6952c0a70b2ba14a4a3bb9c1278e9c255c6fc1b1c18fbc24df51b7681c3ddc22a809dd59364b4773c35a2ab9f50c6906619d152a7fba502454453f27a9ddf582aad290cef124154887cdc397affa1c6a5e55440ade5e66199230752ac60a6bb7df290ef0229931ed519b9931e78728666efa6a840bab5dcf26ace645a7b36a9c2ef254be9a5d678a49be65d56c703aad92f61edab452656dbdc1b208e208721d2a4268eb41bc80c41d891aadefa987e0ac50f4c8cb257e3a1f1e9ebc60e11078be551b58e970548b2bd8581b50508693071c4627ca62300f718e918ca79b16e1c0367f37bd75e4497c2b79755b0ac2459755ee76b375d01dc50950345cca78157282fa195248642517ab5907f0b6fc6cb2a4cca28cb0d2f39ab93f0d7c83d6a764a4be598744422ccd2562f845695390b433737803f3395f9c0b5b8090ae2f88ccf2e5f86aab4b5653483a585b8841d259843b665c3ffcc6f49bba6d8baf8ece5d3e8ce0a79d0cd26f51a35d29e83500f8e66ecde8b31745d76f9cbd658c78d5792c562fa46bc19dcb59821f4a5294a899b391343246a40c34fdf28cf072853e5049ba2b1b901195ca7b7c3caaa417448a4c8c3dbc03471cca98f6e8b433cc3cecaac956e6fa8c04b8899dac57baf4116a4f23d2221b6551461123baf936f56cfddbb36c187c5f41b74040aef396d92893dc055e6131df692c9621883bf0866612ffb7a80173965cf5358fb0f858a49d9b6824d3ac646a832ed07d3f41e4a6565cbc934990ac719d97973e079a2e4bce294e97fe68b9b8398bf2907f54a79e2f97b6e735b8356417abf3d1c53032802f37e3fd0f39f2cd664d44c35f87c49f714821d3c7a9cdf1b8149de1a63782017a6e3e321902f06e079ac638d89feae7a58aa1186ce7fc1df4e56325db41cb27849e22fab2be77072f5b683662f8193d185bcf305d40c9aede5e5eae408a09898fd1087a8160c30fe65bd99815a51713280fcf4199e850ea1028126404406937e20d1f3bc17cad6c1c40754f932ff0326acf91f0056c64050bda15920a8fae3e474dccf6f46696e72b273f8b09dc87e33832d8af152ff21021c7de3ba7bb1a205017a36f42a829c106c7b3eec4ace74026f4daaf33a481c5fccf61d44ec23f0a285fdb1d49dfb74a94a9e5c2033b935cd6661925a7667b8e73bd2c0944fc3a161a6cce51ccd68af9a2bc22fc6246d9ff159172c928420433f297d6b9f8fee4f95b03d9931a2160cdb32e0111ee00e6b02c711af225ff3b7ca907527563a1efcd98129a4a91b63582aa0774ba7cc10e3bd58b052988b2be6c8f52f3252463e197fa39e05161861bba18c86a3236028daa402f36da0195559738ee7151c6dab8f437af390efb519ee24b7713ebcbade6d6c840f4e480c016b98ca6c3d8a3d0fb47ee23611398dc4ad0a9ad9ec2e758e74b1aba6aeeba76adfc04d4bdbd873a98ca1c8dd764d6ef267b488fa3476c01ebaf6d86b32346e254ab234a81c81f2b277d39488a5eaf34c7303e810bb12d102f441c3a34ddc1e19490cb7c96114c5980266a6c38a2efa3e1db40669143f121091d0e9651efb7da09eb08965c9da4a97f63a539a96bec3fb1b656eb4ed265f197c34f9a0bb745147f813a4919afc595847df905543a4377c9de266703053040fa20b755818e5111080956c4b0c683b9001c78842cc4326324ed28231790923591c90cacdbeeda8cb09912d7146b40ec54b4034610cef0124d0d7484e1cdc7bd5297c5f69ac6b0315b01b8a5ab10a6e69c9086a90e8df493747a00e430d5d0fdd6d5bc488571cdf0fba086596812c6fbf6115fb335b63540c8c2df636b35d3b0114cf6f2e6f8350e027aca2566170cf9cb56b51ea4256dacf0ffab5924eabb86e4fd3be8fee0e83a17af4ea1064874a156536fd4196bf2f839d9a65b5a7e7ba0b0eadccd91dd4e9c319c34b90da50c5959e99bbc5619c7d9b80ffa361e3c1181280acc4ffb0e59259cff53cef4340388caf1a2b998da22c9d213be974b8d4ebf0889f97fc681d2a2da1ea0cd6f7217b5ec3809a0765e855b685890082dfcf38ed74486ee80e2a0f7a2edd385b86a37d836469eee70ca2614660d4178c997b1c36f6faf6b9af9c8e4f09dc4e78b2dc074461688e76fb0f0b8a2ed6b0bdbb1b2c435cdd204827d63eaf8aa6e00b4f7bb82e0359d33c2f74f5b780b9d73b5b75e78dd45571948c23482d0f366120cfb4563105df5704a353af36b65b7be0f283ee44a532fc8970b3deaf816f2e125041f943b1e3334580ba94ca041c24301d6cf8e9be4a20bcba364bb59a6c990a9d9279ad9e688805a8ecb7568d72a1bf951e31977dc01c6f2de43fcf035ddfee96a76c39de292afa4cc194ddebead7e40c13d1cc198d18ec0813cbcdc769ae2ce00155211826ae4d2538a3916d1562a7ca8df1e3469d2c9f4ba1bdae3490e7c8066fec953290d402cb8754b8d937899a8cb6556e830cc81b11a36d79d309e4bd60e0bece92cd5e3bf51a45f23208207bd6261d8a6c75a3519e706aa6cf76e6cb95dd76c95720c6942061bb2b48bf338828bd26299990de22dd6c29a046cc29e65a9be06a3c75e67327c1c34aceff4d5b37d1a2602a8f9ab6dccc6c7beac0d8638211736b533742a8b7fa760282d3a6ec4705961348cbb84b6cf9de6630e1431d3694fb11a4df1d9940250b2d8a2403133032fbc220720f76b3d17217cf8874e7e38c248e9794e15a054090b9396e3a3b34b2a37471c180f5e3a2bceaf25e3aeeb1461000e344236357ef890432d8cd70b8de15c68ca4b842900af816727e1b7c14d461ec712ffab8032b065728c3e882e57ffa6d0fb253bb2fd394b957df6f81b48ee5f579a9e6fdc56df34630dabd72b4fee5e81757b3d910620e1330d0e3ff3c0fdbe48df5cc14b572fbe7ad98176728049fa198a9b78bc77a39cdf9eef435e54869dc4cdc6411c5af79c037ab1c7905f6d23c030b364c40117abbf08fe5d3dd437f0c195584e682a31e6dad4a62bfd5293c06ec9737236d0806e6a5267d55fd3556c6d7bdb78760c444067edb1180bd824fdaae7200ab13d67540a3a32f0c1e0355f3173d2d18ea568a2fbb5c3526e55f707c3b8cebd61c5cac203dfa7227c47faa0cbad6f8323890aa7ad662ffbca52341dd87ffa64a3fc7ab022ece5b63ce8539efa0cf914ca44579c7f9befb7c39a168ec08def38041fe19888673d9590ebc55afe35d3a9c5086c68da5dcbeb2304b6f6e0ac17bc233de6310346efcf9fd495fb348a967daa5ebf1f9dde174c3e40fad86e73024ffb395489500b6f9536d9cf573f7c70e3b8f931310a157eb04249e3256556bc3d7ee8c4b208e273f7ec14f5999503924e73500df19a542278f253db9e9a7079f93d07e0e928cac226dcb21cd819b3149f0d5ac7a2d50419b72bc52636c0430f56c21b38b8dee1dff88cd6053b51bc1e985f5a6da552a5bed7e2ec3db94d3452bfb1a4e68e8cfbeda9af45adc95cc2417f168bd34e74337116ae25480b09ce42ca86ee9cc0ed3ea5858e7fab08f66e01156f127bb615a76505f3212472f6ecf341a7ed6d2838bc4f94ffa3b6638882114444a4010a02c0e4ccae579757c614f138deebfb733ab1875403ee01cd36ca9472b10cc4a62956b5d152108b5e1d6b66d0d681a8790be861099c2d20e058fcd2d2db767fd9be8fd687ea22b4f67fd5d614ed95c3d2c5d572857da5ff4c6b0de6388d736ce4190c2d9aaa6510a05c808d784bf25a6b0ff3f011afaa156240aa5206a0c258685f606948c4c3d0d737a750c2be3fd78aa6164ae9985e94cf52cbf341f974da536659f662c02200b5f0d2079b19f514d7c16c24fe52093b2df359e57be51a0b4026dcc5397af0a59cee7446a97e5ae4902595dacd0556ee9c456ecdc09f91a96091889d0cc8207678825a8c6f3073ca3565b62cfe20afa7e853209af89d43d9234839bb229326c102e193d60ddd3e78ec7f9ec8d51a98d26fe8eaf4d0044622880bf5aadefc41eaf65ee60bb20a7f989eeb0f1c82b10bc62e52f84fd4a453294d5c53b023f249439f52245658cd6aa627482f7bdb4c4bfbe82f86fff0858e7706e630a2ef5b8e21fb22103b75d762c9f33bc74f3100f9c5c9d8b7a19fc7d4d67591b25b92cb19ff5f51f982e787900692c180cf7ea6d87459df64790388b8a199b487ad27a2c93ee4a8df599c37b36414c2e800eeecfc6d8cb05ef519bad0ce9defcb20b645f7a6dd15e075939ed64750008e2b371935c3aa967be24978e711e7a473730778bc54a74a0a4b54a9a9bb5ea038c374b115a65479ee95a5541b26b8146791e6bcfce6922e24ac314301878dde92dbc7b1bde07e06a00252db3735c4d59eb040051a83227924f7827ba50d06dadfb72013699d2f2497eb78f0ac9f17eedbf0aaaaeeaea3c10682bc27f2e610c5a9684d4de842569ed8a6e4c2e1c472dd0f4c5fb4f3f84b8069c0e336fa980762f77c04a97e263ad008247789de2b12293461bfa64026a7a4f2631c99ac792d7aadea190cc172a19457cc3c1359359623e23e7bb4ba088270e4d28972842384609b82daf5147e9e4dfc2a2fa09d119a039e15ccdf35381f7fe5af2f5239b557c387adaa94ae3c7a25c824446f9d0dd17cd12fe9de2854a881d66e8cea0b3629ff86a72ac317869a93142dcb3d69997e085832a3f7a4d53daf1d08ba7bbdd43789e755085cf508b7530d399cd71b87065a0c01c383e2840fdf520703c315f88a0ce89e981acc559152d1e504982ce3baba178c5ff67406f1bcdbcbab153d151cbc73684b553655a46e76fc780c78b64b987357f45d52e3f0f5142b573edb5f21590eaaa5583ad0ca29e9349d629ca96138673d1a4b2d4da7fd99de8f82501ce398b04dadd62cc973a945cd42c5bfe471081171eb10eeb279e81e8333910b32b2592303af8cff44d90013bc0fc1dbc890276e6bcdf27edaf20dc47007841299c5e4f0826901ad3a9fb615d1b4aae7c45e637cbd98ad8908714079254e659c03e73dcded776fed0816aa655bfae2cfdb94313c08b7cff8618f7f82e7e6655c57f291f2b8ebd33078e19bf56fae34f30070763d85f171c0b986d85ef4cb02d94604ceb94516966d49d154b48c924dd7a1ef928111e155c1ca02f9700ccb20073f55bc3a6467c1f34a9dab72cea64a8d9d0d09ee0357f41a3d235316329477632b65a7ef334052769273a53c74f8cdc63f6ba5196e16a0a8a16bfb840479628a2456d4eaea1dcf94808c944f844b152e6df2fe9dee01db1023432aae89a8e827b7f94e7106864b4986ba351fa62ae4571e9f0c8446a366e60fa531013ed93285c33d2700ad18a5e42aefa7fa5cb455a1d10c957859aed8eafffdd81709c47ca868551d9dbb3542c197665591a0e0dd7384415e9627db0434484a6b883eefa0f6e5927f18596df3eb305f629b5d9aca7c6e5be1eed726b45a47531d4a2bc3d289f1460096f1966e9d92ac5b478babf0434c9090486b2a6f469b57a6603eb6f10cf4e21e78e847078765a8e95ff8a841e6334155546069492dff8b6582055fa3650cc79f5b361db1bd8daa1c3e00bb3fdde9fe3a56bfa04d5cd1bf4e81ba9292a1a51b98bd3ff268f7e65cd2db0527990d51bdbe57d305ccf3f28d427ce994ea7042457fafa49378fca4f80c1661f66bfa94960a4aaacd874eb02e903d155eca843a72844f130ab9d8eb5e8c1ff35d0577e7021872afeec75fbb4402a516f970be8a39a5128b0bd6a77822e8353f509d1c10903ef88900c2c5914f964ba4b63c2947aa3986866ac4a1e94c8c3f7fce0a33a9dc8a05a6495f18f6afc87ad49198d1b845b432d9b941c8d9aaef3bfe3425b30fbdea0317c40c2e785583ffa3d74d00177fbef08bcb00c158c12accbfc91ae2a1538de6ce95ab715c9ada1cb050824663cd06f60acc12bf43c120f0e9c9a4d61e9073b7e7fb60ecb45c8d045f5f60bc548a5f22dfd851b10142d7ea6b0a2fff2aa0ee3d45aab47f9b3b286a7c4d625eb39e2ee5f76c70d1af2bbdaf9a2a1541d249342b2211891694bd9fb24457645fe0d9d216bed6ffdf6683a37ddd016f5faff8f948f68d8c6a53b67d3b7e9b931cce40934faab8fcaa92ddf2729f273c44426b2ba6e12cd4dc5d69594d75dbe2ff70a84769521070e1122c8c0f1e310d7b9edb19cb58fa272f89cb96b820c4ff2ec33bcc94c65a0bf745be3f59e41fe40a7b2996a2a3a7210eade888fcbd3ab77b92efce18e009e31cfd4731427f6d41974d10654d3fa81973bb400ad2aa64c2dbbb87fa1614d2f898ee875081f23f601887d263e9d13fe46a40511c2ebd5cbbfe00777e167a6cdc38a29861162e95eb88248dbc90adb6154a69bf20698c431cccddebc091fb8453fd029e28eab37276e4c8417be0b6ba8c7e64abae75d0cd82f955d481e49f92647215b126885a037e39f98469e05670637d34296b4ba48bdb2c83c1933905880ff0f73d2aa846001cac11ead3fdbbe377da8c28590980b8f7f8b748ee20d96349fea947ef267285dd4c0cd0fa8ef951fff3a4ccbba615bb05845c8fef0ddfd66e27dc84f2396dd15eccda46fd422f634a5bae71dfe5a6841e60c26169a9e1edf9afa9d4b2c5ced21e3533f4317fc0545fcad376c9bf5206e432b344ea5ad0fc7da1e13e2bd26ad945d0acfac32d73dc9b673a530fbf89d2611ee48044b82f08619705b484d83963e08aebeb90e594a29cba2ad9644845c06058d6df4e8fdb1491d8e1e861c1f719ffa4413165a4d5a8987d1f32daa521cd41a4f20403dcc2ce877adc792174e67062a6ce4ce9869828393209a8d609dfc020b6f1bbbda63782502272733a09146511cbefaab6072262b65d66e0996cfe828f997269826ec40a091c5fd67bd14fe5be208b5383d5f2f22fa9484c6fa35687f05921755fdf5b073727b1a0a8831b8953fe4e52dd0516c9507ac4f9642d6540c48ee7377f37087d3610c8ba77190d02a4de9adad77c7490e657bdab60600f99df661ae2a03efa51127f52f4141fad30e0d5647003516a180f9cc0020a34bd3acba147c99a515b23eeb93e4b74969d0ee3a6850d879c918934c46fb54c34c19bba2c6c4f7789fe0ed97440b45a1a5ff4ef0d4575ce29786442046e3cc5883a65b459b7bd617967a5b3db9a0a6bd1c5c4b887692b9bdb82bd91bff7fe3d7227e3024619a963fbf3685dd45ab1df0419a5061d593184650bc3b14c9c87d3dbd123477ac992a55899c1059f908460b889b57ebcbd4b25dff66b0e50e4c3086c1ddf1e877914654eb311983732376f1a3bbd75a845c5ca9ad480cfd5dcc5881d6f2dedd642bb751491385de350cbc3715f97afe2385a838b2f67c91abb432b642c29b91770c6dc75ae4668da719b63deaf10414ffaeeed1195494ecc4efa22df84719b4619fbc8eaf4d4b4ec249e4de3a293976828b9e5a587f5c52789d0662c6bf27c825781d398d129376f69e92ada68bf109eb8d6bed9d804f80e370ef73626140db56ae46d727a3f0fd52535fc5ddc1e41443366f10ac05b3d01e2154b3b55bf8a62d8fe92290bc6d3f4fbb0abec1b3ca266204f9d403fa644d854b3c72d8a05bde36986ec5d9b5ec9400916bcc8125de5ef69ec98e6072eabc4a01f44161281620ff632dbb74c852174ecf13f92e7f14e6e209d112acc38ec6af4487d4d6fac928721f9b6aeef82dddaddd10bf165d0ed41631e01351f401a60e3bd7aa32b28685d68dc939bceec3ece3ce26f4db456b9c60862ea6ad4e6d965f2ba6efefcf195d3cf94a2d8be556706fd3b8326b963cbdc35fbaf1b4a9761d975955f81ca46afb6a48e0813ac261d91cf85b4a198e08bc83d20bbb14db02ada8aa723b319daaa985371105ffc04cb1f56c2f47f7ecadaa2d485d9e7e8a48cac778b91e72d84f0d949b165870a85229c4f2b61288eca7c80817b1b1ac7551d2fa239cd3fb26e6e1a73c61d7821d54974aee773d059b6c0e0476b31871a8ee8df4dc674ed71fd56524b812c4a0282f849f1a6ab887c6780ff738d4cb2090662cd320edc0c2e6187186aa7fbc9ee808016ca19861142308de4440df1ed4a53c03180f167e1fddefbe53c20c45fb52efbc638bdafc985a9a4eaf8d8f8c65234c2c1ed8399ef3bd78e439b62d5997c5965d348528f0dc5207671570f867f21eba8d1578f041d85618e342ee4330572f723793ef6f0798d6043bd1101ca3cb7cee95d023bc7de9ed58d92755e4cc5996939b180f5d69ccc72bd0e84c62e057f2c4e1abdfb1c94b93a2f638dde3ca640448159d4b4a093eed70423cf8e3b50ee2815775ebd265c6b2f95720067671574d4d5f395fd710038443b601f7d987167993b55b1ad86a72bfbb98442b2999740915a5dd309f68858764945a073bc9f13b8ddc90e76107dc2992f1d40b3b0d5879efa44309ac760cfccd436c4684f49168d007968544f2899b0e3418a29c9747191ccefd1a3dcf8e1e5eb6dea7c72158b8f6155005507ad8830057dfa657957cd6cb45a39b2c34935d70e04cee4c1b0ead9899cf18eb86b02df178904e42c797b74595dd761490685867ab83ad08da26a125f675d8192e83fac02d55175755de711b4b4f1858b5ca019ff0f4a00f33ae9d1893438fda81f0b2faf40ecaaec29ac246464d1ec8c3489deedfc13193b8eb9fd4f44253ab7d465c6ceb34ad0e8ef8e9915b80e2089f5c6dc49b417ab42c6d80a8e6b74ab76e14c577f2f1afa74cd4a928f40b27b803b854088c4c06355b43c1e737b5cffcdc8368f6ad9bf913aab7884f43202298a410ebcfc2ad1e2b777ca01384af506fe672767a8b8c3499f48587adf37af651f2e9e334252d985d23f8c2bc08015536fa0000646a71bb4c6fe8fe5d58de377041839efd441692c87508a45d33f0fb44c4d56a5f2c1c9906a0f94c0444938ccd009899446123f72d93abdd9f121405eae1cd1225ea444ea87cbebe1dbc74502b5fd82701a8ecc6b6d9119510be51a6ee938c8a2c53b042bf1033544f1797be0e3235f7562fc7f98a5f5beef9ad0ab36675edeff5eb51e8f27661e7b44456af4329cbad04a88a7c817dd7f57ff9ecf9b171ba786bfbe10325e833307d2bbf9f4a581c6bc216f0078226203f02b82124fc1e0611488b98827ad281421b26224db0b3046267e160ea9df24a6532a810e8671789dc250b6078837ee47844e011e3e804e8328edf1ea48506e9cd8479136efde8e4fe4e640f1141e27998aea0fc977c8246949a47e49f35f6afc41d2fad74129d7456c58184cf31e63f244f238cc82ea9bf89c7f7df6ae17072f43228319014417775c80608189b48c64d2cf7ab734279793e53e972a04a260e839126f5a5f0a383fd1b002668289ae09edd0d4b3546f5263a4ce6c2bf27b26f7d085a2bf724c010424033ade749d6b8783fb66b29e117c1207f693a1cebcd379129224bfacaf6a25969350d13584d2e24101b84cda33c177f4b90e12d281f29f1cad9a7afd4ee78db467fa6668d2432109b19e809eb200aca129c252ca28395f6786b617561764423be68c74d2242082b5e0579adcf5518e9e8bb3511214eaae0cd2b7865f669b87721268e41fc32ad2958a54c3e6f9e72dbb5d5e241ec0ca1983fad97d6a78091669bc8520fee7b285cd7b73aea4788c029e06a480c71f0c87c3ca12ea0d59211a389573fcb244ce29e81cb4f7bfe0d60cf44b5f5bc7b3263eb3f3f42cefff92e80e30426dd2b16e4f723ba401686b112564c84c7cb1eff370db468b81de723960baeb98d65afea7fc63b49ad56cbff4e815beb85eb053386af10d19ac3462154d7d7b76ceb262f2a67944e0993816d3d1fbb69089b99116c31baafaa2ebc3310460406b8c49aaeae2be7657b7bcfca33a019272dc9617f271c52db44d8c6a266ac5d2e518d39276d5912281eb20da7b6a231aae477008ed466a901496ae97548cb37024712e3caae51679e83bda714e2b2b0916b11fa45b49092c67a1dba7e9223f957630666d958ed85a56fc6da2c2c0e9872affe89810869ec9be3db1a9d5951318298ad15dcd5d04e5783d56db66710334ce993237dadbaa31ce14882bb3104d09a2f51cd12f730b26e6ff5145abc192aae3d54d4705921653a4282d057ed07842361e63adec4e0aafee8e8826e9f9fad7add9870262e7d31d399880859413ef538311a0cb788a4e78d4d0d62692c03486b553f58707ee04300ea1138eb06b4961bd7bddced8f5990dfd2d2016a94fb060b8032bb6e768c3b97aa57d1930fbf8e20eac151684355adeef0a6312aa8476ad7d03a631e991b2305b9e66565544ef6ef702d7b861a3e86b751003a5398d06c95ed49f4495d21ca6d2e907827e4a81d94abc75ac218933db8558cdf09d25b9799d8ddf684d44dc473740afc44762c86bbcc87a60ec78694a0fe8816768dab2371698ccac18e654e9cdb8b820b64b669ce2e68eee84dbda904d843d53940462c5b85cfaf515ef5716a0c2b6b1e438d152d9780f27a5c3887a3e2eb6b065035122324ef02f0fc4f82e540d8f8dd823ae4094912a41312775016435a93a93614d50c7769cfc9f3374f288cac0cfa4a0fe478852c3555e46060fb195925e3a57f999da3c8a1987f31158b4ac1d0ca91c7ec7f5c78fc5f413899e162171545a7d2fb152ba30d82a791b3a253787ee70dac90d78339bb05b443ba9ed1d852d97912002accdaef2ea85715dd339a8135bdfba097f08d3eeaf410fc35beeab7516bd5297c5a0167e9b57087de7502cb8475ccbe1629efee5ae4f49c561996aa0ad62e1a936ff345c4455140c5f9fb172926393761635f2592b1b13cfe86f930183f499fb2d166fb52eb1cb17587250be161b31ec0d67d16bfb4795b210b62fc372636b05ede9d9608a0c1bf8c25f11572985d26a8e8bb2e61873f660e8683bf18386f73a1bb7683441205a3859a2654c8ab394ad389324e9694a1d23bbe21ea9a934db55dd851f510b59b282b8259dd4f7f6723d1fc8cf16a1195a2f4935264432915c51fc2b68e913bae82ae71155cde100efa4fd813abb1c262c42a8542a97c39a6c4170789d39922b8e423e13575d712e0db90bffdd98ec30b7b7a45d64375ad0de019274013418fd898d79bda77d198785516e98e08767c68adc5799cd63f442e6be9efee34f860dd11bc5e9d1f07c56553285043bd089c03219961b267acdf9a069d8c07e8a68da3b70c85fee4b7f26b9db3ef4c814a77c10d92e9e686c5fb101097f3b651e2468bf901982b9a8e9c456fc7a360b1133509e471923b862eeec4343c0e94692b7e260087091b0717eb4ca2f8954c82ce9bb16f9d54cb728d3e8b8b11f8a33fc0337c69ae0e7e191a05ff5ae74278818626040650b1c4f9ebbd7f320006a454416ec3bd150f0c892a015d007f100a2c9401b0a76dfdd72ff346469114b4a201b8b3eef6c055122e7f4ed44c4ad237f3aa5f3c1d28b2dec7b6d98a17d0ea386ad36582b4069d84b04ae3472603c2616d36579f7f4baef796f1973ae40bffc98eca8f8448b7b1ad4b6031c834afc9fb39cb556a6ffd015027085a7de874d69a9162bcff0e22294242bba9550850629e9e9a294c0a51ec2c4b9e62af9ce7d550d3af8bda4bcb94dd2b14fe1d7981d89dbb8fb2acb95bbf99e3836ea7569f0c0f6fb557517ef7113e31f19b846ee9224c6a1f59ca1ce7c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
