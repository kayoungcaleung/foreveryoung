<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"516bce21bcd12d24ddac361ac0ef8ea18be8c10766118a5b25b89df5fe7f6af9520412fefc7ae77bb1c51b2ef1e4c147315d86956518edf249041ab60f9d7a8a211b6e8bb9c356832496621f5e35e29c3515cef0678d2a6998ad7ecb6d2b696c61120f905f9eee20997d91e595515c35db1984f438148ab247aa636cd020e93a14dcf05b38d095c030c074e0622370a5612745643b26776de61cb7ff3b0df1a34aef02c863f2f485f0798cb58c5e9014cbd1507e8543f4529fef159167b359ba4cc65a6244b1fc150a35336a0badf98a9c79e9da14aaa9f5705d243a21b2b230d768de2fec38a8c9bce15e82a707b449b46510904152574d3761dd5fa807fa142889444f7b8f05b479fe3d123b47e927b78f0044d6b7ba56f7cedcd53e542dc32ffdbc3809c36af132df514750b1019efe6e42864dc42a75421fc8fd5091e515d9079914dd4fc3ff6a9345f519c04cc1c19fbbc7516ecfbcac4cb451fb6e104be773faf7d0afeb9a41b9ea6aec120a78059370253fbc06a8014a704a863bc1c6d1649c0490bcfa55c611c2b041c2db19f7bcfae797cc1247f724285b86e3398d640039e31319af77b1c5e6dd062a3b57694d181d5cc40ae796ab40cbebcf3e324780783d9717aebbe1800d3a184efdfe8c6a63382d4297c944d2e13e4ffaf4d568c0b25ca7e79038bdf5faa8e66e2a25fdd22625cb305bcc6e6b3e1315e58f529f533b8cf7a7541f23ad4da84cf2e3d14752e6d70e3e12eb68227a10992de2752973258fbf554be5aeffaffbb0de7a4a3337f21367266cc8af154b9eeb05eb4dbc72e2af04f54d5eb93d62bb920e5a630660e2309457d67559f7032e60275ac0332ff526f443995b98348d9d914be99dc24c5eb4c67deed7cc4168e06720b784194fe224bd134602c684d73696f9fdf77f04a30d2cd3550eea2683690627239dd5ec37c3006fde58d59f966e1b8e21f6b1f512abe924abdc081aa44089d5c4d79645dc03954afba7ccc50d197e75c2d6cd4e1694e930b40bde0a6dc443263a4292658aa52823c798db5638aba6b1253855f45eba4c95ade13f88b3ff3bf259e840dd1cfd6039ec737dc506c1473315c4e80b6632f3e36d1c5d70008889e6e22645b62594c4f2454bc49e203a920a299b2198a52f74bcb35795c63b02c6ef23131f58c0463165da62db9319a6d672551d111731d470359397713e400047406599a436a0e84e23d46cf1c3810c60ec676562bae7124e004d775a32f9e6ab30f1567dd519b594efc2569edea651f547222f887050ac244a1620a34135c90ab89eff37a9710225350cf2a11c3fb169fb45b4c7c82d32ce5156b2b422a1bf814b8d51c0e92fb83ae123baa4f7dcef3ae2f9666013ae68fa41a84d8b3c22d5f2b1b4ba8d99893d2c164e5ef9020f68ff759911e03a6653d9e29523429c85853d924cdd1292a322bbd9b164d33903672e0596976097ba79424455d54603b0d98ddff37a5c834306755d21059076c5ba861727479bf581d0f0eefe32e96bcfd4240b4b0767672b27c7f8a10ebfcfc1994d275943e11decdfad4bf2b1466eceb11b21707480bd15ab6c417a8910ba80f04d4542c31edf71dfc445bad3142cc80632cb065dae2cc6efb8e4a980832c8b009e56a0208aac6e04b7b1a8e2b65e66946858eed00106ad92a8303c7d2d46a4b88a5a218ee5033024ea17d3d7efdbc4845397149523e23a0046058391ee1c5655ec620222f53e36f15f7bef5ead6fc079a700966b58c917e63b4c3eff76006d9f683f943321929cd6e5c21d0e3705ca9263ee33974d93a7ddbebf8336e4caef18fb62c893e9c79344eb219ade864c8b5dec5fc7f446eab810d24baa74abd68bfe35032ac3d21fad01a1258ac8b64f854f8c9e06ac695fbd0e8a1dc95e19348f1c110b5fcc668d0cafebfc27df1ba7b784932432f589e9b354f498fb93ebff4efbe18e088475c9941000088784f69e5f920f019fef447070d80deaed6866bd87494a2835da88a077aa803e5b4719a46136e76e34797a975ae65cde0476b0dedc18e12c7208c15efcc2f75afee52d17aca41f8d48e996f39541cab47ffc74b7e6338005d1c3bd1dc01147ba3a7464b18bb175349f77ea6016f27dd7f1964057263847fb7f18a299e3650c9941db00a09cbf22a8826ac3093a1cad2e6fd89fbaf479a02865fa9668dd02986016eece6a86fa2d40ab0b63a56ab7fd229817c4a9fc618313ae019f3b0c9cb2615d23e33135ca188395ff73a3173751b36d671e2399dff35923bbbc74d6b8db59c05ed70332d8352008d14a7e26682fa49800a9be4c538c1c39916f6a035939d0fa1e57491d61bd3c4da872b479330a7be4d0b45a5c63ab870d60b27aac17b25b4afb0691b4ea8d3eceb68672d77b18b25d6f4388402aa6369f21f91adddebe9ad27c435b9dcf78598a280f3806382e04c7368dc60a5a1defe70f4e4348445c18b384e9dc40b2f96a101a80ae65f38fff69f77b9b8557a118d62558628d8c3cacdb2a7eda304f2e56efd6e3665e1b1a373bbb0103305581747233ff3e6ec414b1d424c096bb2a9374dff8c04be3ef2d225dc933a2651a5a397134f64612700da7ba36bc2e573d8d257f31efa951116687b7b03bec19b3e67dd3a9ddca5f4fa58ad80a4652802dad848341e76dcf8789789679698a60383939088bed1b75a3a18782b340894fc3f19e6d1ed98a7dad162e76bb9e77aa9fb0e3e6c4ce3c16d90db5ee7f70809cc891de3094d0d773bea2ff2722ccb429c02708dbfeb3c7883b1d15be78d0f7cfac2e4969d45a514654780b341a2e6b40e8d1d6bde4c521ca335b02e4068daa9f31713cda317a6cffc770b1e2128ae525cf7258d9da18af67bf506d86259f9fb95ec68a7fe0e58383e7f47d0028b1132e543a7a8185f2605515a76eaa9c2f2ed33a9a445be47b2c018a8c6b37c935a7b403c1d65668060d6d951dcabe25c2816687403dc366ef32cc6769fc1ac013d28c75cddeccb1b4aa83536ee4bc45e627a34924828d2665bdc9da05d5eccc521a71116e2249a5d8a1df8b3a373d6b3d749c3a9323c08ebc99140370219d55043fb4439d3c65a6437f2c97e51618d8c95be2c93b182445ef2394944ef4e5f2fecf67f15f115b3b3f0e9cece92f7993a4d4b807480a2b275422e10bec6e7d6d98af198dd8f7a5e15525a33e16850dc7e579f5358bb361dd70fbe6272dedae367d608c1cc0352bba0b89c82e3572cbb8e3872cf12bac35af756ddd4b79e96b451f72b1584d65ed543edc4c2f1f0022b117c6bd86e5408af49badab217c7b4fb752b860474d96bc7bc95c9154e9ff601da18406353c6101febfce0bc4831b548970ece18b805d212206162d4678785a14e1639522c2494ec04b741a350ad8fcaf3d57e1f00e2684c51a03e77d7f77c4be0e03328ad0bd051d681a99cb1c55c7b0fc9fcfe44c1f8104885eff1d6db356e6369b1db2f3b17cf3992ea50718c0468f1b7ec2d0057ab5996ab34346ab0f7a91a908532e166816ec04834722f5d1c4824d87c107223433f2751da7996fd6e5e074aec0c6c94b46e50cfbbef15bde31972eececd336f46493bcac8b7201b2144207a49456dfd337476df3179e04cada2769dd94b762974ef35368aa31d053e44be3356be1a66b4f2b318284af3437875c259963956d76d83b8dc49dd2cff4f6c9ecd2c951b77fc8aa122edbae9308358d7402ed13d595cbf4ce18067f77d23d78ada655798d7470267142cba350a6d9d170b05491b9204ff578274f21e462aec18576a4416554275d19214f72f6ebcf4c565c55352067eaa85e66ecffb0da7664d7ac56ee3ae36e622d7736fb1f27bdfe59fe91838711ab5c6ebc335e714e3b7fa2f2e9f63a564491508ccd99cbf7abf6c8f0354fd2cae80dfde8ef0c8251b396c06c2cb54e68e16fa20f2abb6022ba52d69c39644e07f2ebdfe0c859d12c6ccc123d7551f0adabaab20177fcaf24ab4af8285d71371cd3341ac4b1289184a47b3196a8fa994469deac98b7a7dbde38f202a4a358544297e1d9ccc44f50f660a44e1553a33ca7ba859091c993536e6a7d437bfac073a9e17458c0f609f6a9b8d337ab79af61cf4bf603debc9d56d29647a5e86d6e2e257a27891e69c27b16db2d55f17e21b1cb4b27d7f0e5705931443d2caeb770391e2ea110f244eb7d6c1259f989646b904372d24e448e3fa71a576ce19dec1637e07bca552ba6c49aea7cc9e9157d02c8a843770b4156023dcf3603cf0deafa655e6686f48369d9305d162ad91535f9816302f06640e723f4fddf78dfed5b5879e9a9eb828ef4952fb08d5d457d38cbd9e9c87a34718c89b6ec77203b4dd2501c10c450e810b224ea043b06e89f95ade8cb646490ae8e4022b16d4a8017fcec8966a9e0d954f85f1602d0edd4709b7a5ea3556edb23874687d2e557d5ebf1e155959fcbcac8d2e45c01743ce3175735bc4b663edfb65bc7178c6eff170b33cb3aa469dcb4db85fc7ba8263719c9f6fabb202922ab1faa80450ce6e3561db9f2aab62dafeffbbc1f8a52a094ca213b8afdc24bbc89a12269d70aa427a02e752a393bb3220f4a78d8721d053574dcab1008ac16dd2585a5cf4e8b941570ab17524c74d35adee6417b9c8ce1b5a378f04f30648f0db5be32209691901e671825e491eb268b4127a2968ff7bcb2228a192e4c1bbf0058cf53514985421f73b0b694994608a797a24e3bd002cc16139334e78c16e623ab71b7cda339a5a239c651fd55365c2d1f8f79e8e9d1eb4882aab5e576be1861926a86e46e8fbe073d2829372b871df5de8daa7bb3ad230bc92ff9d44f7528187f46ca4293bd0a90bdc3f9c0000ef8822c0ea26a695c74ad5ee7b145ac2be5b68f715c193fa8ee972dfa8444f3c4b930b495c30f9b406fcdf7940bf4a84c21592f9789fdd4bc01e641eb1122fb3994016b5804928416bf8193524f5eb668b15cc57266f7dbd8b3a6d2862cbfbb2c4cde449727fde225610b5089cc45204256da4ff1e61d1800784c10b9ec79547091cab903fc1ab359ea35ef774049d41be93e15c9ff559394b269c13a6270620b9783a0d3981c5c7471c1facb3b132482ec95cfd386b5c2273e034689fba2add65e2f0ce6c75c68750fed836240f6d2406332cabb8ac3fd192f8f5e1d2392d41d6a2b7d4e7e6ca3253b32b327f871a6ee0f5f11cc6724d5c72507daa3967b43be06415b730b60a0cf4d6a37aed4614731dbb3de5191298ff6a11f373d51dded30430c8f3110da8dbf530c191bc7477aa9d04a35bfc4ab8d9f4113669fbc59181ea67032245f8ceb697fa2168f6b9a92b63e3875e566eeec2d9784150b833640c66ba0c0d786930433ae6d517aaa1d9da65ad36508a484a021ddaf23bc4dc3c852c2a5f44e5c013d7b44940031d4a712331142da7f297ead71efa233f0507a82a587b2910e0d37a95695a0ff6fccf4052641e5205ab4bf027e0126606de08ba543831937773781527c8f151b82af7c70467fa8169f3331db3c2c12082ecc86b7417e8a04f909f874c1a3b1a98c11f64cd6e22af0662f452b23d0de7c0f7db14ba6d1fc00d2ad6fc73d8af87f875da2da9150590ea12ba0220793015666ef534076324e90a693bca2b070d3553dda04729029300bfaab9d42f74388705cdcadb4d8363dadebee76ce1981ec939dbed11ec01934e785e6bea7085162bd3558eac21c55763a04ac0ee59d7f873f9ddbe178e169811f4560553ff35ee152ac332aa05d566b2e384ffc3db1a99d1883fe3103050d9a8f1fbc311e0f4901dedd06bad90a5063798d2e0e2854f7e1aaf1945cee2b040da8f5fe46b4702ace9520f2bb8a444e2c42c02f57f017abd0946416be34aacf7357021f590bae2012b1eb63f31b104f05e2e27c2c6960ccc5c61958de21782946f6ae68a356fb1b7bc2156dbf60b3d80340f3b71ab78f5cbb3dddacc17af7eb003fffa5820975955e74bf6fa4df68a444c7f8aabae39e65fc09d7d0f16468bf3e5697ff9198460ea1d6d823da1c3917ca26f6af306362d65669859f43960aa5c596a4a428cbb7ebf0a6d2a87b3c0d02cd9e8f439afddb7fa88fcac8861f30aa5b3e1d7aaaa1e2122fdbf952a90b39b46e8027c00b6ad11a75bde004d7b29667df1bfb82f6c7195f1327df135318803009f1f1252a179d1a6a9535baf41f79b62a280869a8a17bfba06e48c7f996303a5ca30e6e2e33ec94c872f25d400842a28e5dd14fdaaa443ba350d8d147ca5f3b0ffdcb187826908d3fd953a5f47f8780861d7f484141347eefa3cc6aa4801cdc222cf3b0fcc43322ee75c8058eec6cd0ea5c0fc12706be9c42c245fe8cab7f7e8cc8d85b9ac18982724ddb70ca288ddae79cce79b063149ab87b96be5484fe3dec63527c21c89a5bd98e3543dfe93c54678e5b9caf2b7555057b31821550a4339efb39b74ffb2affa9acd3cc2d5f943036574eee7b7d889277dea010ce547075af6b846e5a06c9251e92932390281bced22d928e9841e8496606bcc53d6c6b3dcb8926c92941e25d284a9e672dd145f784d207d6c5f778dcf0d0cc7d10a177a518aad8a8f0383b05857107fb25dcaadc7badbae4246dd5b2cd00dd1fc1f9b0aae7afa18c78c1b2985f506cf8e30f40a398818f343e3132b5de9ea22b95dc26021310256f8ab8204eb0bb4886cf2bed12ce43c8da14ca621d4d48279cae648511597b78f8c5acd3d545bd4413eae0146018563daaab58c5349eb6107a7a34657cea64a96c92b45cd54da1dd95026ff8beff3e66f4bd380f5d3bcb45cbc069d4d633740e24e6297d51f8736c6a8c1c8372e1c00411bb814cb132fa391a628b25f3432ce1301f94bfa8fc7e7a4f3371318c09352d4496e0317cbf9ca4f0f41d21e4c0f64945de6ffff8e8a22e64c5ab2bf58239c02e6a6f94141b4d4c620867843571fb5992c847acac84fa1327571d7a20e816ccb536f16991438d49f4500230b13a5b340ea6e02cf478404004c9b419d7651892ef5b8eb7f744110260a5d125a969541e582cefbd3dd64e55a6a64c2527dc26ef73fe6276b182946da232676c3d05bd3e2f10cd4ada67006bc277f204ce293a51d6d99464eeb0974c574589df7b1f32203374f4e314135365388090049188e2e71da3dc9461dae1deb9f9d0c38f6bc8e052685a50ccceda4b877f58da3e91288da6b68456c82a6e5af6f395bff7378405d2b01044dea22a3c9d4e93b2fa6c9a3a8b8e5e3e91b04c7691a92a2cdd868b52493ba5617f22175a0b5df9a6e964fc0511a1432b771735e226f7c2e3f7cfac16b2a226ca5390fbed50d99f3920f93e3adc5a16b5c63660f1cec87cc2ab695769a1c8d39208db710dfd1c1e7cf1c6db4cd21268fbdd619e86da806d4056b2bb0f570cd4ed42bf0eca1fd4f382ebfca246326e8965c464a90c6e5dc21115e1a68ec46bb8816b108cfa7f09825dc0f65af9ad737c8c147ae0ca9ef9e5267d3418d20f402af7a068f3836359f65204c7033db34f47ac4d099df9d5b77c6d67eeb3170fc8aea2d88ae993afeb7a32f1e6361505a74cbccbec4196560416e779be2ec4b3bb506e20f5c043c392942202f69004fce657771502b25bedea0ce1928f70897f333d6c85d49744eaebcbc4dccfdd6aa1cd0ca50e16fff0277bd8cd787ac1609159808b17a0367b02f84eaa19847546eee2aac3333e6b829508b94780f1abe55cd0b35799c42d57e0cd1fd14f6292cbf6746e34a6b2c6e351284f676a32b1b5d32a75c66ab4dbc18a072a912d13b341d42ba45cd56aa9268b47ff59955cd252596600e09a47b38b99f6693f8bb0e57eb3da0ec6c6f23231713e1b1a6a5dbc705a028a9653dde9504a9aac11a5c13074860cd203b5e88209f2eec441b726194bbd8a6c8e8bea1f73bf144f2e8f42cfd27e3a8dca146bd4757f059eed24c6e4ea156174e9565c1bfff6a1e2dcdf997bacebe09f5a0fdbe6f4db6379bf0d9f4e3ae08677c904010a127ea886812e9b37a38919739a83a507a0ac769a5b209176ed4b4ad11c5f6604fd75912a1ea2300d1a28c4b038ecf2b2c4bbe44cf212a9a542ecd1c153c4b3461bac272cce556b829c43205116dcec88171baae2166dc75002be46592b0cea9d074502b9203c44edeacc25c618729ed03ee5f0972641c86428a119597eafc8b56c3206b6055aedec4c3908cb8bf0a68e0cc877f97c9dae8ef5e50848bfc4acd639bb78146ce8905073ad1cc0ca68dbd54c60b0406cea113ad77a6a359e1b8ba7c3ad709d37b51bfab1f4ace16353edd809ebd505b541f7755ef84a2ce9e3ceffb717aefd5424ca820b8bcd7d9b937884bbd1da31a4a236f048d3850f87e45b20112a15006c11aed4bbdd5b1ab668b2c1962faf584ced6a4a99f3b96d86d353547e089c35d53db5b02300eeb03d986fcac64718ec46075dae6a118afb7b58b463509412ef23ce06c0488965d9dd20b3d669533022a28fb97d72a52faffd179f0520ccc46c76951311d1c4b649c4c0da91e07e00dfad07192e513f5cbcb072ce25336ab2af8f0814846acbde09f6e5177d41116b4923984e0b57b9cc051dbdf809366c0bb72b982542fb6cc676eb76c6fcf6ea4ff1100479e38d1dd996259beb3a446569ddd74f71138e0f1783b8be8983e90586b06af44672701ab726f1a5be40c22d4e6da307c9655a4779b5dfd717bec0575d0d9f4dcdd4f16be3dbe5f502c61d0e9a8ef9be5c6d7901ab56920e7b8cbb22ac3fca50a57832271d4a47a1b895e133f09532132ea14d7bf278295385cc9cc09077e360d5a7f48012585506e2b11c2805b25abd3e13482d93ac645b12d9f9130aa51f35b8f86f05d3769f7ccb60849bd3d0502948cd569c9ae7a8a5c3235f1634dffd76ca0c8341d485e9be51874d8273333a36bca442811fd955de528f866e9d825cfd629b200bf823d15b8354f0e38b74198ee0caf7ea2bda7db1345f8ec057476df26c4fb474889893ca9c22cd0224906bec2e996b4731ea6b597ad453a54fb93184bcb432d6739fdabf17e7fb84f175095f08d8600461dce73110427262cb723b720e036914076830a7268db354ec22efc7008408853653dfdb1765367722913f935e2bf91bccc4746f823e7d2387069b5a168afb571450f96e9441060f821be8e4d08295a33a87dbda385cbccdb7344833d76671793aca6f4539a4ea89c092f9c4f9aeda3e7f6940c777dd751fd52f0ceb067d597e06f07a45e4f2cc0cc04946a7ab6ff46bb1b637f1b4e0e20944598b679fa3678718461a8dfd5cf4e3ed2b17661f15d3035bd7b1adc108640b0706449023dccb65783d85d0b50fe789972e7d663ed4e6b8025a82f256b9520b7654d0d13ef95a4c9da7342127d072c5fc0595d61a03294bd60c95938c8639851047e315fe150e635cd259b07c6eef1ee6ed483a734bbf411f0c2ec0408a8896a4f0fa5a8ba43d42d954bbe902643f7cd08dc9d1aa3bacb41a0f3fc664cbc60987868fd8c5b4c798d49248dd8cf9bb09799aab2199b1023b003be580335ac2908b076a171cc6a37c2e086a9c653c054ec44fa20b71df3f09befa74b43c068ac25443bba3ea25d3ce84db2a10400c53f52e29e3100dbdbf1d9460a15b085046b61dade325e2105157d542e5e308a7b324c72a5493b9249c2b570396a79b789787e924338bb834c89e65d89816c5e8f0b32a76ec83c99c3c237ee72243002fa90d4a21348ecc1259e53134292942eb8cd4af24954e56b93e24b90485edf48dd9483fd4b2ffc7658b60644f2b34601c134fd61cf73461e57b7f8345d10afd977935e14d27a65bba10e3a4fd77716c08042041590fc9404f1d5a0ad074a65df61b270039f041d3a8708ce940dfc53e3f582a923d06b83c414d44aecd51482567c7206f7ed99981b6f8d8f93801eb9de82b53284f8f26360b3c7dba7e9223db6da4035512e291f5494a7c771f4dc0fbea1490dc92741d22e9f6650fa8353c05ee9488c28e72e07a41bc7742cd478fabcfd1f3135e3dc9b41adfd57b6a64b6d3df344fea5bd51d6c6a3b6f4f4d88f27fe0d57881be34bb3b00f01cbb66409bc679c541042ae258c7b46707fb8c775668f80354f805b15a1d2f7993a5c410e1aa8eb567cd81898030943f38a707825e6099e8b5b744a9b511ffaa2a23dd7b4470a7b3c85b0a85844dada1944a98854541a9951f75a43ad256fd9ec47f5a6081856a866a9c8ede739be6542a23105c87bbc864641329b21280bdcbbddcb2d9b63371234cf39062d38e8f0df04e31463efd198ad477c4002a6ea3491150b242dec21b1bf031708973c44165dd857c87a7d0b349ac730c8c1e81e44258027bd02786418c4e510af39d5c99dc4fd23223934e9a96f0a06d4a4a5548eda548dbb336669dfdf745f442d69d565011180b0c2a8b2e5f290c23e19b1991e0448ae4088163709b7298c967879c2e74463ba91daa7d21132de9a6651828dd870142b37aa759f5dbd5f16b0aa1fc740dda7575be5db6bb6e0bfe63553e695d5575aece6c79994ab922403f5ae6ed5f15f04175528a81396b638c95155ef497b6715ddf329b80d0e6c213719d3df33037fa6295747033036eacb96a6b855d53333e5686796b4be6c4656d2a1a5704cfd4544961c938613eb90726c5c8de936fc1b1e4c827bfdd600058a38d44a042a8a159d09c0b888fad58a7a78e6b6b74a1987360a2478a28eb51b8bda9a5e1a93c7bbdf8481a12102912942d373872a8b8ad6e55ec6fd86c486a62a511cf8c1f3071f6bdb18cf5104ad5c7580b688457295084ea68f2ffb226b66219e88f60ce42b7126b8fc9a47341d41d5e6876e9e9b695ba255d40e2761794c12eaf7bcf3178da79a3da8028efdb43664db033232095306ef50969911d8c95abbcba4c982333ae8023507d0933f9720b8f6027293e315edc32f92864b87f403a3e0deb752bb3a8c85f479f2d1ad00ad5b1ce00b9d21bc72c94826bcd6ad9ba5ebfaedb70438e287251d24d05f58d8b8886ad7d60e72ed98683050e815fb443ecc7dd6ff2f0f7d720ebfa8eb64a7d3b33ea27d67a71c4b5a485ccaf464504b18e86ccea5272330f23de6865995217c98c5b5f6f75d378199ba140af23fbf6fbf517961464ff801b89f50f86fca31ef07d57a37f0dbd52a85d402a5e4fde0cd8c4681e0979c082b927a08e49a68c554ebe9817f0668159906f9a5a0654bc56140b34c961e4d1605b812327aa84f1eefa361e6583818b6b51ba9bbc9c5c4bdccf8dff5114082005f5d589b10a167c4352994d25ffe343564bfbf4e6dd56a077b1a42d66352edec50a63683ebe9b902fa6108aac7538528eaa975b71fe940425f23d65b4ce53076a7324e360dd179ab5cff4312f3b651f8c0c1102fe563272312a61d990b8e47fd02d1d30349a387b36881e69c1cdc9a502b18389fabcd759529a02d60caee7aaeb4224e57b487bb3b9dffbfdea9f191369ca7af3a0c3f4ce4d5c42ba710855bc21062deaa86f40791441b1a2b61421b6d117370210a11be9ac37d78810c07c01ceb5fec6173f7400620883c47b1e8f7d00bf327383ea57fb33bdde3f80987121a56faa696d3b8abc70a40ddfadc6bf438847621d02146c09afc5503d6f3268c4d556f76a2627c23efd1739ab9e8e6816c2b922cfdfa89bff0962ae8fbde3f0fde8ab087e4d8a45285a20312090e00bfbd42dbdbeb241d73b0b0b407f49886e9050286c8098a212d54c2f57e558f02ea51a574571ef4669abd9b3a4ddbce01a6d6a3295166815098b0a929c770954d5e4fb3f1912e0c5f85699a8e823e2919dad695d2d49e3447b95b75977c90afea5d96c462d040aeebc318cfe95cc126f659185ef2c4c91cccdd7c628617d51eb70cd9bf02fa9f3734d4e9e6ee6df5fdd15e51926a1f3ed4c59aabe2587d96b4aa2d955783221f3e0acb1a6b2433e8b6feccc57707d9f8ccccee652a3c931b1f90fe0d1f1ae35683022d007d6aad8c8291d5cd42c7d0b538105d23c92709a186e49d9d8fe6890b7bf920a496bacc43a45982f8615a087c8b075701b56772074cd09047477775a786997047a18a0ac4dc9400ed4b8e164c76a08cad1af178834233c09b76e4c28a3cb351be18d3eefca37a4e6d6498b823f8d8a0c5260126c10a8fecefa0e120a20fe3b904804786354b35aa9a74a781f72990997cb2581ec92998d67b48639ea1013b66afb2ccb6bf59015f1a8a522130eee80e1f6c937acedffbf3b99991cc13b60fe0850b04533ea14277d2679327dc40602ef866b740d177c4f420a855bf4893f05726ceb27c6164cacaf679fddaee4ab9aa44ab1491813e0de1de97a2b166fdb57028db731bdd60c28b73dfaee369d4cad60dffcaf7ab72a076f91fc859609d58dee97b34054782abeb7facbdb6de416b985cc9b521e276f841f2b1953ba2e120ebdc2d131780cdb677dd08c06ebc07eabf22866b8a33965cb3272489bb0e1f54da85dbaa188625a402d485ebc4e81211ce717f069a38c8dd152da6fbe23f6dba86bc8c030f06d4af01aee8cce880b71b8efb7268dde6ccaa60955e1a33643260b35b3e12478befc6979bf3d9a57cbe1828bdfa5b49012d5e665dc1bb2ee2f7f78daaccd409de247975e6087fabfb9a558db85b90a50568b8d25197f2fe18be9bdf5c350cc95cf4315589838c28a75a738c6ca6ee5cadf983e6d66e1c036d7ae2bc12559231fc067622ce6d834f4f8b471a0a084f6f9b371e5faa8bc0310ba70d43518f0e013e1798ef666b58bcc9e8d57a436d8adcd24f315a66bb307c4d8ea6eea37c766c66d88d882188a1f7dedd4edca9f3294756a4bd3c2a2f4ae696206c8f40e3dfddee5f6e50fe742d4198ecdc2581a8dca1951a0e15ea0ac8b6660875b422af75f3116939f3887b472a52e1c3814643407eea53ecc0ff353a7624c7679d2a903afd8346ba125c2549e6627f8e70d3b20a2c17ba259b6fa044b87895516dfac608d768219896c0b21ff979276e6f46e9e30b32ecb866b54a552989d6729bf1d457c072c668eb1835dfa2c15129ce9a73a689f8591fe3944579760866ef54a4f56d0c3f1018d1f5ba65532893c7a54b63e0f91882cd445624dd602089d9fe38d44721427712e9b3da2a39e03bee73281575bb2e0e04fec3a03638a7c4aa154f189b8784925f5c6a790781f1eb1f59a90eea0c3e7c17d571108492097f6b508d0c24a5c8f057a1e8c66283b08ef69b71f75e136defb4a46af35d7a8342022b85dafd9e68d345a5bf4e2e0dad9357adda45ada4dd94e3ac4ae13a0f56ad5eb69365c014df456c0361b69b89f14a4369ff834f0c095045df2629c26eae8393a2e8b96dfc683c074391d5c1a231a1718ac84b19b1b6a580dc66c992144ca42a8a8c88284470ae6104a00df8cb0a89ca1c08ee27314fe1b2faffe7115f1ff92d8a3800942a25ab2706d3244353688742603f15d5e877879ae9e074676188839b4b29d6873fcac9ec3f5adc0f6e98aecf7a5fb0ae1bbed04845d88e24d86e7812621c459bdf9a6be4cd41c45b915601fe303ea7dd487fb92b6acc00715a4d2d87c146eddab7d4d9d8b07856994e69c846741d47e4eed4d156abe18cdcfaf7f0faa40885d4d76519faa09da2dde5a4440ec317d2c5923a4bb154c04bc103fa5293467b744af47c01e5358e793f53fcb44780a787663a94cc35e93921f947cc725ed1b27421cc7d21af1b00c1ac4a740211e974bbc82048e58af5fda569979119be00a71f446d6c8b9613e63f8f90fe6c25535bccd43b392e8a3f1b7b86f7df9d4b1a8fce1e5a2f02059007c40568dd73627b465f984ed54828faaac631ce9c34014284f4e5236488d0e1e13c57e1a5874c94e0ac1a148da0d52737e4302c299c519aba7df389924419c7c1eadc4a750c9cab7a66e0bd98cecee36265692d831e46071c8582cf26578afeae36d9f96aa8b2bde9fd5c7aa8562dfac5fd2bf4ec613d40cf2e4b084d8844387c2d4d987cfdcfbff4e37ceac27e74b37bf0e236e32fc5ba3a53b2c10cca533634a7f070268aa3437df6a3325b37e4dedbd3272859908a037ef950c4fd7015aa1d5b90f9c4baf1d4a91adc8412d2ac37299e06c2a344305350880a79bd8ebe1820f29afbee99703946a3bc105f1c9cdb555f6dc09ea9e80f23c0c883615895d5cd5bef50d33f5ff9db3efb3827e7978515398754ac272f5d0f373df11acc8d2b3a1191cb8a70152d4c1939f335e8f59b9fbf02eda2c029e74a4efdb1d614e307c6e2bcfb3f24080123152be2617cff821df3bee67b9c36254cd3b04c56c70172f7d6a911e7d356ce98a06db4076d8bd5944093aa21a222473b56cad4b2e425aadb9d8ee94cc44dce309f2387c29ae4346de1e633e64b29753d48823c970afd5f20d5a91e4c7c9252a98fa8819e7a0d87cc2f8264a65e094cbf20862b15a9ea49f450d39d678fd4dbc3d3a426c14baea522681e8d811a849cc9380415803d6ea96d1c1bfe454535d223b1decdd8c29a418634d03f355c592091e5506e4d594fee4856a738834d95a2cfd0120c438d76f020e0c0012670ec34699e70d408f9be1a1e02fda344c8e9fd88cf99ad5ffd54af067f840be9cac323e88b720dc82722521b709c96c65f9d4864eb55dad67cfcc09931ba399c4d1ff8b77cf43c8aaca39f490dfe5a3939a37adeaed1b6f36688487a28de6b9b1edb43859959accb1e2fe4d8f5fc691cbcdce795b0a064116d2f73d730397aa264140bc49215f31d6a349f0673e0467ba3ad3be2ca09c81af2aa4670f57825714992880b867cb1cce0105e533598025454016d3673d795c4dab05136a2d2588128867d0eca90247f8dfc5f9374a274aec2ac96acb951e951e9fd576129b902a01da8c77d5c294fbf3336dcde54b82237de2a09e7dfc5f6e528a5ecb64f6355d311b2a47ebbf554556c92853c12612af1fc527eb500bd8723d03f9d02d0785d45f617f2f2b04eb052fb5c963fb3f2df5bdb275fc47b63641679873d90173eb5921d00873ee58cd0d6b56d67b92631bbbdab25b120d299039e08ec180285d944ee875d5a620d167e174e9e5a16343e269362bb0e88a5bac50bb6b95c48d65ea33fcff63461ed625730632473a06908662fd70f8bb44ea966b0e1039fa52a662cfc18dcd87782d5ec441dbc3eb662b56eadc83cdabab48c0ef7d1b43f95d980bc5be02725dbd941c5949b7db891bf6a8e74e19573c94e4266acfd5751d9708f9b6202c6e199bb16eaf0a9b5ddee50485a5598228c6a5ab0b2988a1055110268d2f6f36d5241d59e4dae075c1fed4a2efffc76e4ea2a74af2172d2a63e972fcc19b499c8e846ed2662f8a268a1cc48827a0dfc539c3514eca4bd8dcccf0c0b5a40d45a5e987ca4e3ea717bb17c32d9287707f18884ccb44f7510c299af7e4463a20b3feea1b5bd8387c8294af27bef0d2f2cbc6374a01c56bee2890909653b5eb1d8d58e518ec79fb917cf30e1b9537ae82d74fa4d8c8a3a514236038db53caad9753eab8071f0f827bd6dfb2a25f2084d85c52511acc25cefa7c4e0ba83fb36f01e20860b5bcdb71b51d54f3292d11f69522cc4b3226c97f1a7e0fdb530b957595afad7559b247461a2fa2f6a1396ec6bdafa8850ecaa8306afb944f1ce6d10e53e6dd84e3c54f1f2f215091824bfbe221e388b816e2163c736adf35d466dd5a1f855057ddd6c0aea5e485b9a3ffecbc3f89055a39e5d2f388d111ec09e317800be54234e94f96ec5552bb362057d651689881f10adf922ba086eb860abdcdb0a83cc9c7676b96aadefcbcc9c1e22b76c7adcad385da9a235cf15c1d1a73060c7c7b283ba6839cdd814e7e33d803b731ac17ecc08a06d5d1e53c3e5dd4286ff22195eb86f8df7d67a4f734c841688c9f8b94af6d601ee20a2c8329c11d72c72d9a5ea0565cceda91260b792f51323a1211155f5a93e01a4311448d748131125624f21bcbf62613a4e8e0b9df8193ee3a9c9d22d477f1fb0dd075c721a1e595d738d38ded8dfca1ad2df69c85bc9e7510ca16cba50580200eef62ef4dee4bdd0b080e71ef422c8c658e8f4b3af8677ccc54fc138f1b503ec9a5287110572bcdbb0f4995f66cae25c3ed3bf9121462a0c87ac64b9be428cddb1430e769f2e641c021d0ef7c3c49d91528774be2af35d65bec6cae51dfef6be97849c4ecf3c37d0f75c508a103a1019b2c2f9917d9bc61c079ce84932287fb11a2590e5e37482b5ebe00228bbeb31c4641605ed2d17ace1aeadaa29fb311aa2c0363d901bc5814e33476326e4fd89ba025f516de487c7382d5cceb72f7079d446f529306a7c6c20b5ba872f19c272899793137b4f84e87f4b80f7c2de80a6a5f8d1ffc90073e35d3e5260c1798b9863125430bd5bc711928941766923a8277467c64dd76fe2a8285be15e5576561a6127d9f0258dff670d45b7f2981e3fb95d9f19096675328d3db8e6946bf7d97e6446930475f76de9e3d6b86b15c5a5fde79901c326320469d69902379c2791eb7cb5c30ed3167bd3b1c264c708ee13288efce96cc2f87903490d995892e76bbc9e0ae373458917fee71cc24f2da0b71b79b5e9a8d6de704e4575307ec07fe0eac604f46d736da7619c381b9ba98bb856b0583347fb39e0ca1214b777fe9b9e713c237bb0e4266fbc7dc3fe426e27f6aa330ea07c6565753701b977f5afc4b5fa452fcc61819d0fb59dc2bae1e94d2a29a6d1246bf2df0246ffa0cbce208904a0699939f87bfa7c3a9c255d33a08a9992b61bdcf386162dc6d06c3b972ce6d4da1fef6e11bd5127aad54ec46b66e0598b2c6be2ee3a26c3851305fc079bb45d38db0243b710fabd8fb069c9c21b920a2394eea30c00d6f090666e024bdade502b94ad9abe80e39e077e5bcfb2f3013fcf35c59097ff2835e789462b776632acc9258c0c496f7500fe08b26dfd54902d52c265494214e386f2c9a00de15318e98304bb07324d893d0f9f18dd6e04a0c1c804e32993aa132f54b2d62b019ccf8dac5b48286dbafadf1f47462ac41af3bc491c0bdc31b1406ba788a3a62ebdd596ffb300f67c771aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
