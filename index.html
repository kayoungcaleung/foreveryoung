<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd9ce8d37f896f11a867900962feb086570602935a48550f30f1cd73072252d8c680a35fe8657c83f04c8ba2afdce16e655eb402a8f67bb77b65e281bb0941fea8edf3d3b4242b9baf1cc384493b9b1941bd45d4ec1aaf9e5294f81c2fb6fd33d97a97c14e7d8db43abcc4db148039b94347d13a0ad08856548f7c7ec57fe6dd1d8c1458ec4ea0f674bd08d60b45cfed4388d2a1f121fb72c923cfb8f88ed087e1cd7800ecd4da5fe6bef315a4de3a3f2140995f694a7a8e3e129cb6ca41f1ff0a9b7426ac8811257e037e49f2e11de280f9a3b58a60be86a57b4bc58615a0493d77df94692530eaf98416426a865ad293260faa61b8ac7f4255ffdaaca9e393f0c9e8f40a418bb520203e091a6cfc432e6fc864dc8b0107b1ceef716e233117f4a4359d5404009141fbfcc1514e52b52443c71ebc1f290167b91890c80fed955ba02c4655dd0fef6925103e9b3e040969e8bc8aa460c81a412f6f5dab5791ca5be84cc8d0b3ccde1e9166bb6eeaf5ec134c8a8d88473009816efd69802031aa065b27c53160c007e085009ec28d6306d08b6a58b07ecbe41589eb52f64f8a11f87e0c482c27cbda451c31a0ae5efc57adf97b3fcc96e339c085a2104764edb3fce5d704f0111262327557c398f3a115de0321345ff6722eb02c83b2bc3fffaf0849c585e5bf6fdb362e87ec9063699cba566625f897f185a95014272fa7ee08123710e33ff68e32e34b38c9d287600f2bdf4944a6ffb888c2bbd4c12d62cdc581202fe0ad4f67f6a4d5a5c8c3b2de4fb6ee416e925b5fc0749fcfa6ca096238e90411c0cb0a7e8bded417b75c00edca493e254e4a06799965869f52ed6ba555e1183a09a1367c4b8e91a44e1d56fdcce252e1d6ad47e8750a25eb3fa6bd158deedf0a7d1bde5c6f3a3482680ade5bd46a861447bcbf8a101b38c719976bffbd5fe71098cd82804023844c30d533044d27a45a3b4c2d691d56d9ef5096c24f8e8b54759ab7639aa5627aa114741d025840cd2518dae8cc980ab8077b92301abf6a62406412280c6b66df6949eef0c1e266d783a3b04363e9c6d1ce64db72c44cb51003e75883df67b7e22afb337908ff4529984c13131ce04ee7c89eb6b024c4a1ecb8a77ebee467f09ac38690529b1ac6e636e1daf89e96498cf35ce384be6ec31816997f39cc7bbd2f11c926971238d977864d8143798e1a13d7551198e8fc516a9b31ad47463e25b6d1a694e4354656b06bde4839ba45df1ca1568ee4656a5be08a877d5f7f9178d25d980d25ab277fb22c97fdc2319980014a5ad82615926d9bace8a70826703d0744c1c0e55925fd3fecd91ec8e793c7dde12ee51c8a6d5aa0965914d22241ccacdee15eee1cde61c98aaa6b937048bb421b37e93c24fcad732317eb57b85b2010f35a5112fdf08c1af2a6c4abdde4e9dd8a146ff6bb88576544a27729a162f3c36f4f277b0be1a592fc7c9251f3216bd5c14f19fb3cf3a172ca2756e00db6a1e53f0ba9cd4e93b010acf0b3b14a25dd38f2847bc45a514318e5e035d304739bd7990ee1271725826744e0ff17ddb9c56d8e9f6ea5fc32a08bf927828a90ea173ebc6753abe324302aac0a9647505b92319e7979cae01fbe3e64d6557e424a682416408b4b831ecb17da57c865c917e2be179adc6164587fa7a3e790ebe732ec6aa849894f2a37538fdaeaaf1d3a8dcc8949e86a4e41eef43fc876570eb89172655de15d15d6fc3eb15e7da777e9d3b5e9ce770dbb1f5f7662d12e28d7f5988548f53990af22b6f1fd780502c226a58bc9223680e28b6cea00dc1baa7422c4b5210d26ac3a49b285100523d7f9115e9b1fefb1af14587ccd338f6b1661a7f1f0cf3a82bcec323e4896e591205f81a63735c6b155db805c4c6face632e1bfdb127418855fd87345e87b5641662c4c500dbe987eb543e069da95f6d2e65381b22a264f2ccf2332269a26fe33a94adeed8404d6365dc238ab864636374b6e3814a209491170282a4d186dd0171233f774493d192fcf85bae28283dd7256c113f70955db9d410c7f02f294d0667fd6284545e7b435e7f66a3a79f6457b4338314e7238054f92f59d1ef45595cfaf8fe0ea3087d44aeca189091ed0203019310c0e458347779c553ec094a9ca031874350eb77e193c0572433d738bd9f34b97ab45eefa959d933da1611eb2ba1dd1e68c8918c0f313880892da7e1c87673e1eb969007bc3898f987a5a550f70fc0c384479c8d305bcd029232ae208e81522f53f009df3e205344b32514c7c42b0e4ab7dd8947afa87e360c757bc6d27cf3c9ad797722c33d2879212e710fe5afbeef2d4f27e591c0bf8bf7748a44d3e871ed679b218f184f1b47c04fddf450dbda194aaf44828353fe8408ab5e99d25fc561507ad5011e3e5c58f36e4aa3fc6642db7d624b9746fe4c2094a51187bfc659f8f7396fab7a3812aa86bc5756dc9ee156895ebcee0f4e757d1b7b882f8159c6b12c073642fbc968d80b269cc2133c5785566c8e6e357e9911ec916c52483d6c6ec7cffb37320f309a238784cd123c4a00216eb1d4de9bc3aa67148847985aad6dd77f227311759a30ea07bb6977092b202cdedf8a3afb3d8285a006f47e99a115089bd680bb31968cb71b004da4144fb4a8270d4f8d48435e60c2e5f4607c50246f0379f351ef7736842250c8ec656909683cddbcaa0b3a873cfb8c2b7b152813e1e77cb81c7b1dc90085c5edf3fe38b13cd2b8c841671447ca32e5e32373f427d9d25bb65544297b7cbc40ad44917e70010954dca5c763f5f144b06c25515cff6c0de0fbddfd36feb54aa1897c266ae3c5407e87a27f08775e96bc5a417b8c8bbe4ec8cafd9f69ae6109319cbdcc2db2b50541841ba7dc12f6ba8c704bc500d6d64d3d2a867cd75c57a021a86bb69fa0dbed698de1ec5f642e482d38bfee66084bec137bf4d69f70c4d740883043123c72803937d250fcd87fcb547f0ec9d50db5e7726a4763c104b0a8f030926ab34e8b21264735a5771ebad86d89c6bd0714b1b2b1302fac3104747cf2fabdbae7b82aaf418db2889027c46a7ea9ae088896b9329aaec190f27cddf8205748f4389de4ceaa9aa382abbb299a538d49dff4808fbcc863551e40c41bbe0093df7862182c6bbc1860fe971d43d8b476c73bd56b2b7d1e0f4d0067436dc1490946fc1ba779cbac0be0f7cab66d1f5c947d4186194b9c944e22bb8f22d6a32de8624963e71b2e3e1d4d24adb0182b5fdfb21cf6dffd6100c0544a50060fe67ad7e5b11a3c04b134a21d2e01eb71a09b50e6654c286c0032e3bd0eef41ca2b6af168343f8c67ff1da005b330e7aad4e23c5165ea792cdda11f1df65116b2e146c9d5aa81ac64a89975397bec59baefc10c79eac0f187068c79e374768ff4cb095ce53bfa3990e27127007326e03f25500773d06874c94c808173f3c0c0184411e7abd08edf2ce1d731b141298f2ddd9a63c1e8ec071957b2031a49a36ec8d31b8eb07ff8f96b81a82130c1e8bf3e5d174edf15adc7cabecc74c317617341a9c2bc2700d93518f25fbea8e51e5ae2065d91b1720a2baa66fa6851dc46626aa1fe8d6f47ccdbe15c8e7f99194221bb12bdb1b34269838ef63fc974b58cf4b3ee2a53fed2d827f99dfbd2f31d16a381b3f5fe022d7fb3f4abee8f964d022ecdf6090a549335119507188404e4315b6f28bb0f2112d782e9b2cc61fc9a706ae430772a02fc3333facf170367cfbb62d5413c8bda10a62aab826af09eca69f81e6f6a10c2c7c6b927e5c82ce4ccb3d23ccc14db46550529f0b993f7441f7a55710199c18bfb52c636640c679311e9e4d89dfc97da7f7152cf09bd57bf235576cd4262d78fdf508e003748cb2f23cc75576dce86bbb257214c42fdfda40ffa093f1a2a6c0cf30261860504309cf9d7d7cca58926778c32630f8dfd8da961d1e4e1d78fcff7f285c47c2b96fb479d059501b840e6e8c5b73a8e90d863f8028206a835aa4907c8e7f422acf7e3a63b0d394447b58f646962478e6f8a9aa6cf5b248826d43448f7e672ef37a4e75e2426d67bb9a357ab3f2ef47b5c208f2cb8411758d22ae44a2f5c494d4c9f257b267c1b7a404a81a24148b2d1477e4535da0dc80da85698572618d3f28f0c4d4fb05068c0320febc9ef58884354c17e350edf8f0beaef955e8c651086b308465e5d29fd5327fb9dfbd58e7a8065b723ee28abfe9f02e8eade58a1c9f69c2b2072d237c2080c5a7d3cfb08422b4b45fe40370a4f967a0d6833daa279c5ad0c428db4d4740c100a88b9639c4d4aaa911dcf7b03342374460ca8f5b2c284368649941e7d1fd180852593c1b9968c630942cbf081942ea6e73ce197c9618ca3df11b2be4b72cec6f03b804c1ea32e62de62a2bb8b50cc9689c110696cc3003f9f229c149522fc1309d10eba475fc0020e5b5e7c5221b145bd3d6ed91c82e2feb7994cc733e0ed7acd98ad6db1f6bdc5e99694e0a442cde3683d1f68ae5fe8852d297176ba13b486ee31b22120fa952c7edede6938137f0026e2ffc95ad0a33a1fa9aea9ba06b5d7760e5ebb1aa7f27a44eb447b959be0a00f359a7efa175145e9292bdb388df47dc7591aa6b4fddcd18ea44c95a057cec9a0a92f08ffe4ad7bf821d2ae097ad725a651bacbccae22b6cb1440252920087d40b417ff478bcfd210ebf59eef5eb07340b599c09b4ade78b7456f89e67be8022340504e53169c2b3cf3ef6215dbc8649f55df1c5c3bbda5c0e8e2a177f57c7b7351518c8d3130e5785d78fb5c1592dc1fec9b0975596d858bb33d8a6e1998ca52319ce5fcbda43644c30050e8d0066115b75091dfda4a00cd2724e24a81a9c4f825eabb38db621b848b3c123901067ccc674c39661037fd989c4c27d051a138f1f53d8c256e2402b9ce34d88418ea441119300aa470fc171dcd9398a4648d6999edcb4ab70a20e216ccc897163b9335a39f3d24d1c0ae4826f75474e7fb330740d01640249c9165506cf3df8e1042cd46778c532d28699a4a51d9db229f0ff775459a99a75f1e43eff1cf3a6a618d86dec8237c3e7c18145858662091f6f61cfd68a0a935e43c5960fbb8fcc557000603e310378e5b9731618cbec9d528aad91e779809e463c59212e81f51fbe55f447873ac33d19285229cde92ff4afd76bfa00a70075ae13b3bf86da562aa7756f3a5c4a1444aa3e9d9ab3f15a1559e6e43c626b06bb7d033764ff6381cda178f82859ba9a0127220ac69b64cd23dd96d088de7e95eb2e4750b465e54760db6350899968f0bf328ec1788558ff7cac496942b8542b774b620284534de881f084acca825627a4e723351575c95e40940546ab97f649ce57288ba178ae97aecfe3198764ff8331edebfb51a78aa7c453a2d55d889625cf783ebe4d1562f9c6b69267f066c8aea24b3d64a113fdb7b0709ab3875bf55a0f71247da2606b95370bcb9b6a6f3a5f6e2d14cec8d6219c4987e0df45df75a4eb8443401974260767a6bb454e09352b164033b5d03802a20eef24cdb6143ae5dcfb5761f8f588eeaeb23bcaff99d2191b3b59783f8fc7892bdd23ae79a1cafc4776478cc5d952a6ad2e286725fe541c2e696156b9db6df09e7f92d87ef6e30176c4e6b09fdb085cd77a11e766b605ddc4d73f71656fd690294221b9bcbdff1a8a1dd21ad2f7f4d25e8336cd33009c7721720ee391fd72d866981d94984498149b615e5b4c5bb73ec2ee65d030bde7d26b11667cd985445b0546453a544849a68e7290b04c6176ee9b200478529d41bd0cfe2e36b3c4d258ee978d973545fcd831ce9fa6abf35cbe4700c625c92a6072f62641e168fe6aa79de942d6d18d87225ce2c24fe2ffc23a3a7b882f631a96fe9e3b37f9db2b9962a0eca408a3bff17cb2341ea17703872ab8785ba5a5696232b2bc3216f5458f49328c0ed86bc2ff1ccf0bdbbb5d21b245efb4052e6f912ed6ed0f49b60ce03bc4ee57a0e4f0034a9c83076eba5a01ca642ac006d750b9e19e942ac735b2daec1c140078fa9f0ac7346cf783be7ef77f6b7620edc307948dc3bfa29c714a39d334b0838b02f04fbe1140ff5e244682955357bed5c1eb9c19b2b15e1e10266236069b5b10688fa362b9e52acda72610b8aff5f5532d9a79945b6e38afdfdd9475a357403f40d55a09b9da93407ab8a3ed42198a1885a4da9dba95e4f72cef628e2519092600cc9f3b2f57bf6139165fcf1cb830a5bac8d1e288a79b7c01f895573d930868a694db0efc8fd4adb9314d22c2ac5a82bbb450a6ae1186d34350138729cc677f7f51ac454425cadec49860d29aebcaecff7910cf8ab24bcf7617128196c8f75c99da2575e8566525ff6f0d5e4f69c928b239e3d62d673d1b723237f4401df30e0bd4e15510842514ddb289dd51eea4c5b4c2caaf2efd694c6abccd462013de1ca056c9d2e84d9e3fd59cc0fdd8ddf29db2f7ad7427e07e3c7c45ed3146484533d188b1865b9c81009811bf199cfb7c74dbb341035c1bb736812e1137c4f9f8530aaf8138b8c5971c5de7897ac8458515824cab64b21c3732fa6948da1f28fe3bbc4ba8fbcc7baf3cc63b44bb85f5cf2350b55c3cddfe37fdb97768cc37c6397d31837a198a89b18d9fe2bb3210c80efd076192ac06b6fe99130a9ea550266168c9d040ff27be64c8242bc21d74d2a7bb5fd878cfa2e4b6d206e31aebc514e28f32717940ce1ffcd95a0aaba8c7b12ac97fde8dd620c3b94faeee02b4d7c8e7e3d558e40577af49abec03f70ea8b819cdea71d1e807038455362db569f9d20162a8dedf344895d9e461f3d39691c0093bf3e177bc9696596c0d51373d088e6348549f9d5f124406f6ed58bc9c24baa64f17abd1ee2875af37caf48214a18b36e99617ee2b93b51e07a645c876f52532942ab036699b4e1ce551a235adfe09ddda2e86b73a99a3ed89feacb7188559ddfba13311a4d67217a242289613f717a19db78e9400702d1a61ca773a2ce4bc41fc6de376000af49cd81271f19630a7e7ba2653f2265c557200dab23757d012e96981c822f1cb1415196695ceddf148467518ed7541eb4385cc703928ae0d2c6cc7dadf18ad8001c9bd91e61823df4a5786512849b42ba61d8bef9e4ba34f9c19e5324c5d409c6f20c1483fc1a71c5ef10cf96789f10cd247b5c46acf2ae2fbf87f43fc34d3b9f2f76897c50730443af0adeb81374f9fafde4cb7b5f0025657b8500c396f299187240405a8997c210e85f950912cf7b6c23112effa5b1caf9f8be62b4b2602948dab4dc706d1b177ed2b2f46f2f16a9d048d7bc79e5c842120a136bfb4b2135b37967f9e7a236e01b2eaf6b66429046c78e6732c62c9820225053bde09bac1caf88a612ab0fa38ac45e2993b501394fe9c245a19df55a74eb779b9292e52304e6a4e1e7a478d1114cf402efd08d9dc6697b3dc8225ed40864966cf5cf66115e5b72452b9a7f250399d4679e8b836e3af75d5f8c8923bfab1c61db979b207b31b8ab17b54c549061dc58cce753e663b3660ed15618bbcb412ead4768c8482445eaede8bb7a155ff6f03b6765763503631bad81fc55a4a2dd80223cde670e32cdd27a068412d39e3e169bfc43b9ac4fc953812acfa214c5d00a20a27906959c2a069f210e3e0d25693bc15d535cad9b0168b916d831efe06b20cdfffd8a2df8c4c191b24a81a7575a67d7607582b5c1c6fb37efe06d894e9528eb6d469c897ea77a15cfa40bfcc69c12b78e7dd55d4517d6d5db2f2fe41ce96b2512383801340ae7b845b4c13c8069f46c09df14ad85043b7a37354d5662a52edad1c3155234a16f6540bb4986df6e675040a3abc211695da88680b3d96eec9fc99be8ecd5196029caf98913307526de013c26af2e0d32d99348c43f4c6d237cc3481432ce582b98b358df25fc03e85feb489f4ccef744a60f900e21fd60807c18f391bba226ef99fcfde424b10e453094ce172eb4db9ee32799e2c159edbf7cc5d00f50732c7b3973edf0cc0cbe16d4af14f0372ee7997dbd163ec637c0f09e424b54913756bc9af865092e4d8132a2d001e268fbd1fb1e8590261a3da41d78f61d20718ebcc979e9731b7a719a1abf8a9b08b90a6e61be931d28c34caee6f6dfd5903183aaeee452cbf9da0f0cabeccd419f7be304ca57509c20aeffa974690a9ec551d8543324c440d5f5b6053b0134adef55f5a5566991d8cbad0f88855e0ea2bed7af823d1ba9eef4a721767454da1c707d45d8acdabb44aab3af2c74dc79c18d490658e94321824abf3d86844480afdcc2de63bd445c4382bb754b446d71c67ea932255ba8aeda4549dfec3a794975b953f9bc64e98f848ba261da2023ab7a75ca1af6800305a792ba8f9790e457c9d7ba1e171dd5836561f9e3b2c374b49adabde2655f2200378037eb8c056689aecefbf34060ef3150d1f2607f69b1310e7c3cfc40cc48107ba96d0d68a17c3a41ea19fbfac38c4c21a27b2cd2ab94b56590ba52e9d21b8d640e90e84bfa08f52f23e0020f84fa90fffed058748ea55f86ff706d38d2a4a5b8000166c71e915c03ee8f308c95d392c39c3b550d23405b0f602ce581e5a0fda8d1416d167b790e5cb441d83a65ae16b71c514acd00ce9d23955335c4485627e2f520c139b57361802e44866044fe31d7c5a25686a20116654a67ab5fdc01fb36e7256cdae3fb398bace89d610aa398a09c6c830d5f84c4c587381b094d0fe7b92f311fafa1af922c1d2e7c4466c3daba70fa8a74794c48700b8d27f995abe415b870f25e90322efe6e4e3797650d8d9add99eafa2692663e20310272674533049d21d387a84d3cc98710717eafe59a9828ead732a38e5dd8aae386ca89cf46b05c06fefb4e8ea13f4af81bcc37ea637d69bb863d8dede415905c8baa9c9a662c1256517c345d906324a421f1f0ef5069b4cf95a8fc084dd33f56177f552b2cadcc1e05510a145c9efcbe57aa8e5defcfd0bfc67a51568c027e7316c42cf1cdb6a73c2fa1579aec30df2b998b9295487f88fa091f976a7b15839200f875ca1e220d159e1ca8615bd0c35558e23fa1e901c4dd2082644b12b6a4c671ead7bce5f37cda41a471a6f2505f6e7138fedc60e779e375d4a4bf619dba574ca106c7254ad6e79c630df17779527c3872de3a56fe71575a1d761bb6b8633945b3bc6ecb1765c13a17e5c520afd8d9e68f158c9d467f8194d4847a782cb57176d47a3eef25c76a70271cc1b269b4203a2a652af7910235448517d37b80753aaee343808ac17466ce0e6bb7ada208cf37d3a86930c2f7ee9f2f5f734201e9742e7fa7355e2db9c711d0d20bf6520c916e420caf497aa1e83a8a33357145d0fedafbec4d91200dc70faf63e4f6267fa5c0314ad9514a8701bb20e6e20e8ae297392a069e0f0486de2abba6bc267e598a43b5f47d19eaa846802d95b586eebec160485721c8080413d3935999539c94c7a74bfd9c379ce16054a2d7b7b5bd98ee1080f554431be8af00b3425613f7cf77d51de279ce3a5780a984015bb5eb1ba54bef53671536009bae8f797649f22df1e63de343d2c0e7be548ae8fa161b694c6dbf20b6b85b5c5884cb16982ed6753c7d049ba97abccc8b180821e35024c579c384c7ad27c0762d293eccfefcc9bb4b653000b80770df2989761de3f128998181c1bd4f23a657b5bf13dd0d8b2e75617c730f31ee070849a3d3fac96074bd5b8c4640cfa2de4a06a2344d5dd0a8ea52d1fe75c86633846d802f23ba85c84831ee2b6819ea1fcbc4c336d4914389d6cc8ecc89c97c82fb53668fd69865115c51cbcac62d632397be5ec4ef0fbdc68dea89a23a8b68fb931a39042998d74158383238a74624a20292de5a628c655e2fd3c2545d6fbecadb9f56bca709a5bb046b3f72100cd58e6323ce43810acbc408f10aadc5593afa0940509885924992ff738220a0217270aa7fe50f679a4e2e38e6b2fc851f01188a6914a00fda6e9545df027b8fbefaf58e98807e9684ee4c9efafbe8601e1fa88e5acc4b14821d0adecbab0ff434379b7dde7a3cb5326d055722d75c45ebfefa9e40e24c0951c62c992ab8be471ddd1f6289ff8927292f1a51e79206e8c768e06de62a4865da5755c27d1e31e5b38b108f206023bce089a6d0c86585fe2ad317d2697fb1280efbf167c6441bec174098938d461bae9b64d0b9a67aa54504bc173b19a97a839e65c1a5534cbc6b5dd9f9eb1954ac5f2c93c69db1aa3505b89073087124a14799f9fc24cac41cecc1535c7934fedc4cca25317359bbbe5dda1d075e20ec7672d0b864143745578650af0a13fcb5329bf8678da3ef1b0d955fa80587f522d0da68d78f28900d395cfa70d40bd9de37a7c4f77dd257afbfac25f9a44b3b633f943ece0a375e7fd19295bec7247e52d6845f3fa41836b824b735522c5b3096f97f7b9195c1ddf91371e44ac92061ee89ab16a25fd314f325b80860074d33d33c3c794e05f4b0aff1918ab445cca956e6675693691644914d5c9a846eb795a853b8185f93209bb5f734863a9c45b499bb2ea947baeb15af386ab3822ee734b6e810562ae02fc2ff7769678ee2c2a165fcef37fbdf60622ca94f552942567633f506d75f7afe9d63a8f0279f500c4cb55be7dc288df8fbb1084bf7dbb56751bf06a09bd62682ad1ea202d61260fa5080090855a00ca0df6ce5a603ced590cf0df2b546621957b9c2055d9961d25073dfebdcdf578bc3d7f316daf129bf0162ee5ecb6b95e289f328f438713194876b7fc266e3c0e7f6f957184cf3310c37945f2ca2865ddbf5827f0a0e390e47a739bae77ae55828a3e55a6524b794bfd962419a1575e7ea8173736bdde94150ca25b6049f025ed8a0fbb24714e8b6f41aea0d71d1373affd834b2a58023bc707def3b42c8c33bca07cefdbacd75c702932490695b9c2c3211c5703c026a0c97e2ddb88d17e266ac43bc2aed3207d05e4a826eace05232052e5d2ad7bdde50447e67050fe931b63ca1b02e6589412bf07a12513cda558e8366a67c7d41fd4e17aa558f380103d129edc8ac103a59c029ae2a906621eeb90377ebfdc637838bb6b829430f5e86b9315f31023342c941136323e52b06edfa8adab2309ebea05d4595e8f8fb7c0a8c1a0f7cdad7183b7b08d69e5e9b977abd82cb66c607747ea0a8f547db119616924950980889055ae847e58a3f0279d8ebcfa548e78473e7ba8caa03501266a7c32964c89834b66f4f775bdc5d5cac064530366a6cb0b3fcd4e4619f84a83be968b1cba442a5e3ddfc04c18509fcd33cc29f71144a5ee4494b6e65a367f240ca569bb0ce091a8f1ecaec5da7b504cf8d361704a9ce825b2dcc423ca6ebc1aa367cddebfc00fdbe7bbc4c5382f1931718533e5fe0b8b8fc5b199315d2bfa892e009db2599e20730a80a5220fcc0fc1a399fcec568ba195526f797f178ea7176239d0a64d24b962dc56c0850f581c3b03788925bb249598f9dbe32b61e7f97dfabb2a41c05199b64bbd46187030f09857d077d9dfb73d8d19affc9608021175c96415a38de1439e0c34487e2e7939ebbd5591074091bb6d31d03a63882a7d66d326f9e11ed47520668be9269055053c5406d17ac76e80e40962f2eb5d9ba77e93b2632ee04ab4f9b409220e077691e859161e2e733c84aade70eb579dcc23576792c80c61f1698cbe05e506daff564649c8860316237ad621a042aab0bcddf9095e2dd9ad0213b0db312560833eea0808cb971d79039e7a629836d409ee654bfaae0bd3b6a79c723a720504ac3285eaabfa4c4332c855536186f19980b77dd00e9a0c6dbe48307690e7a2fbe628eec6d4691780111c6bb7ad3d2b7fef4255f8a1d0f8c1d23bba40e54194380d60d5d312d2f186ce94b45bc92c21d29413c3eb49ec160c6cb3028541ae9f434d47c45a811fe53c2f2d435ed869231a76baff27db1da80982ba12f344d69bec8a0451379e9a64a727d1038162498cdc605a625ac9796ae1d5cc93a0852c75633a4844f5f13c1cb0b5a7e4276b04bfa432898e36f8384a59e38684a3b358f8eb96833e9daa78cdf7eb74d3cb900e3caa45176182ecd5269b15341818b1f99880d20cfb8980ec0df02a07942a684c409a87ba9085525ebe2b169c9e10c23d2f50859ea90e8296756d1e1493c0662b4cbc3b1cac2e6b188e693d367161929e1d0ac7a86c7d3897666cfd8b3ea76539d047a8cd4daf87b4aef5119b7d6fd25403fad56dc0aaf6efc835ef70733c16443f8594b5be6f3de0c1e3eca6751f7266159303c6d36b59cf58bb2d83ec38e7d4012f1cb8bbe2bc8b4017a246339cd2e84e48e1995f9026f0b37d677816311aa45f20babf0ee149f2c5615f9e2398b5bd4ef0f4bbbe12c55e282351599aee815a0fb06be071b4beefac6edd0d20c73811eb1dee076ad52f1f6a42132a45ae290a7250c12a177e479e60c2ec93da3bc91571348ccc3576b9dba3dbb820036dc396d4edd282b3da99069c3aaa49fa93756a94a07426b27ca9b8dd7aa6ad8ac1beee394b609fbb1f35e93cb70aaa5e26b0e1b051a04c78e3de672a1e1070168c32fc37354dfe03fad975c70d01017c9d8fd781afc3b2d08abc451885c31e8a3417667a664bac5366ff349f477dfcad94393eb2913c8704e2df209ebb3c8c92c2cfe7592541744c338dda2c4794f647f4e9c0f289830f797a01b99d930462abbc76b9f2a6e2b73257f4a3462f33d114df14ec3f33e4c728b7937d24798640296281719bc320bee0e2c51ca83f46c499683a7c03b0ba915ef8b8ce12d2094e6723ea32b314d2580edcec97d4e39bf7d002ab68b22c4a7a166c2701a4748cb562132c5e961c0970b8774525fd7ae918ff03489bc1ad82c8a111dd8b4ad2c27f83700e72cd9ca2f5051aa84919fc8b5dff2a9c874f7bfcd40bc7067a42014566cf75dadddfba5ef581fe3fb15dd3610ab9c354faeddb427ed4cbcc4629be84a7f24f021754dd81070b0e538b5e5fa881da7b4b15716dd957aca82224fbb7d77f63db133d1e05622d12afeadb6ce373d331fcec571367b89aa4bd123db5554e22c4c564d057292fe2a0c090133042699ca9571925e60fdf1114f437bbbd82bcb0898152c2be30022c03d5102123e5f5722ade9fa6cbbc0761af0ba7ccd6ac4a46fa54029d8f7187a021cdf53b4bfa585e56c1863dc7d8a688fa79b135300b0b5fb918f0aa9cf7cb2c860ed189e19e41d1cb983dfac05cf27929e9995d797bdc887ac942879cce40c7cac4144e44abeea40beb422c546ba264cc9c1443dc28ca1a7d7843f4c0026aec6ad8b26152a2d3984bf42c2b4236b474716161405119a799d25e52120ac8b80c5cc5093ad5a75b41322d82ac6a1f635740083c86377f0138c330354854fcb6a9b679d9a294934257208b89e39adc0ef606a91cc888eda8d0e73758636ac9f4c17e2e01e6eaa95c5747068c10cb5981d8da358e6701862226be37612009f002a10f8b9d62361eb4cfee4e4e5f99410889d9dc97509abdf0c549b785e4115eba96ed9b6c5e29cb151b045f8997c6eb1ca1a56ad26d3b4cc8578fab8736f38a64b9d2a7d9659382dbdcb03992a1d3986cf286344d7a5a77c23a0b0a015dc281ac8450c80691eefe56bafd6de4b793b3644fc2c5c7fdb076f2431e5cbc2903aa8686c344ab2bd7e44f03dffb4bb5118074484da8a851b9bd79927422c42f241d65a3ce16a06682bf7dbd55445b9b0bfc3215039a9d9aac6b85ce033770bc44d4417b33779cb46638e32a2fe835838838a4b6aa6d0f50b987e32ae92d933d739e82c6005c467c82845f7bc1d7391f76bdda8cda9ea5dc9b8a3ff873f970a1b699a97774cfe8a9a3dc4b9e2f2defd1590676fa29d560ad5cdb44e696c7296b6643271f6423ced00f6bd132b93b44428e10e364d4ebd60cba7a14efa8e1483b6af04158f51a666cbf41cb62367b1f3135f9e5b9544ae592e8d670c3981d3a804502b51348116b907619da082866f0c3eed68697214280808ad4c55045dfb5b4d87455101c7ae2ab61da193c9bd557b1a5c1164edcb7f99b75132bc8761afc423795fc7f93681bd75b53a71688e0ed1100e0153065090406421aff187e306f0edb863e131a0fb0e12751dd36eaf5f1129e408f8fee4506ee53c79314e4faeafc3bb17013d4cbad697d4b5ed0fc81336da92279fa35e8caa5a268249153da6c912f0fc039cbfa7ad0a2d7a3e9011f175896d8dcf2ec20afc266f104e0c54c33e3905f58438d74a83ddfb1c8fece6794140f9de93fe72a9606ce0a922f89e5f5434f8289c8a636b31f2eb46fa9bc7169ce8d1ebb4cdb26c3c3c9e75de78fd89749367fb926c636fbc385fdb5eb4a7de48dfd8bcf9e0b079985090238f8a3de0ed4f66b25e556bfffdf7f21206b46a93953dddbd0466dc6871c50a25266da98c42eede63e5fd81e8671f16623bca095c3d66d3f240201541f63e8bd84e074e33d315449e7232f32c520835820b1859d515d3698d12cdb32542df329d4f2258dfec6a6f378d550116248863e84fd92aca0c2636c4561687d869c7c9bdabf29d03d692ac3bb30138af0134241383a75ff91804620782941ef0096432ffcd3e9afbdc25542e938dc34e0982e57b3ce5be3bb10a0c49f314bb9b8690ce47d4d6cb22070d97cf8e29c67e2a74ee059d53ed008d0875936ba46490bb0d2ca8e8de19be19d08d09148467f32fa3e3a1ebd83b777a6198bab02e84c21ea9b8fa487c0c637a7c9fb6d8fd4c6942d057d38a6cc587259b58e9f9422e77b0e91b36cb4a6770beda54120238258136fc0d3a24cbc0d0c656786d247f2e697e8ed9faf5823191b5bd688fdda852ee7d79f6a1b45ea279ef4c5e3746340df13eb5b35c3453d47dd0e8e854c773b723353e3a7b89e5d569dd07cd4175465ccf80bf71c8ea947bafd3339581a03b1203c8f1094d330883af790cb10cfa9ad27ffe805a761a0a37a7086a66fa8c8bdacdc3b113e8c5ba69be6cbc76ca2ee659290a0b7335ebdb4e54e15a31246f712dc57cfebd69c90ae6904bf403c38b8a891585fe522055deade05bf9f75751df522383d5b11a17dea030a1d45b41b7cdf3d8bdea6dc2eb612467388cb0941eecc58a3ed9eeb623645ad1dd9c7fbf4d149ca89c734fbc591b7e961cdf69643108728c137c02ea458625aa607d5e74a643415f0e019b25a916d42f38f20144043f4fae7ab538e7c38d2208d158cf7f1c487b737fa2d93086a4b8650aafdac59859ab1f9cd9f21bf5e128e53c312384cc3a37b9f92f60c36644209c4b3f9c774cfc759b0192c17f481b483e684252e829d7bc28c0f51cde3548d7f832deb43cb80204e007c0be9d3c0c0491f5c7d8ab363ef74a134d743a7d15f4a9d0ba06655e1eeac540e6a39c65fddbb36af3bd1a3be1ee357438e9cba156559422d24b42f3cb5fdc2b0017ba40d92596a0366e0814bd5ab365aea581d4c160cecbf6237c3d8e4d4ea8c4eb03bc8f29362c42ce4c45380fc042675510cc4e17e792d06c23615b28f0e34f45304343d3ebda81a7df538aa6387c821e0c44737eba77c7c057ec6e294d55fc9e27a4af0937e3182ec9ea89556b1f60ee01065bcdad3d982f320aa5d00584e50216ab1d32e1b7264ef87c62305709205f0c2431f4d8a32cfde279ea29faf7ba0fb299f284c5197382d316a1d3dc193b8b04651bde11acee273637fb6a1e37ff3f8fb06d12455ace07b0ad6c830a40a5aee60d5f486c2a881c892f0c65d34e54107471ace6ae62826654f08326ccc9e43bd6195cf2136193a8c1c7272c77ab4106dd9af6bde1d91e4342d97234ba85d9be844cab3acd158067a651c662b6297a567c0f2b3056923bf4006979d617fef0d9da71324b3b00595e3fc9fd87450a92441f753505f94d0b4414f4037c59cc9e9da0e9423a502cff83e4ea5007dfd13a15c0815354956a62a132aa39979d78664575745d4a6ea61c15f1ddb3b7d94211e24c87af66ffaebd605499f65330ef0fb1434f40d129fceb33c49fc438ab6c0d3af75f7d9a7eda042f318e7612a1c131ae4cb642ad655ea5b8159e03d5e47d81645ebb04ae7832dad3da181b1a6790764c4a7bb0ce840ffe346651e2078ee3b1e18fb090c640af0dee2304ade36fc72d54825e74cf0b6f680d8011ceb5d037f48dc6dbf8cf8851404f0a381123a90e42b1185081a4149ea519d6b48be4b3d580b792ebe77cbd32bd9384b03ddadbac3464c11ac0e7156f7b156b7d49ed1e0e65ae56fdbc25c0a764acef57a651f2cc03b36f70a52d79abaa61ac0617b893f77fdeb9c0a7e50275c5b5db546f80427744c9855087fa9203aa5bb02a2474107ecb3d6325a8aa00b667e296ac232742d0a983f7b65ccb1781ee0853a82281575a1cb0848e561c25048b894640193697e3feeb49634d9f5365456ce17be63f1571746e536bf5839a91f4eefee2e741a93719949f9ea531336dd383430deb54f303dec0b51723bb1b805e4dba890ff523b7182a8b6e0dfa33cae693aff1bdd880f8032955bbb7992192500aaed4d72cc59e249ef9fea761378f03daad615a9adec5d7426362b39089d7486ce627afda1f88cbd714390b95b8ab6b3246ba3a162302703610fe97583a47312c3c148ad32bf32c186304389fdd71686dc2175df8e3b99c5bd9528722678ae05b409130b3b6912d0221a846db494a3f04b1e9e2b3b58de34d570d13d2d1ab912c7311fd75af51cd67691c1a7ecf06fa6469b245bf58d1e439a084e3070b9f3b7acd92b6d4f9251f4f45ce3c02a216b979f356143d9b592a6e67027aa1e006028754cf67bb4af93aae81d18918a6caed03dc1870af417d9fe2a703eba5ac744181ab7979233006f0feec1f19b196a01d697c823be69e6936bcdf9b278bb61042b08575b5a0256d960c8f1d62dbbd5fb37e07670be9568f7abd930127c6cc9894a75aa3925daf3e94d37b6898d722b56d23b0a9d3af932f7bc5d629b8e4646880986151817afc939e86aa43b27bb676b1ee15a8acf816a925d4228b0012364380382cfa8e5fd631ec59e8ca7110af36f2a0737cffed6985514c8277b0cac495f15651b4a431eb425d4bb70fcfe71d52874f98048bb7fc060bfcdbe2961a92b562cea4cf1d99253724a4fbfe7991eee6d30288be23604f41742b146d3ac5bb3dd4d4e424c5c2be3187a5118d368403175a431e084a3ff114426f448b07ae28e2c9bceec4581ab67d89ca80e4050193cbb3b27adc390d11699f32c0f5d1f530b8f0b1ecfb8445d2df55eb63655490cffdc1dcadda985ab54c5966aff4c389741ac6d86777030426cb50b20325dd2f6a70c1f24bcb495aedf26c97ca399e10b53d29e665daa700b235412059b3d713c0e090f9abeb1932d8fdf2269d47863bcd5d1f621370ef05be94ff114759b11bdb56a08a8f2032d9b5f9316adc1ba120be306efb36a40da4b6f968be5e7db59ff7104cfcbc2ad7cc88312dbc6ca7db766a68c6cbf6f3047a8087cb370878c3fe7713c88824f9e1f01fd0c6efbe4f6431aa2cb1eaa941252c7972402778b24971247a0efbbb6eaa5eeb0eddb53151399e634fefc4e40929cb10f53d3c9dc5763b375950f859098b424df5fde25919c392c9f6073f7016ab27296b7056e5f36e51da564440ca0d432089c6b7a3a1cf6f3323e4d8220f1167f40f78c5714868581f44caaef69c679384a3e84f4c1039d3f442a5b091808bc0e4cb4606f24ee2fc4ca62b3c61390938dc2ff0d76921c0f558013d36417ab58887f9e9e6cc1aaf144c96bcaa5322268fc5415a524d3daea7e6c96b73a13796112276f030b3ed76b487549223cddeeac750f6960e1c46f6e7bf2c0ad386e30da2654a3b7e0128d717408e1ca539fc4e5e4b2f1fd6d0dfe61d7164c5f640a90fbc0ddb14ddbb909fbcc3fb81a931f02267e619316963ea656ec8c3a8c6de8162b81bd191b1b5eba7affac0c6fddea311f324b5426fd47a32d289fb472d4a1e9c42b4a7444c8547d569d3b2a648e3bc30c25ae496b8bdec6598b26676ce4b8e4f7b80d4c715f1e8a8bdd1accbe3eb5a9944caba06b66567fdd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
