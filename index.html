<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b41bb0881983219267fd69879a79d18cda10113e0e13761eb3e69870a1ef352f6d73642d047be6a4630e7bdb24acf24f86d1e66775ad4ddd341b7cc36c28dc6931a990129867fa58fed5da5ea753ac4d406dd943784c793a67fff978b4ed0f954ed6ced2675c3b98e952b70072b14cf2388c5b672252abdff0a6bb02379df7e53259b5077b1f97aeef1050a03197d39752109724fd9e75a7208630ef9f6cd889804f8c07f1d6eb95458e27229678bbf055216b7bdaedd7dbe5944a26f29dd2b25378ef992ef3e4cbffdc2f2dea1a7a1988722a0445d46303a2dddb554f47127e380d03ca30f6bac51fad0ca58193d067bca211c525f0177c1845c8db58b88b97cc382f6820e693359609b6b61dab3a2ac9d0df1cd934a0299bf56401bd3ab44d1fccd4c9344bf5f4f6766c96968fa2317aa06dfb6d7760d19abe0f79e951f3f9bc9186810c2fb98ff0a2dc3cb650a3ec4dd574c90aaa8f0448a0add99e6ebcdca76322afcd6a565654599ae66402e2cb5a8e3281b9544d7b2d2eafc80d5d3f9b754d38e7fa6c535e7a732d160f196d3a4436479922487762dac4e17aebe4fe3d4945c5b8a34c3de236d0b2f18c5e7c8071ed5ab3d564af18e503b4a3b8a888c87fd6da27ed0279d37ffcfab25f48ad03349f94166e243fc207d0832e14e933d0714bbd0e59781eb24090f854ae97dd4450ecf7a7d2523834af2011743fc02dcc03d15aba6d9e7bc1a352e4e42feb6d9f850cbfa43ac5f63d999d114010979fc84adbd2ac0ffa24465bb9b76294e0811514c5c75e8c2af304bfa2201368a68125306c90202343bc736a808fbf0c758fd59a40fb641c6407ec0431a502b92bb3d617c83d746625ba19c4ed2376619bff5548a8921564b7727212a7db89f71ce977204d32d8d68d0bfc6559a6f995f0b2cf649e2b923c7d1a32f447ff8a084157750c762eab0ed400eb0de740326c701038af50a6fa44e07c6dc77dcc84f2095f50a0df9776b9928fb12d30e6909d01cde25a3fc55c3caebc0c8855f9f83568fb96e6e4e45ff4c2adcdfb6acb600788627c7b08e3946c6a0f07064e92f04af96514832241d1d180ea1eb3992742dc55846217f2da000d1b17696d9fdf37cb7a3e6c9fc2b720935d8ed9c74194f4ca038fe870e4bef1268f0dd5b3a7ecbc905cf9a6399211d1a2c20145fc3ccf1bf2f3b61296fdb22ccc33c0cc1e7451e0c5514272a136bae39bc82782a61406c504d3dadcd3554b64a304010e5b78d1d3bef6725b67fb908b8a813ad187b93f8cebf5bfdb8ce33bd065f184e5033c92f2f28c31564cc4732ac52cae5879ec40cf045180db1b96545ddfda0e33b85785376d7072a52acaf9535c9e2dc9a55936d75f780c13da300578edbb1214126de44ab2ec378b161f73c2c00c61344de2849999cc0e128885dae66c6c035c87e916e9db6ab30a26b4cec5c76b1681300cbb21a06b8bb83f90f918b55a6e5b0dd92464052300834ddfa70f6a2cd489db5ec6f0ac811d3d9937e64e661d4d0d97220bfad90e507badff893ab17d0cd043d5449af131f2f81a3e7f5c76a941efc3dd3fd9a322a1bb13316f39315244bba5235fcde5cf9512177f135392e4647ed6c8ff953b371a232bf532fd4a7986fc0115131a0767a36ff51e670266721b6fd2d859f43c6798d71dba348169988b5618e57b64aba5e2f436e21ef83e5af2a2f951e675c96871a639dccde71c8556147b8957e5060e31532bc456282cd42162cbcd9942ec7b406a7974b5ed2fb548e11d32dcdcc2e668b96bcebd76f984b9c312c9dee74014ffbc628501af7e5ff95ae31bc7ca9d02b9dc5977de7f2309f7b56c3d7f2e8fd1d72ed8a0f3bb542d9c0a20f12cc81f5b1d5306f0f33d90cc31da1a4dc296c910bee77fb93242915073ddaef94a1ccf2038fbc80b69b980a9f67bcae23f7a65804bec13e62c9f6e14ff4596d041067cfb22a8b8bf7519fc5823fcdfff351e458f8350be6edb9a337df94fd84694fd12902510051cdda84b35c4faa66460131612bfe3c000e7e98314bc85e9f21e0bc2c530c8920f7abc2c01caae8f8be946df998154366be6b495b658b568c30e7e9a26e5fc9bfda5d094480dc6651e3436fb79d9d2211dbf2920d2dc0cbbc05c79b011a88ab60ae7ca5ab4ddaf69ed499852e82f47d249065d4d6b0e43e618dd1dd897c899e3811b9e089b043e09e6e27eaf5deb079f50f0d3c32141caaf3eca4fd484e2de7feb80fcdfb813f1085b260d07d8b9a06934284be13ef24a64895215cd97bc97c924fb0d3129145c132ab1fd68fb38a8272d19f2906dccc6ede5c5d41ebeb7141071cc72e79f994ebf65b9aa0aa324044257e382694ad7499b7455e848ae44f41de66d139af4c4201410726006325717e6402e89001583ce14af01508aae6143138700d08592618f5aa7bab61e0fef4285387738582e21fd74b40f8d453e3f73cf632cac7c4430dc6490e21defdbd8b202910a521e1cc2cb729af50636f4cb0fc9638ac68af8aecd3b82bd7f633a25c00e2dba11a954495d6fa05bb4ddf014e913672a98f84d3148b9dfd09e262222db494966fdb3f5285d9c92aa96323072910bec174f406484edbffbc8c5c50f079bb7d2e317f61d183117cbaacd05e46a420f81f0b34234f6d0271c867cb19ad3b0d8ae415707387eb03256bcad1e7c9d882f01d7cadb3a7a3b1ace6ed22951a737e3f2fdeadb9639e7f7e96bf242793884f011be101fa202f769aa03a71e86d8af1eea69b81994df0ee0c35a20fe8b7e6c3fe594c38154588e0488710e214359800b1e17e309891c0bb91dc2c8674bf35f978fdb615420cdda7a104a46fe2e4ec9e3e6d4c93b5d8ec6e5f6641218532791da08ca5c777af80f1412b5c575f2401355f2d1413ec6c50de8330f96720c8a5122795692816e14db2ea6aba6879989e4e25a6e18a83224ca9c21c6b8542f42466c90cc8a620348ef345f4de56aaeb632e974c7253cf290465acdb99a88637f395b9a8dda69f78f052f5a57159211b7fd63d182b9506f6e60983adcde96e6095e1bd6374a22d229ba268e12eaf58b7eeb25ccfb6d43c4f0d43fb6f1b3de959b1025187f6c6e278f9725c0916893f43948bc48fb1d8a4f9cd6ac2f5c2ee95086a99a622803ca8d3493b52321c578fb046611cde418e59409677e1e784a696a2740f8bbb9c86ef63033e91735a0903d52993a9b809bf4f86e3db94b2e1784c8682e712bd58238ef940f11f3405606a49710ef0e4d41dbae904312afe3270089455041b2094680ac9a1514fc9830edaba4f1af65ebd3905b30f5e5df9576e0d3b73786324447c233e312f90b054eb56e41fd93920964a2fc840090e77317e8e51f71daa23bf5bdb3f639a955428f50929d9432c11ae25fa40bcb7aa65a796b8fc9e064fee5af5c7a8e882c17f65479daf7d600163dc70edc65dcf5a82acead0c29300162c37f3f06925e4168fc075b50333e0279d9605c062cef6761bcbc79edfa696c788bec82a4e874f763942ffb693b9a99eb9bb4b75a7a8cb55780ea8917980de5a584aee82938227b98c8d6d879bae309c42312ed8e48fe1ce264d3091bdbf771f11f37aaa8d59db2b4ad441fe0834a7f9b318aaa7e65d26d6da7fd11ba9c754551bdd1bed08e230f6627d5f3591f6f1570406d4e27f820dcf077f5d88a7148394b77edff5b69914c185a4935047dbec4753c1ba21eabe5d7c033ebb018156cb7a72c117046394b8415e643cfd949ddc2fc29462913c7bb3e5d5f993afd4a288dbaac14c2afc8cae2347190cc9172716b34ef65deaa9d2fb55b123373bfbf083a86f6d03f50e330f181cbbc044f2683fa8f72e4dab2e9e2e31250f6fbd303617022b969e65fcbe2a84f8ed0559d0abfc696d5b332e355e62e8fdc1b18a9a713a83197dab7d5a6f953ba3bea051797e0042da78329750c253d777a656f62db513cc80a53393cf368383d4e39dec4193bb24e4c2b1099dbc8a8f4f8341469135acde26ee6ed8a5bec7bc2dba161ca0ad0ce255d09b5b5489c2cd9da2e1b5c1abf5147138b9c57dd38bbe2fc3e8d5ae7e199522942c48e9dc9e57e105d768d93838a781d681e1acea14f5cd6d197d7e724cc61d97655c695d8478cc4c17a36bff9fb8d89e422a1e84de5f9a95af6f55bcc1079ec49e63c7a387d26e5256b0cdd625e7a6a747fb3e637b96256809e0f292dc37172c7d733397ba259d120b2732dc28e527c39d8e0c1ee6d9d1fa15cd9086a17f1095443ddb587332881fcd3db53f4bd78f401ef17be2ee658586b774387a193feadc611eb55b2b6c8950c76abb7d90cb3cb3d755bf0d70999c8d10d8cf3ed628add2d86eeacd25ef4325beb8ae4b178bb80f512746543aae2cbada3dad00503d0114526a89ca72e22d73369f554a6285d0e2d0486cecfaf7ba0216a367fc8751e0295ccd9957f28623f3cbdaa15f7647d68ff4197b8168a311b44084349aa17b10baea7fbb5246b5ac07b079ba06e5566646c584977e109381769cc34e87927933687bdb423729a28557f360597d4460444c9306f9101b02243eddc455d0fe730ee57108c5773a286956ddb76b111d157816e49af51a7e3906d6ff3af562a6a9148e05eb7b2c0559789425cb0cfd03b186cd434681ba5b4625388e0b11e7ca4a1b738b275366d3f032770d4ddbfdd2b835769e7d82090b3fee22c18a352cdf84ea3870de89436ac69f946ac0092e3c85ea3c9812891e96c0b4951a5bc55a4e30443aee6fcf3e2310a530f25efc02bb942bc1a71c74885f55481d42b22a20bd156459a63c708d479696e35e1e53a9f8cd2a36e5ee7d427964919ee38796e79329719a0fcee01ae97810b3d4624ca85188c58aa757b126f368331c8ab1f59f76327b2d8de75f1e47db7e66475cf883576a49153e4410db056a73dad16a084e2323ecae3230fe805311f08d7c0c3a3e9cc21608c84bde2c962cf39078c0c8e21314dd2b688c21a7f3463950e9246f7a7274c4a140f72c039c784cd8e7512dce926ac6813f753b26292f8e2afa37376a20f12601a97e9499074b42890845106701212f5ca610d74835aa8b9bb4897744bc0dc04c928cf976677849a1c41eb917d41f45d09803cf531b49e4aaef0f4336a449cd83b5f5c49f250bb91364f442313a09afada93f11c33fdd6f8a2f2f31f8bd04800cd42c1e392f3456a3d8ea4a6c1f39863e4a0067145255dd8161862e867d08be9c76d5456db19b493d6870fb3be4221b3983f52f04e27c93e4af47325a1c505ae580b9dc6c69cb7b94a02da12d6eb048293660541ada65b74aa45a15767636bdc766cbb903340510f6303e37c0ced891ea8f8f73784c48f77494e09a812a9d7458ed93b4d99ffd3bee3afa9dd0338866c3892b6dde669ab140810a02d7e58c7b34f416635a7521936f105754d167a8ba00b032f9cb9ee7cd25ec9e79593bf99960725c5d267ce0bfbbf1e3d9c08c16bb89d30e50cec0861e54bf7b3b7cfd281726f71c0aadd80ecc43c3f226dc6f88b2555e5c8f86ae2a131b9e2e2a403bceb6d80ba47e3c0c972d95c0f02afb3aae14788c593cd515176016ba0ea6ef3d421d5de11b2546a3f95e5f812fd8c9effbc90a8714e3be248540fcaaf3ce852517029dc5496a40762375fb9fe7eb69fba83da38e6ee8e082e7b65aeb4f1bc14a434e91c48abf7456f23a25b33577bdb38130b8fe05ecfcf37e444c8c5085a6aa13f1c101d22c26d5f586a74ea196c62cd808b37288c3022ebbe8ec2980ffeefd0a08dd7214bdfe01b7a6d8a49a2b1723901baac7e98590368aa4caa6402c93ae47c110c8dd62e74593fd3a06570192e02cdd8cc7c0caee079d0b03935334367f288e0d7519404720f03e5445282ffc6f6a5c1b12581deab22c7d829691b37520364b0a635ee77421f27f3698572ab1f8278b1c8174536c1b4a6527ff45fda95e5d0363458027dac15aa61df60124f0f7e4cd1233ab789c35e2e7762a800b73d85db26cd4e5fc7dd007b34c6179e1dd2f473d990cc839732ef3de05a63b75f8dbaca4eb5c83ad51f2c0735f8e19e4c7051f3242396350a127d4569af32344cc9078897512e328a62aeef190bf4c92114e4b58e6c717154b2c96e03b2ea990cab1bd979b49b2bb5566d3cb5b05266422ea96058813e50fdecf33b800f1f09c70a1ee9200df227bc7681f4d9175885e785857c0aa31da750fed64eac18d7abae1b59b3d04af205bb6f5a5b059553afe560c8dfab764eab503b727dbf75803f3428410e8028c898e8e8abab2d85ca7afbb758e68cd7c8bcba82c3bbc560a1207986bcdf50071d47b629a64547e71c9d57dbb3dca58679128b056ad987e1c8f43c3dfbbd829e17807c74bb4c9cc0e443f904e27a7eba646bf3f646ab4128cdde720ff81f30cf1520c75ab5a338d52a239a728c7ff2c533fe1d53f886622e9d3eeaa7bdea37c531c19e1156d472d8e73a4285d53676a472e3d3baec99793864c106f31c7398bfbd91b7a15f464837c09b3c5589382409478b2d41a8b713df0e6ea284612faf304d03d137d8f0707f501e4297c4af83dd6c45236a34bd10f3baddff33be9161929ea5232dec9b4c909b77fc4453b81cf43e2e2f18faff7ef21b4739687c790522d6ade9f3ec2627023a3378b3aa57360a7da16c1291ac30e906e70ca1ed8934dfe44c5870448871a6b669e614cada16217d5482a2d7bb6d0a456f1e837a5af50963861770d225c120ef34aa70203749402cbb9849a861b87d7d3b3eebf4db8636176ad525cb625e6c7662749038fd47c9bac81fa9f3c9aaff0a6efacab23d66eea041bf1254155b373c44f9d2234b54892a0a2c3f00b8b2c171ff3fc53db96e55ad1171c80ba6fe017a4e881832256279b6c6a1f4b77893752fdab7e53490a26e9c84f840dfa9a903c71ffcc3d309179935eb11bbed2af69bd5a414bf0c72fcd1c452ad0f1014116c5d88825731a58ef5158e8a625db7ea93a55f0481b8193a9e7539c03521bab73825b22dcb56831bfb8b058dda2943002a731b902f32169d9fe02cdbb7c4117678ce6af27f9858b8eab4a1e8ab5aa0378927bc078d845a92d4b10e936df23d7ec441e66aeb037b73ed96bc238c012a6401cfa9332c76c36951993c1b3bba6c5f2e7c011b4ce452634859a96cd0f7baf0db65bbf064c8616920be237d8f51dbf1ca520d8533e31c4c8cdf2b73ce5c019d226fe864b6382ae2e2ed509c2f86c74758ba6ec25b65f2d8fe933108180b164bcf4bd2e055f281ab90fa035e76125f1b1b1583ef433cc0fa6adb15fc3c99aeebf8612953f464384133ce1b7ff1321a760d8fc54f8b02230e341a9be1efb733653e0c7286b64524d5bd84fae24f06488dde07a1240589be19d88da6596ce08953bc05b76ef78cd96e1274f38785c6a6b873829f43a6db89a68e94cbb0c710320cbf588eaf81d669e7f0eb57a2077b8049aa881879b2648d55402f6564da39ae28072a63a2699ae0f3864839c273f4b06272b9424709261a3e10f2793534ae403d2f63dd3b9ca9a44d3020c4ad89e12f5bbfe2a4aa1454abf929f3ede51561a55c371c24b59ad05c7746caf06c936fc4692db4783db80097268cce38b55e801154245dc09e645a61e6c28c77ec6b96e6636a8277bbbd2a52d787f40198a884c461ea1ab99ebede28aea0a0afc079c324e606c9ed705904605fc64bcf5a53a49fd7a6a11943b06545c3e74842f064a6622f92e43c216559f14a020149bb96f8b390652c3072c146796a11da73948c3182fdf7bf33d94147d36011acd235ce5e26e6eee49da502f5bb0821fab9284f8b7b09f899867fbb0366d03839dcced9bc14a41d5370d6217f6df4de5d0e6fe673f38ec361b6e870a6bb7b2eda302cec640b3f28055672ebf23c2415cb0ad3f46c1b949fe024678fd1038981fa70c68ad5e89b668c9da0d966a114854589de1fa4f2efc2214762ffc05ce8623e4b0fbcb059603ee58bcbe005e49efc3de336873663fff97ee9db668a91858220e7013cd69b304ad1ebd1ea314cec6da03b574209c4ddb9f6548e6f67b707379e0863c3141251233dde6ef7141694bc76728e55f5e332ff56715b77476225326cf620bc356db7d37fc2ec84e9667871acece36d13a8b992f1173501868f8059e71c20ab09874d3ca8b7f06dd8efb74b7ae6803d79991e908152ddd4c8440d351748f2008db89f2e54015e917b706ad5625921a85599a67ce5e9601b92da49a4fa62c35a3c048ce8de363f73ba88a7c5f6ca76e3f4133a251d94d36c4b95379433410a4c69374ee54814b12880c6097e8467d605a3a982cce3b4e19d8024a9b055f0618939ad7dba1a7a541be67eb4ec9df0bfa8ba72f1830a754aad8850d72696104c3b77b3b650d62f5aecb68b904f0a45fd4a8cbc7ee301a543161f7c4b66b868e7ad3cc0b867c2c5b363c27a8f17c1481489bc7c9e7a61248e9e58c378d6bf33d74cfb7264b4b4f1f9ca25e0b4ba63987c8ba51f1d1092a52b3ffd34296de8c906b31d255cf40857af3ed5c426a57c9fd0d9903f5838fcb86af716ac18f9b4f4be3516e77c75bd01b19db3f8999400706d065433aff2524e6701b8d382b280119e876e29622f16e2ab647257e9e7ecb55b39a8ef415b59673555810a9cf308e7b979d7280328c3c6109d09bdbb72cf6a4d465a7963f380aae2e4cdba4df7dd94b999c9e8ba469968ac0530f1a68a4bb3b1fe088b19a8aa451ff813bc1c6ec44f00ddcbee7c71dc318021ad9e73fad239412b4504361c7b18d5658df6b9013d6b792f5e5299c21ea910eb40b7251219795152a11be2abe22ba9e6d8a7b75ae4a278902bc0b846059d9dbfe7c1631386553156eac4a352fa9c1ed1253636d1650c93f855301b2dd83f5528bf497ba260d81981dc02d80819ad55538503595670d5665f0903ef9793d32e602aa8460f95d2a39f36d2aa20a405939e91de1ca9e3cfa94181107e126226eafe1a363152e198a37223ae04d1d1221476ab033efcd63883dcecead5a516b6929e6d8c758098e3d347fe8fb600fcca39e14727d3c63f6c6a10d00f8098eb8ebcaf115ba9898908ce6ffe60fae70d8a785c8f26c1f1798a398d836a3ba4d414cf297b5e7a064fe600bf403038ccaa779477b5293fb814d3571d119a41f850d527c8737cf418f1a8f0b61ce1abb95cdccf2b72ccf1df5e1b3919474df4c1b8e5de380b3e654ba10a573fcbb974b7e12c88d553fbad4f19b7c874a43a6129193fc94c324d4b350fd63cd03e70e3f602fd797d8ab2263475e0e096a39c1d65f94df73f7dc6fba411eebe7926c15fcdaec5a39ae10a40b4bd63162cbb06e12d20f5df678484bb2cc8221ca67a3782e50a948051e97dead7fd77ff87f77413a5a77c81c1d464982c236e28c299d10fc98ff866246b6ddaf233c76943163b63264d75c6b1d68ea66f76d0a634b78816e358b8882607c7821504a280a533928dfb6105931fc20727dd0556cd317d0770a0ba107a99a1e5eaabf265c2d221d4aa862082d5b0f164f3264c965fc31bf7afec27c1b2ae5a06540bc1a051580a8af3cb15a108efc2c9d30a60ebe3a9d31e0590c896dc7533e1c8fd4f1dc5e3aa36cf5af147438119694fbd6e375bad063a4f91a0363dc755cc0fc9aeed3cf38f7bca6bb1ae3639b927eec534aaf8095fd6c7fb17398fef2d65bdda24cbca5eaef0a962968f1ca5a4b32133b4fc1f86c1977a3460f9fef3218cadba18c27d63066f69748112bd4384fe5ba3a9f2236d1a5a0d8607d5f92e20bad858f8511c199553df5b690f91b038c7fa0ac981aa1dc89877bcfa70878bcc5bb5392b993c4dfa4ef51bf9500445eb672ba0f6be0ae9c14fbf1d74227fa98d324be2f9fb4ccc1dd275f646d159a76ce2c74cf9d10af00f3913f41dde99b53e660069a6a6aec4598e0c66dbd9b4a98c459789b928fcc73f58a3a035b91f602a78dd867407784755a1462e9a68bb66bae49785d608c8fb2e0daad9ede5eb8e5037bae40cafbfb0f277cd8b84692e9514bda72bf9ba1724f769e2e9679f68aba93d9ceae915c166c6c128d72a6d7df97150293f0f0187529e7d307e731fc2bb237b57639963c0e07d767e302e84ba172b93438598f111da62090e99e488be57e7246b35735722726bdc4c7db1769778472d49ab30664a2c952d01debbd894c422e4b5355fadd209cc333c8e42c0a6f4f0a5ac5f0e944f2d66399d7297be4befea1b693994630bd611b1821d49d2d401de2d77e36492d8ca5d40db14c7571f85df69cf640e5581870ebac034e028ad97a152626547556395147140fe28d293428400da6d1d8a4adaefa7afba6e71516fccdb0dec38dc75e6b11cab6267ce3a552dcc78a05ad37fc3b62f98c453338433d1c09ee8429f73bfe8961ee684e1d1be45dea7358ca781d34dd4a52be5f2363b6bdb9101289c59085fc4e5fa1fe197097e97735e8a3ebc3b4128b28edb0b320114349b6c5acc83acf18c8b39a971b296014fc19c4a6f03ffc98fbeed7a6a38a135cd6e33924a738df3303ce42e1822c5bbccfba7283beb773347c26f19dd1a2380120751c8d53f8483a9943d1a59e12425f1987dc80b711d5dc3862c9caecb00acd1abce6dd9702b3dadc2309fde81481e4225981f2955a955ed1461ef07eb2cde13ad74c76c63296caf4a0d4a43f00f4bcc143679fee329e289aace481b74c6a0aab0818e0d2c9da8c9d69e4efb76281176dde9750e490b639c2e1447a0bf5f1b1833d3f5a834227c6895b458a4b9a61c34eb50b5f2e9340d013b03d5984fe5522a7d23bde6732d7234ceac4df1c9a54ed903e44437adb3cde673755d49aad713f2dad40178f60e38cb62815def95aec74a5ac00daecdb1e4ccaec4da6f5dd60e3e9b29aa2e98c1dbd61f677bfa1ca4d84226430aa13a244894de4c742527e38ff79b03409ed2f9581d4c9f368597bc15b9ba35e1edae40829d2e540b226fa39516e3abdf98346e79be2f4df1ef7a2eee358b92e607c9ce35219b4efec5b9185ee3769f0821062c4daec732b38312695fdc710202499ac090f98e80609ab8115a08616ca52f23258c531033ce64cc1422f8dd6880cbe6f29fbe8e498262902bf56c8561459df07ad015de2740ee943fbbf88d8c1635008562b4747c0fe3f866bcc2ee039db5fb2a64805c795f448f6ba336b29dc344481fbda43c50da8f23d627fb84b3da477ae6f75866166cdf7d1518f06a2e5ac05ef7df75f2a6721a6b77108e32b1865ed741ed0bbc17649171649521767fe7d36b436ff437247a0c437e7e5e55317eb6d5d0a47b66988f91afa65edc952671476a1bcba8f669357200ea0ecb94bd29100089483edaa11e19c16ca14a1c5226fb1807a9777779f59697663dcf852784da85e2b9a684d59d0c33d2877dfcb24188e8485dd224afd3f61d199cec15a9e0c68450e9d7d825fe8b339eac1569577f8228cc043ef9eb495e87f39506b1891bd4127f736e9b456d6e6d60e975b3bceb859b6698e21abdf229009c4da0ff00dd58a30813b56e6f9f77af270ddcc56dde0df5b07b49e439d0b696430a0cd712c06dcb56689a79c83fb7979e3fbb91931aa3b5a8da0cd00450590f1bc5a0ec637bac5d66ea1d3d5d46217f53be5e0c0492b019eb385d5e4ad3962eb727fed8bb4bfe5fd95792281712ed268c02269da2e97be372df169f28829b3bc8704d8e4258339db20a17ca8d99d46560eb4b1dca4dba5df304af8f12f6e99ed0e2ce536b3342a4981ab88f24edbfe4fb6ab46ecd260c46fe76cb4439d2a9b3944bcd92c67071e78859db229aef7f4b3a5f9a49754f07e7b0997a62481a6f86c109aa9a69c3c04f63dd978682489e1c0b701891b3b6004693846a1776ed10bab6df443535a88c7a77c3848350a4d36400be9cfe082f4f8befce770f783a8c82a97392e7a0aac91ab9d34cd9264da858e321416521d7e16d631245354a2e6366a1960775550f0f7176f2b02017fae178034721e6a2c4a1b8c3c65713a2d2851e89d6e4d71f973ec3d253513b14ace72dabdc0333b834b42789773b49a3e940b7dd80779dfbb7b570cae75ed2e29d495a18bf37fb8ca9f50d77ee85762e6e081cdbda24aad598eb243de3f935b1b29ba1ffe6845676f3c04746a1e9cdd8798c5289617a1cf67fe0898a046f90d75aa4b4f0be4b7debebd3604ce9256beebb2c30ca7860f102f89c28ade8be84a42ce338d3967382f900d66fd8d7a781cfa047bdbcbc31692415e46195f80badc33248ce3ebe5f1a22c0ebf7af0877cbd9002ab93c5c0d67232f46cca670056313039a7d05debac8241c5f356f6b2e6110def0339357ed69bc6a0503bca0832f626654d1fb70edc308117eae5a20dc08394877194482971464e8a6887c57248ef467c191611a485f53d7cf842eef2b497be43791a107b1af37851a00ed5d4b8de44d3cb39c51daad705010916cee3e2ed38028e7fdf3cd4eabd23bba51f75b2051d9fb15668dc95e59485edc83aea0eafb216d44345d5160372b8ead54df1c032b64ceb8938be5ea9810ec891830dd8b5c4b2587510c7556a6f32740c6444dd6269b6034715f3824243d4b22537515ca7b6e86fe0e7b3490f3696d93835736ed9f43a214eec8df938f5b07cff9c9df04a36b4beb226b28c157beb4a3c0740b9b64a123c412879c3dcd41f93c2db827f62b1dd7cb5f589cc993548b286e7fec9beb60d2f74ec992300bdc874bb4e780a78edf464303df8912afb9727f33d20cd3909748db8a52a56d35a47d943c077b1af82328b6f2b652aee67be9990e11c123baf1fe5ba6d3bda7f48949d889115cc0eb3d2eaa250b5b5630af01cb9402c813a8270b9f3ae03661fb7c752341daf1e870e90b85b7859be39344a06f2df50aeed48ed632e7206cb350e423c1f71bab6d9d2e60d887597f7c6b5bb9c66979cbefc763ad9cad362e50a382f5751fa68a2bec70ad6f1e01e3bebbf010f327ab204e1a31e82e218ddc0de3f1391992d8bef9d1b1f2bcff3fb4dfb33adb94eb155f42491393dd4fb24dd5f63064bb1b75ce1d6e2246be07c37f3d249f9dee70125a86b7aece48ec0c089fe73db4140054f40d854b33e80128d81b8c93dc02f59e00c444d4211c659201c0b93eb1bd562a43bb8f947571955059dbe8fdbcdb5cd5ebfb0d15e5bcc1cca2b0671daec528434ab863c070c0a087c127fa686b5ccbd46d6df5d21139eae644886519f668b91573601d29ca57d010c1cbfbe4be9c244f48b5bc1050593f4b452023e81064db6d0da16d8b50a21fac685b3176034f12f334ea0e5534e411424af33439013dc979a94982979796137ed4b75694b735a4d4cef9a70cf6e380b62c959b431206e99b605e2423df63e85fd306ddd87d45b33e2c0cca2295134b7f82a69b20d211121d54bb0e7268b368788e98d7e9fac2c4f604b5494cec6920506eee359a9d40de3d62c2cd37582a7e1ea4d851decbc185b77f30f2f58dbeee69acdc826664111458830366f3115a4ba3083efd50135862b831938c1f79ba005ed18cb9ff301d61f304991143e98996c4c31e19cb68bef1885c9978aab89d3009e63577d29c7715179e8872d12a31ea7b6eb5ddc5f99f7f538f0a5c08cab656a880ef125001d4b4597a6a7cba0c650497130a7901bab439f6409f484c1c01f11cd4d65cf375c169a375b975ab28ca189b4d49912721b6d5e9cbc20299bddea89371eba85d7316d2f87d7c7bc9e512410f15e0911a8d226e720b5f1941a69d380b66446a98c8bf0f07845db30c1f172d986ff142cca6983365a78a00bcf8fa817c65d6b8cb60afac01c68c08c72b32e73fec6032012220aa567bb4c12759e2c8d827d84404d4f2d1faa048895916998e59836db6285344088c6fa301901d63c42859dee6afc754f6cd13c4e22a1097be703b641a686640e0cde847878fdc2ff24923a35a2645be1c0de2dbb5fa11e48587f11cb75055e9a1eb9100de4bf6b828d2d6589c98b596ee1e0001dc85151523d29395f167daced35c7d7ef81b85e3a473f9a45335adb4eaaa30fe00bc8d0d449da932809ee25596535a7ed35e7bae53ecf17e30b2c99d413b7795880f1615e7789c077aaf0339647186f69ea7532252838cc98daad1052426483c00604a430ff2360843edc51490d7de1de3c666f32882b0de409996e167e128b25d515fa2361d47095c0cf412736d0b140f778aaecad32c644607119666da482d4ef8e66ef9ed92e1878139cfbcb717a0e6ac6acbbe667eaed64eec6c4864cd99f2e5137885c831aa304e6ddc1e8fa0554496a1de11521fb99ac5ced7f99c5afa4a2eb6be7f99cd0644af08e2af70c29aa211828788a87cadba0109946920d587cc99209722938ce3b71219995def257b21faff8ab072a1c4214eea1063475254f7b4406779e158ca1a47a1ff6a5db14379e9211dd57ef61fa00603ae7f28cdda9f8079ca1815550534b4d87c32472f862625a86b4fed36584fc362192080c060bc468903a4a4deedb69ff366b877f7069bbb4861998efa34842ef2411bb145e42a99e0c134c3c47404a130fb5c7e9cd9e71be33e3e183d5692c7ce2d8426e54a7a071f676205824237f09e2cac62fbb0da9d1a78592281a6d17f317e8c226b4e464744e2a61faa31ef30a99a845700bbc732282f54e4ea27de191d17bc7ad29b47e1a958ae46dc2878e8a647acffdc8f1f2cc7a730a7eee50cf962950a2293b04997f47bb58763b3cfd11c0d64c26f5388df4f1ac2d3abaf7a8dcc21ac7e6947b01a8bdfc92c923d1ac35015e5a7c7b397fb722ea57c73b466235d76c261778203d785c4615a8876e41d2a9c77f6648f83bf32fb9c7a0eb00e31e345f6948c59c00d3157fb11dc9a815a412c68da1d8e9d41b7adabc04188fe2b6bba372677da467c35a6651c6b9c88e71f772c9f4824a363bd0b8e4f9d839f6a15424fb0ea0f3ba4f293555c36de3bf8fb9d7ea400dd0b6a5488419a1eb2d314f5dee1900287b2193e053fbe968e86c2a3373245648c723db3484e538ff0b9848f1f269d869d2b50e8f85273b7e500f82e0d45d22c1e0cc501493537622ac9fc08afd7bd8fd2a0e64ddfc877d5834a41934ec8b24eff29986fc3fb0b390822644d81227180ed4e6edc594684510ea7a5e9ad0f3b07d59dcec91f3b31ed599cc5caf57c80e1d1f1201b730905e1a30b526afe6afba58c58b7f008158959f9cabf656d9fd7d2c65fc9c899444463c65cea3ed19fb013ec924904b94c657b9861d12ab52fdfe0c7ae6985010660e9aeb9be4cba73f26cdbdae6c2a25a4c051eea680e392604bafe422881552e547ce325f6a4e9c83b26c0481f9214ef5844a4729a47a31d3a5bd0c67703a44d5f4f2941c0c9ff30d47b339198f3c1e5a06cd953c1dc110eeef65119394028ed0f86932a4d29aafb94066848d8362a80cef251814e984e5f883bc828f8f408ab25e7274b4fb007cf3e832864341ea7a27c9057b50ab536647a105ccf6c20b2760cd0ee9ec432f11292192248160321e45243f73d8392c6e516b9aac8f40d563f0457347b33a863950daff995882cf3ad34c290cc3a4180a6d630229d7c5aa4f4a64e500a7fb7b782cdff0209be039601f4732e60f160df94aab6263f3e6698460f766d54e3ffdf3ccb64439adb88a7d69870ba5a1cb0d8573156cac747ee63421e23d957640a033626c85b08fda38dd390756911ccebbb281c7ff8b2e7f720b956e63d67aadb5b186ed46afb906ea408d9d3ff38349e0c2b66464ddfc16e9661c4fc10601140e8fa13dde6ac4be87dd4ad015e8f4a6d9f24a0599c107df98706cf6a6a962ff3661eb9672a8729430dabee0882286a46f14ad57165b90b2b14916747b750392232148ed3a289e5777852f96f042e66b06eebe26b16b73c079cf0a1fbdcfb3074252fc8e0ed817cb5b5ce59a2e46376ccc7f7d9264a1f8cc89594e806c24a381d8de81ef148181b30de346d31f5b8fa18271a3b5ac9857d5f3d92cba920c35858158277601d1e27687d5879b3f370573025b4a0fd369a1afd72e36d0fab899316cbd92e56c2b158d888affe67c10b40494d1e3f9263ce113b4cd3dc70948716ca33414291978a19a612b2281652fd2cb57f951630cb2f00d1348461bb6a7c06ee005e8665eb75622641e2a5f7cdb213f8877c5cdbd76dcbe430920d218bf74dd156694197cade036bc353ce6a8efb2cd9454866d8a0a755404b9360b7029f59336f43752aed3726ead93b94c117d35f576a5e547f8fbcaefd375d982d77b084615360a7c7b3977085e5683f9a33b72c598989316bdb1a943617e5fca378a9949c9f068446536892880a53e9d4dcf2b9cb1782fb94eb3bb95993586f729693f69477f5959932dbd08bdd2a7dfc7365b0256f7d9eb686004eb177967d828d205ed3ab1accbc4ad6f579a3feca7a567d7318a8de0bb03cae8f0d98e9b525362ce000dcb051e706286c1fdfd8c4b75d6c50650eae2d11df965089624817c8025052e5968b199d1bbd1942df78cc1dedba84f0913a707451c25824fc232f6061005d055e5237f3c0f93acd19040250ac4aeb10bd4a4cdd8a056557cd88e6f9149f7d2a0836185d9df7df5f015066f7264738aacd2ecef5e476da0416f3e1a600c9aee271ace921f451f1c1d93456d8d7e6ff380ad72a003545532f8c84473499b5a1bbde02ae43c53bc2fbadc5a9f5e20d21e282778b4ec947caa77fc66336b8c3adecf4f58378badd3ac74bea6cff31b725f88acd8177f051e0f9a416cee5ebd039ab4d576300ef12bd226a513f455cae44d3938201c8236ee294bdf8ed0b7aeab9f7750f6db2c2d58ac34ac16f39d59fb8cc94754c7aaadd9d2430f16cf040bd2b2d58fb129ae4336e14e923d04ab1386de045bffd076992f4ce0b19d1369988814e0486551430a8a016b61eb4c6fd91bbdf2bed48023e11722f0cc7fda4f94a67cdc5153f7f838fa492eb73798db630674944717402cbcdf3385cd193d19bf3aeeea7c50d13a249ba8a76520b589c47a2306c5ec78683832182525ab9ccfe0d75529a6d55c921c1bb6f508b06cfede48455b8a2ef32e99035247c205d15e190cbe0f1c76503c9b635f4fc65c6e25b6051eefff2f5b5458b90435e0300852e0e69adcd08757f1b449819759b283c94b5554e4368316a0b320840128c078fd831bc0cb352e60de099c0fca77d1da878790fa41c9926e2860243bd97a082fd35aa898be0df8e577ffcd451337a40b5b4c806d6e64cb888b8170d9729e31af2455dd55e938dc108a3d52de4677e47f651f8d60e948cf0939fa4ca2024d08ac1acffbd23e87fdf2579f3eebe3762526f3d5dba77f4e75e33c1137e6b60651f29560fdefc73fcc257fc92fd662b5f3de6bd9c83ce09ed162d5211157ea9cb24d7327623b1f7aeaa0d416b64647fa98137cfd23c6f68bd5bf6b3002a9a93f09e3179e6eae3422667300ef5e53db6e4bf2967b3a4a40d25e74ee615b956d69ae22c60800cf779ac04ff73feace6dbd18a636fad160540f99eb5a03e3bef9aa6a41b79b9b296e5e3d5cd4629e3ddda2715c262b88a323cf8a5e9710d4993c4baf24ed5e637f40bcbe04be5a7e361cfe223ffabf79680f40fd556acf2a7baa8a87a852c057d6b75a0b13cb1d9bbc9a94ccf9e089ab222f1b344a2f1fa197ba066564ef128b1eab40dba46313129b70434c8bc16310b975b0cfb6096cfd90db7380ebf506abd20ccbd4ff5c455d41c9e17945eb311f8a485d4571595c51c65bb2b7592842cdb4557158cb0e2304303cdd5f4f17b2976bbcf30356eb36e61fe34cbac13502626bb0591f40b578a6e151ccfeb93f1650656c443d26821f1d340ec8b40d3144355e53a8b1e0b33eed0c37d59c12bd9709c55154f259d1f3da6af5df26c440e5fa78fafec47b3cbf4b864f8880950d1e8fec4f30457e17732fa8a6a7d656e6f28a9e313e86bfeb8350fc2266cf8528f88437f6d31386f05f05b27af5cd4cbe8e991ae1979d474fdaf8f8e1f9deaab06db1f0eaf6a378dd637b8e96c41249b85dc0395a11ed0444098459c83695556fe114b5764cf08bfc3beec32c7575ec4d3f3bf37bf4372dc92454c8e1b812b0618b4091a187c23daea9e493a78fa466a7b3fc0be93651c13b9c7f81a5cc99b84b68ad9464f45cfeaef58b127bcffc6768b89d740633f479e6a084b93f94c73fd3a44290631e1ba0deb65ae33bb15022c3c83710e7c09e5191ec4171fd719f520cd230f6646d4a748760352b59e7316cbf7357a058e69a538376e4d64286be7f154f6daa58c9c5cab3c6112877385c1e0dd25c774597a41c6be22bf4fc8328366df4e33ea3363930b64f2a3a2f484958429e88fe679a8121fbef6f3bbfe35c79889a528c110119a5fc895aa3168bb3236eb7ce4c944e30e75322e44b6de10ed724ece8ccde1f5441f1babce53097e8f2434658f01370fe20923fb6d2acc7398b9823981f9a970361bcfc36d5a9ec6ca24e8619eb525e80e1b5d6485edfa22471aec2fdca5703dc7c165b70c92085c85471bd928e5619222f80ca3868c7e7d6bb0caa47f2994264fed5e1fe08a43b1a82f8b64d32347952d7a631b17d338dee1eb47916f6251d1507192b7766c4befb75a4ac737e060ef03d4b6d81c94eb77687c60b5c9ba55d053ee1f9a5c6f0241a0a26ee513d40d2e38327893890ea4f8afb1b18ecb9d1dc885d57ee4801905272716c3ffbf2c5319a208182eff656912b7ae352e8340f2c61464d18a49686f4a6fb53195c9869adf49aab35c051447f67a1c20c547c4242239aa58fcf3e05facc88cca4d682105771ad87da0c0cde0e1efae7612a8a5e7fa368de6de9ab0befd08359c3ab8d8eb8ee8b929b2628dce11f83bcd106860d9e650a2d4c160b3a4613ebd10c75aaaac29a411da29015870d344742329f529422d2eecde7babea66d7683dd4010f403ae0892c75850f867bb1cc05cec3054d228592c41b647d6bd11dec7200513df2b88304208685edd9363a4016d38683595ba4160db7f1a4cfb16ee2081127eba03254ee907fb832bff1d6ec3ba04030bf9f5b4deaf45290b2ef4cf659ee1a81eabcf5537c18ad577b563a83dab84b98890cac228b15c9f0aef0b30b37c956128b633dfcb9843271a815b035b80393dd7cef5565d074734f26bd7769a0ec0dd3d7fa77575301af2fa7cef1ce299313ec34a3fb95d98c9d2a6b55d2bb693187fd8e1de45baf77c4d19955a71dba71781b78f93dd3ba79ea57ea4434cd2525c86c98b9452cc838b8ea479d304723dc29d3f83ab42ea82aed67f90b74f5652d37cf04b04c13a73702989f49972973125bdb4bb0873bd2dc19192569c7f2a4e681d6de26d6a01279f111830e6d0bfb107090fc6a63cc02ab829eeaae651f4b8cbcbf9fc5a5fbd8af42be7a46df862b4403361a4ad5eeacca03950eb63e76c0d69591446d331ebf32254c02d1da829a5a2e4db59f1af0b8da8bb6524c102af5c6b252043ad77e764ec3609f237c5c67c8f7ec1eab7b677ece127d38e5b6247b602fbe0f47b40f041a27a1d3d8999b0608848f5f3c18f237861c8fc9cae3f1dcc187ce132950b5e435eafacbaca3e06924bf54665e9a3c8b687c3078cce245c1a04eb9f8562c48940803f75e4a00073ea0dda21be993707ca6b018f08f419e806328e6612c26c04797618789f5c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
