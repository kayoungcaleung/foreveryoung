<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta name="robots" content="noindex">
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcb125311a44db08fd4ae034fd6bc2d6f9b5ceebf9426821efe79db4aa8470027080fe7f85c08dbca6516a9dd5844599aa561ac2569e607bb131fbe72cae9823c1163eaf01d08606cfcdb47fe4b34949a8cdb79677e7379cbbcd21eac8a5512826be4b2cb0070460ef23bc3ca0b1e4c7f973bc83cd3ba1de12a71a05348bf27eae6ce8fb84e5139f5af913e1e26ecac6d6828fd816e87f6154f1373e7226c05336dd8922db77b05279203e8a143a13c1a736e4de953dd48c02cb302cb564dc942453992d7f6b9054b157d35bd0a5258e5c5bcbc032db3ea86c9edeab11ddb2cba4d8441878edc8015b3a830a57a374b2c9cb26b88bd99f22cd685fa75d4714127692d4f6343d0c842e6efa95b4cb91caff1373677b6f390ef37bacf0e7e914fed59f83b4dfe8462d34ae09bd22bcc0ad0685fce8fd27167d9afe814a0a3ae0a9a17ddfb38ba84e7c805b7ab8512a339c7822973d1db93c8652694fca567e8cc562c802e2207fa28e4b091896ae11460c4489d9a5b0126e34d886b2ca062bc7d7182af4f899f5eba145bd28090608f466ced17e73c91b3915383603045a74d169261ae7015959f3b8f12a5b036dc42712608b7d6497886e9af5e6856a1a9b93255a48d6864b53f6f83322fd46c8cee0a5b02c760b37726a4652bbb3de6ebdec5e289bb79e7f5a4ee83bb2fe4337088cc496ca86a9a53af22d01356cebd117550fdbb802240c5725f7be5a44c3ad39bb6e0ee556229ed9204f2b787c1cde0e938e11f45e7eef789b4399cb1ea1b2e7e7ce08438fc5af6a79f2b801712699f6bcc98563baa73d982db6a4e036681578c3d7e07c04fa7285613d34ec91baae8ea993cbf623f2c7a25ecc6f8ffb0522afbb40067b37154263d1449d672ad02217e0d73d9b0b4f5456f98229ee0788487e6879543356e6a5ad26488d012288126f57c478ee23906a07fa75d3babc582d1fec9f8b7608212a34ef7a243f20f001f596a56460990d5cf392791ce6e77a23ee6deca011e335a919fab5f374744dffc3c73e8a826522683e80188e6ecf9b02f52785f6be9aa50678253385625790cf9d781b32756d37b714a82bff0ed279ed7618ffbbbaece5834bb6c90dd067516864e68d388eec79d10f1db55cf2c056346a55c2018fda4173a6b8cdab4dfe4e42dd1e6e1bd81f5889b7928d410cd4e9d0a39079020dca0b706081b0f8dff87a37c8778d61795b3377180f751b976f273a55f054d2b8b1d74188009bdbcaf76e0e40cc537886060d175c08547c03dd3579e70b6486b5991fee85509515110dfc2c89201aa663420a3a12e6c71f8c86167280a9cc2b199023488e30e8b753287c2b4a29053b98dedf95b9e9ffb97067609e765fb0ba240d75c20af14eb855f85e4fc2cd26a8147dc6b1bdad914f59cf6c6c4373a129f7a8b144b81768871f2af33c732c87c994e7145cd053b497a34c11a342c9eea3876e214a5bd68037f72e9ff2837f67e97b371228bfb2979238eb7340a13095ca9d0581a2230ca4ef5ccf98752e150fbb0c29f699c778d220a2562acdaabc82ad85e6356ebbb49fcf5ce7a9931c30a7b7de46a3c63e75d9004afe29a26595af1c34cf12b1222b02ad4ad0c8d8b23d1bfd3f71aa6a95af7988dfcd2e97de47c2626b707c00b774a1b88d8d1828b41749eea2717340f5c92fff5ccfcdedfd84b4260409d2a73637393590ea06b2da442115693986c7a17571b936e4e4da1bf1aa5ecdce5a139a8ec6474217ec6eaf64b5d550a930361dd8a75b9fe37dac19b23d9dcba096c08c7a70c58550c0ae367ee93c5542266cf2a2ea200045d047880166640d8518dc04ce9fae623724fe944d31791d0d2cfce9932202337439d1432428d37e6cbdf1cd87145776685b1a98b6e25cc9eeeb20e19e3e89821940e31dcd3bd8110ff969c6bafc28a78025601ca740cf5bc5ec04e321ce2550503cb2c15e4b83ad7de30119bf6e2aea8d80cc0a92b23d828e36d7c1234c44251cef6c5b6327004419d5d05223a7a576e068750a05cb69a179061bf6a7f3c2f961ccdf6d1b6846a4d7a30c5270d0ce34bcd74ae4cc64898270cc81f02df6dee1d8e2850ff341c4960233ec32be8b7b23fa63739da8dc81d0cf048b1a2d9e28d4a3bcb1c3470d7f2ab989f66f28e5896fec75929ba2831738486020cbf609d9e2d7647430d4cb5ab582d686d769b3b19a09ed9e0193fdfad6b5fdd8822747843b990673d275f12f4957224bf801198a61d217d588a78b2287dc8106dd346dd6674136a481f859d24eaafb3330a7102e5397bba675d20ece764e877bc872366aa8386f4295be8bf6c6ca49ea11b56dded396c983d9d3312e866128f198adf35c915d5e1f6a9179984acb5e5ece6762f0c5502a8d4651ee60bf5ef6920a53d7caf58e9a46eeb45a802cc6ac3e8b30e119410246706af2b595eaf4cdf4e2027194716d51e4519c35fbc582c5c6b56065d0c55cdeef26a760bfea5cc21da094d465455cb07755e19e4418878ffd3c2df3b95c0f840e2b1f0777fddf730858359688f8800154186a44730313c0742a8331f6b3fe122eb1a97ee948abadf31d06049d4a6917fff764f56962197d9426c4e408a086ea08dfe2706ae06475d2a0e9e7cc3dccf1f8a21c8266c1105d28e6f80bfb4094bc67340a9d763a527cde8131dbdfd2e640aedd6e4a94eb09f5218926a89443231f2208e5a8739cb16a57fec21889c481164be538a9cfa7edff6036ef064f908765443816458041dbd78f7933c2fe4c597e06c5e9a67f6685aa53ffb8f45c3a1c979238343e962dc5737913e4380f3b7477d011ead7b56f2ac2851a031db0a117e2e94dc6f65dccc60932e770fe79592357e284f8d8ecad9db994a0ac4a674c391468874ec343aca9ff80834a18467aa36748bef098ae232199fb03367615ebc779e4f5ae730e11ea6bcaea796620bbb25c2a8226361be065508f4e186fe76cfe1a44939d7b36f4e8ee6267eccc8da4b1df6a27bc9dc4e9487d362c60e961720700393bb4109b873d0a70614c40f89b4dc1037c379ff7b463c21647aac093983cbd4d51748b0279c2f367480abc42c15c97971f0939c1581de12056149c3095f23da65acc4f7f9e1917ffd94eb806e10476516c7c37f10c0ead07ca3f1b9400856bf683b3a83967d5be766bca53befd935d490e655e9ad601dae1ae6a140800a00c81c8e9d8bdacbd0d704180cc0e10233d5625a1aea9278fffa6701fa434e666063499512afee1f7dcad0a3f68824e868a55094afb3572bc04102666cc6505396faff2c77cfb74eea2d0afdbbfee2457015c774bb290d2c6175dec59a2ed5549b58166ec53ca3f98c23efd26014028098b340376ac19efea0474b5429656ed6b25e5fb978ddbe7c7e4c3ed0f777db8bc4ee6b9070c07042fe706b977d40eb9f6adff429d785188b3358c842704ca4532c2a7c96a536c9ce4c0674a70e5c1d1931c19496d91ef3afe14c2ac22c73e38f18535b0e01d7c68b3c316875dc482dc56193ce6670bd1e2e77d31631532167c200f95c6e168413ac67de502680f2f90011d76a12e3ef380395381e8310570dd75c76a794823a2a143e8d4e8ec3d0f2883dcffc294217f1fb2df52e29fe70b1d9ff445fef98ea13c9d20d2f396b4833d1d373831c1582f85a468532e765518102ff906a80e7cf89db0b4a4a7a3346c3fd88d85cecedd874cb3b26447c5fa7cf5c5d41a378081c691a11db326edc862ad932788d21e1e195bd748079cc44e0f8a02bde3ff5caa9ea8844b65416ac985603316f47e7b5b42710541b39c9b54d3dcbae909c14339f803defaab271b076c5c264b720297ec44be019bdbb33eda2555e5225706cf3c245281502192db46ccef1351d447e79b0bef9c4bc536795f44033eb53bcf18d9e75fa73c01458325b426241b4d59e9946e91bc345818727b6e8775e1d144ce1f7617e7ea8ff3048309552edb1be22e0b77de2d50d94693f339d3381142fc3f8bc091e5f8041d1aba5ae5d94437a574c382aa64b7c44d46da83c388daf10b8f998f5ea3e69d20140849770e21c4c288a25b85b7d3767cf853eae2dbbb58b0309b15ad9ea22c4008632dbc51d3e1528bae3dfab06921dcd70164f16b9cf1705b20ac075f8c2cd684d94da4530933d1d89dd5dccb2edfb8217c382815677367bed9e94fb72264b6b4c4b49ef31f9e57511366a488883465b8a04180fa9b9ff51cf8b031d63fd12e8aa0aa3df710eab61c67485f63cb78b6c0ad53bde0c691dca39c2c11dc3cbeaef5297f95a8ad509a91ea06dcbed04d07cad99ae94ea89342dbfb70414a5e84dc2b3b954379770195f48815251151396cc41134fa831619f3f5bc51e9d767f2954111523838bf5f8d4bdfa0f078e7353fae36391b4d9376f755ba4143b34b2bb6bfdb17e325c29079cbc53804880721371fa35b1901e844b37580b900ec566204ddd5ba28619f2d214f11e930448135fb2a52840a50d9ed63364ceba1193875db9b0fa457ec42351aa564598c16738bd15a708158a18f16506cb04316a46642e07b4bb34a4b2a253acda511eda38f84d7e361db6d13ef73d96f9735622dd0ac6948570dae580ee60d1b38d9c603bf486bfc90408eaef97ac3b29a406613e17e2230c3bfe8840ef039e6c11f846d51e8d73acaa0fefec0ddbf51b9948478e78da8e73a89243c78d2115f4dc19eea2e36ad0210682e635507f77a2feb26f9a6e21283dda2680540b6d0a65cfae33c0331c7bb32b8ace1b877af9e53009a7643923b76029210279c306356d0b2fdbf73cef059b07067f9324d016a03b4f41fa70764327a02dd0de82ac4ccfa40fd99e7b0e9defa71b49fd62302b85755e0aec4653fb19ffb9d7dd6fb17198ec31bd840654ddc1e674984b85e3f068716886c9efa535a188e93fe951268325fb66da25bafb47aa9d890aa6676490011f810fb66b65c67c63ed157ccfb55d9bdf3b361ad07b1409a72791acd6e87ad8295744a7474f04653177e759ee871ee29f910f1bec930ba05393cd3922bf8dc289cd5bc53ff864a407edd3478ab66384203383a234466e5b778d12338c7c61f7da0441eb411b3222178bb30993ccd465c6496892b548ab464678a3aefe9d3e807427d41e3c9d2ea740be72669841a8dd7fdbe18492b2fa768b2a1d3cef461c721593b4e49715292b86f101522a4f0b3f122f1215e60d06ac030fa62874c27ca5de1993926778ac61cece5f505f35adbbca7459e2c2c90f1d81ad14324d43e6eea41bc0a52258c5db0f5fba097280fc893d396d713a852f259a9e08ae2f0cc58ec92aca6696eb4e49ac05b1da32d286fff080bc5ffa1ed1d53aae456be5d041bc5c5e43c1793e403cd2fc69da730abdae32e7eea4d48898a34c111d4d4cc4c46fc9a0af597657faed649bf2f21b8a4ce42ad5093f7d8fb4f85987da7e528f66214601283d8fedd090604c6b9bb10a53b6291f86d79835c9c4cb183e206c75941673ebf1c40768acd6da2f8d828ac76a18afbaf0c0750b9a7b1e0b90b89885a5557c6ae104976bc0d5ef9afaf2d08220f61ecac335b004349fde4e68822f85bb2494204ffb2b1bbcd58280f6820f6f82ab4449aab885108e6d9663bb6c4dcae09ade9c2f7bebbf9aa77395c6332ae05ca143ad9796842efc7f5b94e25b33e2312308118224ee1e600b7f74fe0539e9fc43debef78ca63986b3cf150a7c3afe8fc0ac65780d155f795a8389213b9808d008b55245f313e2b811e35ec4f27fcb59adff720e8bcf88027252527dc3e63b7f5e7633a40dda51b5b96f733994a71bbddfcb9c6212523f50ef75f68e9390fa6f87a60b9e9be65e7d1def0711e4c31632aa113294ce1be45ef99f483a80a21160b5b7e11f05e8188ab865341bcdd17b17f2e5cf6f15ee9a5e2eb588d7e65b729ab93aee83e2dcd32611f76e5882f20ba2916273681405637af61ef8d6f8d53d75d35f2d9e8cdab9badc9e10fa53ddf653ad1b9771f4c152b90faa9929531e63647ed0d2a1dfb80c263a6f28060b75c554adad22c69b18e081f548214e96f873ed27e9600c80800f9ab0661c2b7fb1a9fbe114b94d7301c627c3efa22b9144683945b6ec87f33b583e03820519bf850b8a339d1c306bf7cf39ce51f444588d03bd29e7892ac08b8b76ce04ccbbd86ddad3e95e54974cc6d162976d79057200144ee865ba8c02ad04f3e5077bfcc0d1983b78ed3f5c3d95edff7a1ffe311b0fc85895d85c1b4b2cf07f995901130b44c01c03ecbfdd3a9468b22097247f5b4d0c0188922e0718d17f04fda138db3862420a59644329d8177636a7e4ea6e886c3848d24439dabe711c08a7f9770cc36eb5d31b3ce651bf98e089ac2515d43bc1188449e10a9bdf78b8e4b199c2ad1367c83c3944d23e8005d40bf6504af945e2a56a52e97408da777e49d0362497e94ee20648342084b95c1bfc9dc73165b724881c5f9332aedf4a0b8dff46bb26dd56ce7d924d2443fb5b03f7e2c271678358beee46074fd3153d902e294d20b034c9500c9ba1c847c2a1e2d9464569d64156d56d8a9a38a32c8e908a98e8e30e60abbc9971c5a86631f689b618dafe75bd19f72a6fd19327562e39337c35f24980ad36b2e59360d546b2817d2e110a5e195da3dd61d24c8ae9bb32ba696652105b0edf7e689474f36fd7ee6ddb4f7771729211fdb94df557fc98c6114631ee9bc0cbe2660fd7b2b0f383f979f8d75a65a5004619a9e99df68810bff2affdec4a08c3438a95598aeb95680c171e7623c29587639b22f807e993ec3c3fbd8719dd388961b0301a27b024e8d8b00e8c006ef0f31e0372d86052b2e77ccbff9532c8fbf3c0feab05b51e50861e368355ee71278420d013b61c093dc7de529c81393bb402ed3ec7f881b8405deb3963ed78a5a9a3c7cd7aa2f6f827ea8b4cc2573c77d2cbcb9640ca5d29b70d491953e4940fb7b4881a4ee5f5843ff9508a3e4eaf0d42a766bd22d53f0466ebe1a2eacfa9f1e78b536e2a4b7cba440a6c2f60ab88b226a422565cf391e9ed1f23297ee4d4a5c49720ae191ef3c125d64255cf6772d322ad302fc7312cb02f0b161edae123be1ad9b5c9f51550a73f321ea79344634c00630c345864230cd332c5c1333acaf625f7e562528bd2ff52998a93a86cdea4cd9f69185a45d4fd9104bec971e92a5080f63dad1499a8a19cb3265f0709cf39c68f6ea661f609f083f88739224c9c96f01643cb960f237107e84602115bd20afe99ff88dc2714417222fac4e83b26c12a23d829fb5365d419e5605fac1098c1a4f600cb0b1843d11317056664f6b0bbc1256f4e25f4a2bfdcba208e517c4a92696f11d4d468bec0042a742585ee784fda660259c57df8935a21025c6eec6df97261b01fb9e44e91d10fd0e19c4878eb4b3964817dfa4aaad41db85cde7df0da9566729f34f5ae4bbf0bb03a917023fe795e05d6838944b5d87fe7adecf6e3cb059fd4dd454a4671ad4883c1ab763159f421f57caa5cdef9ad611de8a25b1ec5fe22c25fc6614c828343822d990ff904f9b7cc896a1a03acca4f408cc07c605d1a66dac5214a4339625629e204fdaaa8c944f4dd10dbfea29798f99a4d56c09920d2a9a0196d47b0b1cf61427138b867c4a02b598724fd7a736fdf45083be5cf7bf55f1f3eb302b9106356192e6fa7e15a6d88d996ba407c454a075e95676f1fce759e3dfd88bcb5abbf79b45f2cf71841cb5ce564bf73c36abbc7b0864fa441a9a166fb10b7302f380af15fb170f3f87e7a371feeffdcb5f9f7922fa09fa95a9c88e7733cea15f5924214a48a6d8cc4c097b80ecf32e7cba0785fcbb80d9517c51be2c7322942f76c9b94109c4b05839443fa8656ecb1e43f00ffdcac21727a45dfdbbd70c886e75fddbc9d388b011b45562df7dae63728e5e36d57b83af4512853da4cf42424c241c475ac53fb0768e1f6cb13e331cac493ea97ea3054cb4220b4f2c1fbc4d5d1107f447df8f95ddd02d6aeb9b11b3bf857f20a4572532fadb32467f3eb1d579afd8be73cef158233ac80a86e7de5747a690a956195f8d355021dec2346c631712290b7d626d83edbfc29c0a55fa63753d809827f0de51aa6fe68e30d7c93db72f4e8f8ec6733031546c49865564cfc8542d984b8b2d1aa4207b8142a14fc8c77ddfc13bc1fdf5e848289b7741edb50576c774248d8755eb2494305ca2a55c0d1f2fd85b2d094ec439940ef0ce5a35359e45964ef847297fbd3acdbf2f3f0f9f7cdad682351ce196749935080a2bf6d395d23489178b814a813a982a318ccbcb539afcb7615a40f675d257cbcddcbdbaddc7b4e7441002e4f7362c479cb9aa8fcf25640555787bddfc2f42d9d18f727e2dad685e5aa2ee3d0a6762d89f7c0f9bfb316b7e65f9189aa1d66555d82b955a717f65651d7854b3d0f85ed73e47d26a1e8cb118d124009f9005ad49823d4b6dfaf08997dbca729f892e4c1f4a5b4a0b264e60ee116ed2c0ead06aaf5b005f1c9388cdc010370a148a1a2afcdd8f27d8ccc0d12761bf2ce62fcea0d3ace0b21f2485291f06c9992ef9f11d2d9f3df934e8dc75cbf3e4984afeb215f54a64483373566d8553c10fde74e9693f1384ff6f6579444be8541f1e61a377a7cdc81025a8bd2b060c060029a4b8b03cef23a21fbf8db3608eb729f67bb4b29750ea4671913afd4e3752a46001a4fbfce05ec9346e9534a9774299bc66b3ba749716756d2894558aa17a6f70bdb30948d23a52d275471c76a931a1ecf3d8fa502443eae087aa740bd88b841e0e1dbcb8bc61c2004a214bf9a67010a254d1ffd89d8a5ac450b76c737122f4908fa9ae4c22b8c798d9a23d942a3d8d6c2b096ff2d7541e28c1a87b1c3b605df8cc3616115d762b1f133661da76d879a0c11e344efb3d59a0ec24f1a527961056a409f4d8c93eef6e88835ef394b3c349acfe204874b07843198ac8c7d6ed2addbdc5b72821c82e457ec5867b94adb168c8787f7633b9251cada1d35b7c97601853fd14b38ade314dacd90acb901a69f26b372103a31ae2b4e9a6d0bcb47aac3ef8e171317139ccad9ad8082c0b5e49ba4e6c8894c8585d71d8badd472e0622ca8923056b6f3f45048e821278398119d8318d9472e6f78369743a7814c9eff9a87b57b74dc3ca055f670738bcceea853164bc2d74d25e2b5f1dc886509ce5b357d8aae702a67b0711a20171257887a57f5bcbcbdda146c8cb1f3e6867cbb37bc84131887e3c4a151d5b833ae331e4f5403040efce96632d23168a37e17133c661b5d950ce8233f24347518b6afff8b56c585f7ff96bff72020560dc239a2fd3bad05677e3c5ea5dc61443cf713b7348f79508d054b0258fce83f7cd02dd07b2f11019ed0df44f5a891d99d1ee3bf9d2d79f9fa66319b3e0852bbc06a78808d446efb228896808aca66741889714c220bb6a690a87facc3ad04b7cad4de7f733e726128a43bfcab64c358e018190cb3df469a84c004fee984166000748abefeb2aa9b3d360514d00a1c6362504201cab69df15e0e7cfa1cdd5f0c7ed06692c937919f9a4318f19d7787988ca7c74763d9ae2da8c696b60ffdb5acaf70c4f430d08e78ff983d33573653de429f8c802b8a8d1b8549840bf0a6a136bf80248f1071bed18adadb9f284853a88af3cd0a45fd9d237b6633a177d88c7e7af45239a7eb9d208b56c5429096c0b2ec93d29545727945dc9002abe297122f8ab8eb85d3aecd5847c4931077b01eeab178876a82db8e5cecbc9fd810d6f4219e59ab50bb99dc9c809dba578328eba8ff38a17f5fa5be0986f1962272ef2fd9d2eec8ec3b63826c7dced375f0f4b0ee96ff681b53ea3c5e32132bb67814d0eca4f9c039286c93155aab070d05f9f9502673c850b7a48f788ea6a7eb1b46657a3ea2c8da8d877eeab3e9598db0b6fb4858bcb160b959c3593af790d7c68b07d587a4d9692143c4c7aad9691b1c5b75825339ac92ef90e554c8c7f5f402a34ae0e2bf6dc0bc481683411176bccde261032aefdb0a28712106afaa37313e18b9a7fbda970ad25a45f73ff99e0e49e98b2e7ddec87c4300383c2b141faa443c145e5440bfe4071504f919059c7a61e34a987dd515005405901fd4517edd281279774fb8b1e4fd4d9e7fd41a786e61586cc620eea7c3514f5ccca90b2516a87250e64c3e1084ee93fce2847da2d320b1f0326211fa6b7427dc3b5a4d93110e4520984687b8b1dce7c1a77bbeb85d41e78d510f5b35476a66e4f7753d2f7a172c982f4ca0caf86a1a45142ad79cbdd3e4460bb9b7bab96cd649941ac09cc858afebdb076965ecedfcada047810eb9292783d116eba9ddd13cf33f59c6fa302a3f0cf3b0ceb49aa35e3e659970674f8036e01eb606efeacf5df73918cfaf1c26c99dd82b7532aacd9f85abfef61317177e58e9fc1befab25ab2e9811f9a8f5d35c60ddc6d801c3926e68e1e1dbc9c8fd27c6a2f2eb36124712e3d95d6ae06f38ea3a79f5274bdfbef28d8cd42376afd3125b6e13b40ef4f7a4771e3fd3624a4fbcf6123d4d1ce7d4488b9754ed2de7809836a6d6c1324a180085da99edb0cb678cc3496b951194f18736ca223a5b892c44005ff332d0eecc609726eb87cad311c1f38a97031532e62bfc1c95540bd8f4619a96ab3104e01aaf70ab29975b872b86c6c29fb64bfb5832a9b940f21a2c39abc7843f336cd8dafa781e3b42b8f0baefcb77e69807415a4f065c19d07dfba7287e71ec4873ce44b67a536463e63930d7f6925af6896e78f1d7fec70e1daa103947b19b816c71218d3ce3ba5c5ec8aa043b84deab492862e4f6392a081b440d01ceea6404a21c631f90dcc56633fcfb98e7849af714d1159192bd594d27c34e6ecc90cbf4a01c9af26211231c7639e0e8855bb056a17a3967d740f337fd1dcc230162db02334c780190b0e5f369c47dc481ce45b36e8d53b0664f02d71590907cc880722f6ad6a591146ea7b38e488650e4c83396f99e4507c569d3262c1d17603b264aebc978f8c22ed10aa2c4ae9ef3734372b20ef28b98595d7f255ce34c5a71761227d7201dca38404856a0353e1016ff02aa756fc11ee6ca38c332d2d9443541d07395e82d5c2c3802b47d7498d6f62989a8bcd3f8d819a37fdd17a1aee9d7d45e6870bf3008e9d27952f3ba5fb46b5797cd8878056b0688e01ab76fc189b4e22c902dd9e734a73c502d5d223f46e1c1a88aa2fc7d574e4e9a5fec530908e0446d40eb2a449afd1b407051c1db5621366c279ada57878df5a36e1d90d54de7e6a32cd228db4db5350696aab50727d4563e1b6b583c9b83a6411989f8e4c59161c892941bcc9532b110d5e30e52a4e3cef7de2d7732ded491edf0b8ef62594c762d8256410fd87c0683feedb0c7a2cbcd6f422b96ae663a022b76f6601ab5fa1e717e490b8cb1dcb8e7ff3c310b0215f591b74d80841c697c8f81af6938e1c02257ce2101972a9105b860ca5f847d227c160e992007a4be61cb7d4a7d1783deed2a0fabc59417506198ada74d469aac07b351d84713cdc5ec17357890dfbc11a90a2980505df5104c9543064ce292b5b93f807870c71d69b7b1ef90a59ac8c46f7cc8ca9e39c92fc909f52829e676a1dd09f33054a4a6628105b2c68bac445fe66389a9d0b2148b63e489ece46ef43a392e4484c3eee139d3adbdd11673897cb1a6318ea94f0fac0378d3ce0b96c4c04c750dac60696a9b932671e746935ac6a3c35f9041b10b9389f94906e730d93acf2627b604c411a42d19a756e29bf90d52031c1f2b3cb879e44896aadfda9ea102ba3a3c8e1d437387fba4dcfec1729f47a44e1536c4d64c1f7f0b10b188505dc3730eabf78d725f298c6e0d4d4c7b6d59592d15410555a463e4615438a5fdfd1b47d6b83046f57e792b9fde74b65d8b0adc617f87ab0731b47f56c25cd9cf0506b15370a836d41f76df2fdb8fab5b02f7e94e0f7f8b61983a9c867c513865bf5539f93bfdb6fa1d709036c2d24c0d6cbcf1840ee45d46b9c087cd2fdda6c0b3aa0cef1f7ec9e8337e511a0de04de11ad335fc6e7ca50fc5dc8b7d5a521a352bb8536dcacbd7100f9e6c047a1ffb3ceb9ea5772fb8fefc4a6a5d8ef2b77f3d82352b9b6ccf536352f84d618178d311adfb65957019504c23776aa382530f23d840b1d145d0cce5bb859e4011e7a05b66677108b46c53a6a952672a214ae5ff624f40b12d2f9cd0b87fa0d78c3cebfd3b0f193f6e709d13bbf443b8c567a12507fefe4d4387dd7738d9235308a46867e61d2ec4db7eda48ebccabfdd260075171fbee4b59c9fd136ec109e4fa071c1678b0c5f3f535515f29d557670a47d5440134c6baa22d0fca91832c041e3e7bc37d9662fc61ed307a408dc32a3e911eca61adbc371d87491f9462798a98f3d2936051cfca094fde02bc176c6fa127a367cea0f810bf5feded41b58b57cdb86a5b0f2d73608065616d2bb75d3f4a38837999e08a7351cc5897244fcc70039b2d1eb337d327055ec0068589f95a85a74540ff7397bd2794c8c8d45c7a9ef78732c5770bea74a2b2e3498bdc0b86db590fdd06d930ae55ae4b02cf21d8186203986cdec625621746bfee5aa1a484d16dba8bfb14c0913fb82184d1018019a05260a03605d67e5e8b65de86387ea91c0a838b9e87ee6c9c8d819bb4cb44a69de7825a8427ccd512c49edff4af9a5a813f4d54978d8ad032c2af936bd1a2f0bc6cb212896c6e5fc75938d1da6838902107388ed56cb2e5aa9a8efa591808b1f88b6a16fc2bbdef293b5a7bd25dfc0d5d3551cc7148783f419518508e752727129520278f5a882270baf4a81f36322d5f97120813855bb4c9fb008c021eaf8f5443f2e70a0b7233a5d6bbdacbb38d80a78fb4480db39c3a8e42224780374d434790d3ff96328a13883283c73da3d71d44b8e0260b18ec664cab34c5f02ee47e5938809f1f82ca314930534a3d357659a1244cca13658875efad787ce99f0c40d2421150dd0e47d90e44cb115728cababa3c2fa8920cbca85cea7b2416789e2ae91d934c05bc9e65b25b910b0badc2c6fec8915638a50555ee9278419793e40042ec67d023690b5338fc1c9cc9ac57146303fd84e1ca70590d460856ac7321edb25b412bb2b4fc1b976811b685587fb8d5ba5bb9ff1948d429d0e29500e9f45923c0794c58e0a3b6d310b37743b45b1564dd22a36ddcf7154ddebdf4fb1c95007d7cc7fdc3021c7750ede2c835f6a3d813c5a7ed296a52c1d457f73fa88df46bbc17601911b06e968fb1fe341d676daaab3115619f651604434258436941f67d5071c6f29fba2d8ae792eb0ea760362fb1ab4502b07ac5dc9b7a038acd95fd1d8bf0cf26fd22bafac4781b67eb84ffdfbaf2c475f962d5407c458f24e052bc6c313004713da5e9a4dffc1cbbaf24a2849a14d327d5649186d541e9b8555d30f879fd0b6cf799f23280b25362d04d891cf1ec549bb350b1a1172128bc8c6b33afa5364cb640949d5ad9443f9c782d3aa70b469dd051530db4d9a003aba8dbe43ea2ae0a37e52a55d80a27ddbc3d1ff8ba8d2cde5621458970b0884bcd084cd57531ae55bc645297825e3c5c8fbbb2704d908c6183201c37673d5153de14e4a4ca20e74363e4cb00d1ca38692292e00fac8f58e4eda4fb6047f8d8eaa2067bc2a4f1c9c2d15af2b670702d868c3bb4b4e62f2006748ad98333ee4aad417f7ca412828fd127cb571156080cd4b2e3d61f9726161e8e19f25a608dd2818825490cc8bde8436d5b1de127579421ff910b620345ff2daab3a0ad7a1ab324078012526932a691a5f10a7ca2144e1bd82d3d18ea7640b417ab0987f08fd86fe753a237ca4a8c9e917ed94227798448bdbdc5e717ddbf3660c6618dcd0bdc75ad4f8ecd7c2fee8a94924e89d35ebeec58b21f9a5b3c434ca2f1e241cf56f046f9ac3cf452bde97234ab227d5b9c7a6165cadf683da2e7c7cc11241d08bc7664f20fd94f9b59a79a8667395e7834e0ed16c4aea9d04cbf2298b70be82932de55cacc3494253baee565fdf037fc8f014969574fd779eb83b96ba6652f1f3fca8b01bd828dce110c945d56041f4f135d3a58a063c6d7b044efae6ef59cfac17b94817c75b3bc0f6d3bd1734003b976cb7649f03203bafc04f742e2799d2c03969042346512a1fc2703b619628c4f8d55d843b0406e6abe17986b3c4681abc102e8199ca3db77385fac5646c949fae5713dc0f241e1ca6e8a16d0017b226d6b258febc18d46ce50ba1e25edb86d4186e5339081afe81b3bfd6960a38d0119c93477c5d3719c9214bc76ad9a74cc6b77f7cb373425aff6767d53dbbee3d548b2bc7d52bdb631199305e886f7e01f17d7682f9b2b394d6ff74e56e05e05589eaa25c2d23d8dd1cacff2ee0aa06c682ed5756740de551f6dff3560d7815548cfd5903299a19191fdd846124ce3b3c6ce23b799497e87a2ecdae74928415d26ab4cbf9a0795277a9d3c6fb50c9c4c65fa9507b0f6e084f9abd9303e574d251009ae1572bdd8a63d639f6cc0faf6264bed13b0afb696aeae8f617eec254cf02316a777f74fd3a92cc90fbc96ff827081524532b980d26b33b49f8909904cd7aff7c055857d082ac36b7f8a3e59dfca9d97fdef29530e82bf591a4d53da914c002239eb2111626b9f785004e4deeeed04607eba0781cfec9c130e33c191abcb632d943cc9455aea10a6317e7631f3a2562c505a9e5ebead3508b82b5008170eabe9200005b0998fdae2ffec433ad2bec3e8a59125149dca614770d2ade45cdab04a7e9c78d2d25aa50cf0dd3523aab26766012dc7a063f25c79620ac41aa8c30da4aaec5367a29b60fc361bfda37e4a71be98399f2b68e5fa6a39f7b9f853d04dae7b3c4c82499bb58ab453bdc820c1bd4a79b14d7ae681005a55011c7d2e2b0acd14ac05e5ae71692eaed898688962e070965cdcc4271e71eed12e2df344fa7baaa7099ff676d444ebe0061d2f8b4986026158066df0d169b8f8917d6e82d37a6e9d3d8113e29777ac53d5ccb1cd24d54d7bf38cac44b75d6818285655f867f6c56b13c355fbe8c714e9ee0086679a60a0ddfbe850a6c34c32ba2f21c3e15c9c0b0b9b99a8ceff204a62a4d32536dd9c024228a607d8ac758542387667ccbe824e2844079ae5c540f4d8d2b0cc16a8ba4e1b6e0dd67510f67a64a8b7872d8bb25d1248a11627fb7dfc376ae43ed0cedd1bb6677afd42cf991cbd4cd109a7096e8fdb7b13aa05e5e72bc8a9b9685747a15fb4bc5b0e3d4890ea0aa661f7fd28aa4f03a68d13d3e019fffed44a510e7f020060452f9e6c0aad5a75724a467690effab5aac9b497f94b31321f4910b70d06f72f2bb59948ea41cd3e0a445755dfa1590463f3ea4887c2a130304dbe010e1c633321dda642b695e42f3e6ac76aa7598c10bd7219f4cc93b8609017c42fbb57a2af21ee5ee86feb730c3dfeed3ed2a46f95d390981a138dfbb1734235db9064c879fe4a9499b8af38527ea848b7f3ce94d768f75aaaf39cc952cb7184db49603df990578e0781231044c7fc2354393e16fa246e8186db654e0ddbf4f1c15fac2f53a0b166b700f690da5de5e0d0e4eaae70f21375627acac73176a4394a57b7eaa361e8e4e95723ee576105bf6c4772c236a4df25a1fce4c85f2e2bedbcdde8d341c2b050f7e05e8a5087f78910ba68d35c85facd5e6fb4504e421b996ed3519c5577c5aa4378b0fea4416ccf7646faf5eb33b2b6919186a4cb88267de6496dea0cca25699acc63d61b9d5514f8554d7fe0b71592ef8561a1cc1f32b45fe501dbc1d22049ab8dc1576e682abdd3f30a2613794191c58465e5132cf3d240876b33c8d8d73336d58f6cd138abaf62083f7ba0cc560da677249290dd89eafaf28ad78eb11481987896378840b578cbc940f5bf11861917e7a521011f9b99e70da39d905492310e7165bfcfaf0d912b8eb9a794d9944501f0923fb144bdf6614dddb739bc7a5ea5422a666dec45925189651bccb87760cb0f4811e8f3c9eafc06a8854ed8f77b9a73501cd83ca3f0e2d859a7a28c6c3d71142ce848345291c1228cae3e64061921ba36a045b6bcb4b2364c3a20fa8001e8289fdfce8d929bf126e7ac63262525d7e98b2e9bfbe3de3d5e573c863f2d57acf823f95b2c5f03876e0421ac88ee3446b6b6e1e287067a8544dc1bb46d5d1dbd334a65e59c13e5d1c44681239231cede6eba8e7a842ae1a6f3b44959e3a3d12a55b2df145d37c29f67086f3d3ab3bc0875166bb8b4e71bcf8dfccef8a9003646bb07ed756e1304173a29fa7fc738af8ecadc26a96dafdc2238a6cb53a0227e59daf0bcfa6b62d979c81fdd74aba73fc985a2aa22a29e1162b8befc638f35149a9a98bdfedad06e09586ed92302080865c1d0333e88a9bf2c11ff2745f88accea1901973796a2b0f077b35a7522c698579790c91db1dfe9afe0eb88985d314015baa131dff8f2d18204eb30567ce76406c397993089f65b29e8a5668100be458015d49082a81c66f9b45c6def95a178582b6285e4f8040fa9ab3723c28f7c30e2aeb30c9951c1d2f39c683e8eabb97027b5a25b7396007610350b1cf8d1d4a9f729f65e1f4ac3c02874ef1480c407f97e0777941b5fda5ca22e894b991b487e5f62759fb1d89582880aa8fe5fd56a378e3ebb0944c998a79f94fc18d65cf111988c25b4ab7a006ed040819aaea6859ecf7f0437c2871bdaba40a2fb89be439e6673145a3b3e9f1b21602b2989548124aa258ef51e730caae3524185f9c4df3956fbbfd680786e1e1e8f73d41110f2e541d97918008588731ef1cfb04619d80696b4af2004d4cbfc9f14b5184e4df4f3316e08de4665618c8b1fc3d1c145caec10815fa2af4c84ec29223aa8c63ac9a55cdf4de6328febb85bf13935de9b7d7f0fd0f90aa04987bb467b4786052a3574dc4738ab73acdd3fa550a5f9d724e59283905c742f4690dffe9fc968c1871798840ac62c7f39ad444680ff506f21ca6b834f323efcea5aae263b4df1f4ace253bc28f6edeae6ef6063e300bbbcd9846441ef372773ad6228578aa3196b0e4e631e087f4d59df5683ae8e9289b2aaab1c6046d819947169f724128448436bb6aa1be78b1ab8b7b11489c8bf3edc7b2761dfff5897c57c5ca7730d7281d3531b53061b11afb6c250a052aecb449c526e156ee317ff4c4b8dd1b9a9f880ce293c321ae2793c2a3377c5d8dfd999e357f161262f1de3e2d24fe816ceca8dcafc7b932202a5f96c7d3ca61a9ce65951d35ccdbfea52f9c5cf57baacd8e37655580f7a827603032c2f4ffad35da17bb89b30a79f75b12d5b741d337a1bfa0a751676fcab8e6a6cf26d2db4302715a490a72953b94030d339020ee00da1ac7db65478b2c455209d74e15aaaf19f50b11f1a4e51950c98c70e29d3e85fb41d93f1714554da7adeacbfc6e90eb711665ee5a0a6480396bae3cabc3860fe481cecfd24f79dfa17cadae1d2d8cdd448dbb8bc808ac977d5e951e56c8f9c48c863db26f5e805946008ac7907f3fad92bc186de742e79010526f3d9faa18366d3af5074e3bcaa8816e023fca542dd82ada73989134e2e44acd5e720c24aeeeafea947340fce458b26f389131f440d4d179f4dd03b8c07f964e723489e96ecae6b837c6e3d1dce6b915c1ee2f960a88418f061a1227078f07943aece89dbdd9bf20e31c53050ad49be1dcd6243e2fbe87149c3f1708607b9833304d1a02f406bf9d7f09718f79d11a9fb2aca0a84b72897ddecec4dc655200add47d31a54128a419b2144219e22bd7e766a7f67fb1de5b94277af5a7068965ea0fff7bbc92f122c4a340c6d197193f45571dec444ee6ed89d76b806ce8b5927ffb965053d7195c2dec95645b7969bf301f12ba912884b3db715a29d703bba86b821fd763aa2b453afcffb28ee070a658947b076cf3a22f6e902a1854923ce4d7236284641cbc49e2fc33d1708f4d7d426873dbd667074c41b7cb66eb85fab276594ee15e347d4c9089434ebb246ef4347035541c6bd3948dc834df129646345f0906c5b80f6aef0f35c292141cff9cf2aeee6b03c97211d0ec074fc049f41cfa180d13de04968c49d250af0cd297c1e83fbf0410040e002c6c053a81433db8baa02084ee865fe91a56ebd921dba2afa37d71024500141c0bde019eed049103bc37d156803bc2c238a2a73c60db0c156b37fc4bb9ad6faf28e227b0a0e3b21acdce1b3ea4ec814c622a167c6ae4c0c06c452ee8f6d193c9656d5990591ca066030960817aba59cb80df80ef2a17d5956e544b2ca73fb49ffb670b06344bc0c9ca6cf082328d690dc6bd8ee854222386e1f16def43e18d48b136f8804ad551414c6cacc90739812ca2f3f7b5ea56fd7ecb77f17f9d39db701901b69edbbe223b884f8262328461c78cf1d9467175c6f16ca9e74069497666397bcff938cd5cc6e389c4da441cccc20b9f70b24a4689d4dede2c5e0d1368ff2db5bea196608c2d6ea4a27a7c6e51498f553267031fa1483cce81f9bebc02c4390968bbde7568974b8d108ba82ededa158ebded03a30b451d0bd7880bab667bb1dd5ec82cf422fe864cfd8c43dcd9626d79f5c6b16ef7b96857be29858b5bbbe0ab856c23dfabe5e74052be6678d5c0a772a10244250e57e2e22c3eab68704e6c39d4958b2a472ca5e70606bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
