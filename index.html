<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb9b57c5568f29a90e368d14278ae856e045991dfee4086af496105854c0b2f3950c4b9a4534748bdcd6986f083255b9a8a01c19e2ebf08d1a0095623bb5cf68dff465f4aa11df107ca5601edc5b2e045339e44018ad07a5ffbeaddb9210523ac2f0936557874e17c43b1554912a1c22bdeeec86f95da6fda096ddb243e936f3311134f146f4fb3ab57fb0a07730a5a3690727f049dcec9d0f24ece7ce7ac09ac0677297cc25f770118905b9a1216a89457d9a9cbb96a7af572c23c42f81e1b9ded8c4a5c95382a44e222bc62b32276bd77c07662d427b338d212783e5071fd00b1397d342cca1314b09ba162e46545e69a3967bea8c9e8c6581e6e2257e07b86d0d8e8be6e23805549e57f3d6924e9a5c9edaf1d1b3e38eba8508fa6ddf4a93bb3461ea229b9b13b75049adb6fbd38eb6c7b0bb836d634357f89141dba38df76896e44655bf0fd7484246093c064843f997c60789c765b327d6d14815dabcded47dcb6206835ea01e211b0cc662155adfb11fc0ef903a6f77c966fa672b39a6fe8a583e1b0931dbb2bb8879a4a8c3d7ff9f503330cd06d6d1104ee0f344dd3918674fabd425fc8fea9e7f4ad5916a88f0d3a757d1b7894a5863100b701c19ef1e40bab6998412ecdd31fde56b63f8151759824f0803a400f219d8efb2e288ef8b7b2eb306fd631b31c4dda6680d68802630d404b6dfb7de7875001ba309c198579b0db2e23ec599cf23d1e99683efc59768e95691a2a7602554b5fedbe8d44b677686bab9714b8c8175d04783a1359e826262421c2bb3d470075c2a1b0eb320212d7d44ea11c142f68a3eb56838e6bffc9cad4b13d22699572074b6560dda448d816e05aaac4c1978793831c67414eb9ac71cb7ba6fef2ed4d96e7e6d57783926b38469e6a86c9a0cadc295aa5aa41622994a9da07814339a714231eed4e232109ad9e4c04b37660d6b2b1cd9fd9991d35e36ae0141f586f9161e1132cd3cc8987841ffc10742e7ec17c661403187f309d65f0c426ef3f053f371462781f3376d3ff804e386446628c12e86cd6fc0bbe18de8db2061e333d2a8a79213e5bd8d7e95eebe5210fbfc7fd898f332f323fa64e7d3d7f89cd1c4c6c138c315bf573483cd2f48082b00ef3a8a0645abe57cff9af2466a4021dcc1b0c8c78cb61e68d574cb1502020a71bc66c8d7683b03990b6ab39613a5b557816dbc14f8ebf87c48a49e76dc3181ca12adee63d34e66b6f1afe9adf35d2e6c5b677ce9606f8094bc900156199265601342dcbc9def6f6d9b8cbe71561ccf24a14f81bdea71bf3a2ea9b42d64c6e4f44381875f9cca9c4c03339e1b10fb11eb71d7d03de433a2bfb1ad18532c8c8b5cf66897d6393cf52a07239a2312c1e1bb27345459c7f58086f62db382fbd4f5e5dda208243cf0fe2bdda48a03d1aab32f90d269bc129508226f8fa85423542508e90fb0b2a418bd3655cb3bf192fa43fee0f9dd0e84a93ac841dea6459bd6bb1a732fe102b714cad78de5cc9a8b3120c9403ac1bfd93feb5ad3d3b011d783f9d9ba276688fc80b9efe32f4e5c8baa4b456042a474165150bf3035cebe1aa527d276c1dc126b52f7bb9d8f80d8e14e5acc6839a66d9b4f97a77b77b9c3359b1cd85c321238bc56f7bc4c671d318ce324402b7763d315315136e34c873f4b65aa0b9a89c77b1123cfce275de423f9db85f92041e3a06a54ef5765f8ed184a2537c622b29333b7d9226392ccbab5e99fb18b559ed705264c2f4b742cd977b99ed1abc0eacc1febcd6716a7f2557c09a6caaf585282bc91e8b83bb44dfb0607e87f59a18f52e7c70f45b964810c1990aec67fe7f717a7f136ae09a29e377b1d90a898e471a5d67a831941ea04c119ef9c28f1ba908bd940f9276dadef251fb3e61ec1ea5924208b7a4114598bc1a164f9569b9f048679e3143f39395dec8db8ac523f9b7c2985c393e042a1dea86f38f2e4546253db8025207766dbcb127b8e1896d2b904ce46e90a7a281577b7526b148ec75b7970fae53efeded808ef0998f189c926e70b9275763690df8e898f586454f02df5bff07e9db4f24d7fc2bc6076709ea4c2a4f54dd0b926fe7566986644402cbcb32a245bf3513c525cea1da8b72523dec764772f3bb7270a057b3a9d9695c49ca58d1f3cd24543af709cd21dba74a50cd244ea93983673de72c55584b6730c0f3810bce2083efb1e421373497b54bec1a35c592d54d77a3d1f052ab125a843cba5e23287519475c00e181db416ffcac817ee52aef8a1073aa90f4b20a5e14fdfd3e9b257d15e43c4a5a9a769f05e24f86e90e8056c433044094812b4f3b84b96d2a2c5d5b59bfeb8bb44645d8e441a7a726ae37fc2c40af2927b7f2e74020b32d44b4126f96af06585bf20594e6df9897fcdcc28817a4964a05dfac77d0953fae1537044ecfeb1661d404face0e49eb3dc45ccac56efb1dee256f7dc2703a3d6baab1f35158698adc6edeb8eb8941d212e32208eed7e53c44a3c9a5ffe86c90c6995abf6f2188d8fcbabedf4e04888a5ac0b3043ec805175fda35b8b6749bd8f84c3127be9fe4652cfbd7b1180fbfa838fc383b22c958a5e1912f50b1352ec794cc136354a73faf4d57f0aead7bc1fd1c97ccc8ca6ed594b2acef16e65880566f0a99251bc66a8e78a7a316767ae2dff64ec40c309c41d20472ea1f8165b5f361b8957a285f2b8454f333d0f372ed5e655ce06937dfe7cc0185660c24adff02eee3e18f23692f81ce4cb1300b6b23f12e5cd3a4ef98022a9522dac917da2c1d2b1c50f0cd2069c5512174927d8bf8b165a0d58cdc8747141197e06fb4222c323bd35d09112fd44758294d5ddf7ae6a3ec7347d5f703d44dbceb3f9e857add2fb3a024d38181b8ca17dbd0f3aa2a7f3cf5d24f271645fe8d410edea78df5eb76e23a4d72016922000d5ce1d07039bc37d0dafeee70f3fff56b238cf60fb631b141467f076a920c03fec539aab2fd3160f1c299162e5f4b384be43a01dbcb9cb091e4390f4e552e107ce8c5f7fdd6390fa40deba4f58236b4b0410151856227056cc347fe509437a082a87f0b62b96ad969b16d6de8da836130fa82db56bae6a406abdb25a263d96e2990ccff2d4a977e252e55fa97622102ca5c5a0a45fa5b7fe70001fc6b5746d42091f09a0e17c2388c17835d214d37102668f3ec400bd0c811aaf5552def83d3a6a8efaa03d41d49994f9da129d374db98e6779021ed155e9eef879b4ee1943f7af7bf24b16baec3e90d2c9b10a63280072341dd965d6c522ed6473f8bdbf04f9e376d49cfa3072a1c1c0c76887e9278fcea51c41219ce9e160b78dca20f9f437a89cbac75afba5c2ec69fc4b459e60889120c6c373b47f598deebb8ea1380f95f02b69b5d0393f4710367502006db27593c743a8530f1825543f37a6a0b58fab3202a42045082cade08872bdcf250294134259231046b7621037bcfd559b14a6a92416e9533fa2f0e7216bf031dd19618cee36b9464a65949c8ab31d9041dc1ddd0bf2e8414218fa515f56f1a4cf0e1437a04e78bdf828473db1af7dc42111c5e27819a9c52b89651ddd3fdc74d90bfbb45cb41eb036662e1df9cc11c247ccce9f2de073fc6ef23960bf22f6a0cd0c3650d9f7ca210dc5fbe860bf640ca257167df72407ef8645eaa7619dbab798c02b9abe8210b7d3f1a5037b86fbaea3109dfebce620776818b254ba6a6b634189e709395e00048fc1dac9c74c73c25efd4f5b84e76a9393aacc41c8e2c82e6374d1b59916cc333eed764d7f7ddf9c94b3851c4bbdbe6947571bf794f4bdff6e93681150e4e7fe7f9cbeb402e028d692a4d75c7c8d2046c52591058b7430d35857d2b8465eaec6c80e7f14d91eca02796dda40f8f270e4f2917db6bf44ad9ee6f167465abef302630ab6a70149e2d158b6b047c903573cb664a6d89bb497adf52427857d9ed9df4c0ca193351467b8cfc2dac6e7c0153ba862ebee71e6601912cc1ed51610d4a6e431925838f53ff75b10a661bd5e1ec299df6b1a659ddd0400e0402fbc93233ad3e8f102de3ed8a9bde704d49409212be1c1b43efe7bd2a8d05ce4564390c8f20825c2c305389a49cd981d901e670f7a92022024f3c3b6aa83c8e0b868b20114d36fb894658058372a2d79a3fe1afed344f5b77cda1929ac73109ac422338479a2a352e8d29dce16391fe021af4cb20704ab71668b71cdd8cb624bf70f2b48073320e69a29d2eb2990092e93c63a0336d2441da7842df86ed8ea6024164efa2c690db867580d0dcadfac49b62e47910b89db4eb2270fa216680f504eb5b405ac20c9aec81cf1115c6238338142896423e96b79e106407f6f6c2b4f5babb4a207d2347a71599264bb4220cf24bb1097c8cf4426d5f7e3131380035c12025754b05f72f5a649604138ee60e9faf7df79ef7a833de1c9d19032dcef278d895b682e04083a6b67a5fdeb70d89fbc1d180d2df235a11a32607eddd63cd36d0c46d301a2349be3d97fc47e1c44d85e8c4cabfdc5511d099780877fca1565078d209a45d01734beccf47fe8e1a0ed56b8ccf0820d48d866908b204f4ff940b2c6f1cd5b90e8ff4a0a865e88b114f172a23d209c1b86abc87d8105c3cef1d0b52331bb4dd213c88e72e4bb40490fd7b059321a1b71aecc2cc87a1b8f198c0e637402e6d9ec82bd8da350bc2228e92579f6f56201598c49aa0009895dadefd96f25a0c07fd6a37314e1b224760dc89f8c7ac6669c8d113543f31960e30640ac5cdabd1f1b15d4f114e6e5a780266112f738bf64b284532e15a01c03450e19022cd38d709b917ef84872cd958760d0b04988fd595175bde22eeee866538a142278c12f0a5aff855d067a09b03e88978818fbb4a8acb4d2ecd8f119c623b74c2b6b876b0046e4da6b427e18c7c56d76de89bec5e1ab8e8e257a1cf5d68ed40975cfdae5e1a1109be11321315d86d650094ae94ae9746539163313cbf9a3bb7ad6ccdae9bf16a98368d48efff3e2d7adf53d71312179902f17c88a7283f5855c96985811c057c4c2e56e94eb93588c74d590a5b4d9dfb42b2ccc3b9ceb452cb9d6cd8e551f3ab5acb0874c5f6ed50afee839e4c71c0f3f5a768982a1dcf8bd4a465fd1077e4aa44d7eb4d221d3064743924673b9f984567dab345617c5155ca2e3cf48aa5c42eaa82fb979efb1809571c48891a44b5cfc689c869be3a8840ee199ef939b969922f796d90c280fff994c01d9382fc75a7e3ed6a4895c46402ccfd66ed6dba567e52c3f21715b0dfcdd87f2658d0fae63a30168b5ea4c208bb62e46b8179599d69f7210933eb9a628ee41775f31d61ce964a3f091c5f80605810522a8c1113b514e48aba1e87ab7723a203b38bc13509311fcc8b1e8c186dc12164fb7123f0693edcb3f5357079d92e03e887bedb3a08c97ec663b26048291cb4b52c472733e4da78c33782771c567ef577313387546ff9a777bd9b79ccb37fade9d25b3d30af3a94f2cb94e05b47a119fe6a10747bd7b1fa16918c8957b8eec3907a63513fb5d562bc5d226a6934d0ac5d8051e03566d0018431826c288560ac7af85a5483aec0c66fb61ed75e10979b8d1da0dcb300bbe48bd92307842c3682c1d48e4f3373efbc703b4e64834d6ef7e84c6d974c240539e4545971adc921a07ab6be0389a2db2b33b9be00689e2685bc72285a65f1817fea42032a2613535b2d56d4ce683e6ea4e772602508fc3259b9daab81cbf49f5431de07524641c89684dd6cb9eb60b347dea68642c7df74af8ac8e79aa26048a5a01c730c0f78fc95f2378c2bc6c3dfb2660f3e210cf24c4a086d02b9bcc9ebd57150a6c36eaa66bf97013d2aec43e26b8a108f56796c64eb718345b7f79e0fc2ad59fe5fcd5f198baafae8c88fdc69bef3b6c66a6287d34ed71eb8377ac6c567f18d117615c05c280f2e87b9dceb384731e3fcd7705873537f3b59f229d46c602ee71eccbbdea56a1555f216bc3b6c1ff25ff05adaf94eadab0dcb8e3d668f218efd298e538b7ee8d9489c3642b75337b3cb08e1081b213341f9a4bac134bbc93f9016d3f3009efa545c0240018c448ffd20e827fbeeed29dfd2c51e95ba00f7c5236024596599797c7b5b0dbd61511e105097f22b3d34c3d7068033636acb85fa066316b2990f93aec418387604be4b32696307c11a0f38c5e822b1cc7a6f359bc88ca02c49f9636af8494d83ab980ce02600256c6e5f41cea162c077dfc9bf94b490192e948a45f639276c88bbe3dba10f81bffa9135749db9651e00590cad52d8e654facb70b8a48764d534f7ea12168d33571eaf904784a85e71d26082e915d459711e81a187fce479655c88f5126a90970e92639ebe1ff47a4249a6d19308318125e072d7f0f60b3686ee0c15438487ce507bc5e138e64cd4f99691620800ed3307fede67c53ff0fd85e5d7d47d1875f7c357c6cea57a39be20b38e0450e09980b11c91ad726d7c96fda00d082077b3afb7b6aceca6a1bdb3dfc01992dc9846c3adef7b2a05b931d1745710cc9558176151bb7bac9819f29c57f125b7efad4485089e2d115f1af8c6439f0682d6f72b1dc569c345673921b0ed6968a607de05b3e3db06d0da043013c59b0cf30e538bbfb8c8228deac3a8abe3a6e5608a388a2c0f6465aba4c94df16966146d5d1ada995d5243a67379c362edb59a02b20c4c76770f372511ff484684b9002715433abe4bf176a286ac87f7b9ad060fe18fc2e3463159e5609ce7b4ddbca393de637e03a6f058a44b867327f39851b36e45fb86243659bc95d56d9a7b2baaabc4d9103fc00365404ed33cfc783488fcb5e23de2c44517d9e7413a488dea491ac189cb19374e88fb657065cacfbf9e272a953d9811a0a6475d39d3344a94e3b5cc1e13db376b7b5aad341239aadf17ec39d78d55d42502f63d383910a68958aa137c2f0a9e234563928b5fe51a8f3faa765339d376de2ddd1feeb2b92106928ebc9a7e90cdd3a56ed6189b59fd383ea8709430a5ca9519e227f17bd8330dce946bb5c774f1c1e8acbecc0d9cb97e7d24b3a40439dcd066dc63b98b5a2df90e104d639775f773af30da8828cce75608d2dfc11e1e14c7f71e76a1c1d7d2ed4120e3dc9ce46f4aad978d8577992357a11dd7d00ba4abb852d4afd5dac7c11c4738dcbb0616c150a33a1e52a70e120f6b94aba8d4288b0b9b0b3f55148f5419abdbc978b072c10855c27f38a5ef2bc5e65e12fd7ca53b63b807f2e71cba209aec05ded2403bddfc900c2005a303f9daacd968be07ffb506345399bcf1aa7d71190d64619ea5b765c473b2468a627f11c1966a50a5e465f213e20624eff27597cfee0994d1deff7d2344f277ae9588e2232e5e312eb0a856e369df3090c93b6d0872d6cd41cdc9ff0518678fb2313dfbd54390824cf2074ad394a15c34d0e452ffdb1ca68efa1a81f13b64356d15f37fae7d48da0de22412261e79177fdeaebf7b40dc4b023c5ed4220795c7e0716c7d6753754c8274c9b7c9e55169ee040242ab15006e038c0e21018de2a56e65da3f186bf719a9f9a7db6c71540b3670ecfa7172caa4ccc33d6dcfd8076d9d662daed91df2874a684622f68465dbaf19db68a99ae9e4a824d0d561e6846ee4e96a1e1aad9513f1357cad81b50d73e0f6afefa91874ccc5a5f71065eab993ad5d3a330f720cbb88673279950a205d79396d866dcc1cf6f930c6af108393630ec8ed4949c0cb4b8b9221f94b7b9ea8881139001c5c3c00540951de1d50628e579bf3929d099c47934c44c01996f75b261631c039fabbf56d9a6f59ce022554e7bb44c6f8d06fac762ed37d4d2e0d39c1a0c22cac8a0afc9aa82e55ac8ad8b18140b53108e2608804e99671c4b72afc15a511aaa8d8d7cf44e5e6b5ca5e82820eb67cfbe36b0d7a582c0831faa8368ebc4f40eb34bb273d2572b06d3b1ae72be91941222cd2daa4ae806265a062bd36caaab95081bcb0153aab64598047c94fec275d0cb02743cad1e0fb760c6afd1591c23d2459e23b2f40364da0eb076778fa19d553d93f67ee1e3ee0e4085b934fa97d32c1e5d1f72e76aa18d09ab26154cd205525a61b92b771be53be2c4033b8fd3009efdc42deae483f652d9bfee7fba57bc3c625253fbd1ab6093275aec1d28d81800628d098200db171913d54ac2aad0b811e6107b59971acf496d42b298d1ca3fa41351d91c2b7807d114ea3a18d32ffb94ab482e8a14ca0eba00cb8147e0736179e97de738e2a97f5ece4268d489a676562d5381fba81e1bcd3f9fe1a5b238ef2f23c337bf13da8104b7c5077a91a923814bf026f0216b6778b3a5e66002b082cac7a45694530eb5037dfd0af4c750ecb404ffabb952d087e9a35660f07239fa0f5a4a0f74ba06d0be8c631ea61d517a533347006f1a9d22799821f1595f060cdac70206c965400e3ac4954892f7a0f3c4ff063c6a8cffaba39cd5de471e59238a19b5fba2ee49ac8de02bedfe85bb4cbfbee478a3487c6856c0c25f27fa703cd9fa27d71a54838fe623a8d52e363cceb403c21daebdf59ab0eeec8c8b66b7fed7f0e9708d22291083cdc6b742157ab370b4e4f438b4b23f83dcec863858acf65739991fcb4a4a385237fe7ff5906df9bbc0ed51753cdf2c16bc3358934132a7527808f1e2d9fcc698050cb5c74b53639421f0b2072798329ccd6359065aac72feaa4c3e2bfd36844a46eda7abf38d7f67be10ac83438d9c9378d847c0366908f085674e5bf585bf3a525ccf917793c4fade584b0185ee5496940b81f97b6666782e988567a7744dc7514f0c11cdda3989aa0f0a23ffa52c489f0ef902a37e1bfc4b340be760f14dec4772025c055bd7721c9510a268a47af9b5e1e7191cbd9031a99c7f38b331184921489c16ca27b655b87411338b4d1bafdc97c0a246d79c5dab1c787909bf4c0761c90b61bd0840cb0a034b3f428d9979a5588fd73d4af4798bbecc972b55506a7d7f12ccd8827a03cc67e2a32394a790a47b936d5c280c56bed88d8acccc24382bb9229a24076e06b3d46181f78f22302c673debc30b8279f559f644d549d568fb6f9edc29f8db246231680a96e58da334f1d4b831afc0fca32c064c208060ada02628a0cbe5a53160ab801cb0561346570243247c6744d7f6aad19d1904541c0c3436c09c317847df9af99f54bbe199e6008e24b0783344dec16c46478d79947d1519e3520244e7f8785452dc6436d76d5f71c5c8558cf8cbe8d1b56ad20633e3dfb3ecd79708dbe560f2ce370e9636a92ff83c379b9cbe78dbcdf87393dadaa9ba7c8867e9f0726897604eea1f67e1a486678a91cc2ab156c5d1437789cf78124a9c4bd47cf4cf362ba267b345a90b7c3692a9a94bd8bb852ed0a82a63e26f7f93ccdff7edbaf89c5e4957846bf1f584c3b212d2aea4bdc5eb03c5072d63419f145659a18626c6ad0d6296d9aae2a4f95dcd1757b558076c6166f7e99799e2fade3d50419900e96326d68c68f4e8e2f65da342df464d64d4f9223b8c5b67ccff0f810dc8389d2c779208f74bd20c5c14c070436a49d0a9fb2a6c920e19f4a529f143961d446ba7801e1dedb8ee91953327057abeb446bffa69943ad975d55028d996229f5e6877936d9134c7f3c344c9e8dc3413e7c945085c4505948d5942a786400625705247326f850049839907404d4f1c8662e494afe8ae1598976bb998da11302f0fdfc03c2512d51f86958eadfff23e25b52af8b57b1869ef7ae5c71517440811e56fda99a293e25284fa6eeda11029fd4750514ebc362b247d58d4f40e138dddb6c8528fbb11e4d0a9a7bbf1750a26ff00ea5a7412085a46d40110bec144e5b9f7b3b47d263b40aafa10a20b4d5808b6e849a330c9b2688bcef215267e368de9c92f1f9763b535a939950ad559d26a4cb168b90373a8e20a76b3e6bbae2b9b0f23dd0bb1f2cb19c885897d38f0955963defc0a5c8042334215757fc16a8614c4787df9f5479964b5122fbc2ad527e0b39671e68e909013ce247a34fe47003bfe235e51059c55936c92384678f25ee65baf780c240ec2bcbd053dea2ca3c852143401564bf90d688ca753b53c2582108261d7b434e01e067c19dbb916f2955ff9177a1f02945af8604bbc58bd8fdb64dcc372643143cda55c255d9d45c0c5f22cb850d82db31b835d212778654b9ee6df7fcedabe805f8174334c634d1674e06fa7099ffc49124aacf4eee28eceed5647783ab57a8a4c1d8f2b32e7289be802e22ceac8d84f6cc7ab985036b635928fb3ccea70701ce89437095e884fefa680026c210816e48bfa5a58a5d16a0017ad5ddc4aae5b8576e73fd226f5b8fcdd93d1a1a5c24dff3f0674800375fc4c2b3d6e287fd297e17f471913097f306bbb6c4fda4562bc00f24e4c03ec5e2b7c9119d3615ff2f8a67da929df85eb75247d95b32ca84df7be1b06487593521aa2ebd7277d6752930824906ea29773c349db650493b20975749e666859cf4777dc558411a3bded23759fd8aeffeea0d1314544de9b52a598349a8e540e0475052dfe2d6732a1d199a1adbfcf8f31a97e5fcc117d12e2b976d835da33738024af71f2982d888ef6d2bf106cab272a323ae410b7b76295096ab04ee7768196c2fff19dc5a85e8c0ced579f77af06ed112068aa5314ccdf32adc03b93bfe59efe3883c689d28c8748de2aacbff13a2b753ed0e1dfc77e36bdfa622c296b4182fb1159a1fa26d350f09d7fe9f97d1f899dbab72058b046b462da8c71d6e24ae9044f3c6514e10fba9ef9ad459c813ad64375c01294f040e9cbba62ab4c4610a0d3364490d027009aeb29a59d1c1b6175086172c9b64effdcc3cd8b55f76b9721e2d52004ed3f81980b5be5c7d0ef7d5c8f947d5c70b0f451cb9ec663a9b0c8ebc142b05f9df5e8cd7d1f4b45a42b1cd52c4e1b8b8d1a697da5c7a90771b73587c8e3ac52b1e3902632774a3677314d3c8a589ead83b240ba14d75349c112717270be2c67ef3170523b67bcb90e386a355c967c9dc34200583f5d84bccea4e29cdd423045ce32cf7c51166533c35be7a148fc91b06c483c1e3e4b132fa03d26fec42fad2775d8f16ee2cd868a7cce4ec236451a774132135713ca6dc480ed06b79a13a1e3f8633bb3784384c8d0d7168d1f0732405fbdb9105851837e2acc4eb449afaf3888f361f819719939d22e0837732b57f8a339a0b6508e2a0a300aafbfbdd7b3e0cb5ffd5ccc732eb525c50d68defc84f16c61f7282b75ce627d13264c66cfcc729db7d36f11266255d12fc6d175705c3dc882b5c0e1071aa689df0ddf16aca3b5344af711a73c4e7f41b0f99c611061e195626c468f5efea476a2e33f1b5566bb3c91e91672a80b7a43d7d6b95a65edd9a9c9e69ac16a031ab94b326c2c1ff44dea9a8b62849ac91ab7687d3c34222377cdb243bf23c21761f2050da21ec238e024e3d62b94b68810916b0cac6ce2f6c7c7284dd5b6b72da428f4fb28ad3bcef3f3925ba5b14212e5ada9b306be97546c1b1f6c673f681156306e0650dff4406b63a7140c0ac6255b3dbe78d3a09ca9b4d8c0db55a3cabc0e78ea2a802e7f5e5f38b98f4cd3404d285f5a6933f13b4d02d340d5679e87ce3b4cd30fbb07c942f40be404316c9d6874ab5d9c1fdbc4d883fad00999701774bc26e1663fa75f6308523af03819d215a0393ed49bd50169b255602174571bd23bcc8f62860d9b001c8060aa96b93e2f1d4eeb41ef774c66d079f4c3db8be89a2dcbe40b637ada089c5a51f92027cf03ea1c06a574c001fb867166cde9e16299f1a4580d254a79c47be16e9de6bbeb0b50417a8b2fc88b202ddb87a0db4051f846c39a9561f5c924af2ef7b88117e23a12b6085c26d0dca049ff8f43a1bf908cf3f7edbd376f3a3d221fe4b398a8f020f8f62507d48f2076df0e7da1617c5a19af12ed9c22a7f1973ef1aae0d7fed651e5c727e998492467f8ebb3143a653a27d4265b19351a6f1cf95be348dbc17b028e324bc9b954469be4237f78134c1af983246584c0a622a1d216d0921d0217fcdcd158fbd7ded6587ef88fed13df92e95013965c1ca8d6cc410a9a87bb15b97f95476860178665debd1dffff1351cb02fca4a3b2aafe16454ffe6683cd48c9f051d238201a02e55880faf83283e84987a492217fafcffadaa9cd5a5a175f708098fc907634934d249748e7a8c35060b04c1473a90520e3247065e58cc7a0aad85156b43c75c297062a3fd3983056dee5957d015f949d6295d5803115d41075941f20c89e95923a375b5050a19823a08815ce6ccffe3084d406d196b60d8e01ce840d4952c7b28105bcad05f3fdd8850a5788664a7c22199af80821461101d3d85d83028b5306c4174315d1a7b0f0e9dae4afe511aca13fe6fb492a184cba8a782e084aa840a1a38144f359d4b0b67dd3da1a1d7533d93fe955ff6e3deeed07aff850b0dce1b635aade5b9ccdd0bdb8a884a978e428ed242dd14344d9c450f81db22656910f650ec6363241d183b7df53e8fb5248ef9df34365fdeba1c8e0e605649aca56ae63818b6c73657e47354536903fc8e75e0234fbde383596badb49899da9b370f778bc0dd5129f7357dcc89b068b7e7d9547d1b578092096df64569c2084c7aac39c6a2dc28afb2c924c9b87355b97321769e4d687abfcde7ee945c2b3279b007b53dd426f829674cdef5ba2592c5b09f34e844ad08febe7997948fb8cdcd9e45f0c687ccd1c89b7e524d07a07389438512e02dc5e8a5db66cc231f5ec54290b8549e1a584744ec790461d9bc9835c8e65aec2ae9e78975b6484f9e629df87561d14a948ac8af53aea7e63565cb8139db46d691a66ad7a5fefb8c3fc4f3fd1a3264ce08cda8b065bf2312fcea719424a5aae10423c4c97ca0ec3539f3915d7ecb050bdd862a720baab9e989267f3fcfef7dc2d1be24fadc287870e8771042416a46809959f72016c3c7617ea7736b49ea934c92dfb5eb6ca1876abe105221dddeffa6fbaa0e94d6fa11b8f435274537289ec913c11d79160a2bc562760cca54c9408fef81500229ef23e4cdbc62f6edbcaabd1efee52fe239c2e04da6756644346fe412551fb17404a9c83ffa802c52636770d1c6c203474c48ef9e8172e2b1f5a70f5219f1e4ed48d7615e440df292355fd4d94c26d9d02d39ea7efe3e80b98c28b294480bfe05b0d6c0d868d7f91066492bbebdfe9ff0413e70f7d53efecde533b2fabd343570ae4a39ef0e01877efcf369c996c96fff0dd8d9446fbf594fb62e0b98cc1b7bc0f3189a9f9288be42ff55c49f0ae37f4bc08e7f6d4c5172afbf4364a6fa052c70f15327a3a96309af43b3f7e4eca72bc116b56e20eb2f10f343e15f3615f553b0ab7814fece80c48cfd13f4b4c492d83164f55b1e24575b71d6f98149d3b54c7a27be9ec1fba6108d2739aec741241ce99803bb59d569136f50101c783918ccda219f03e0105c2797adce155c8ab711f9bb2564ea796650c44b072239c89b902081513d88d8c316b2ef8091513e32cd86a95700f932e7fae8bd9a00fc22758e626158b180c4db8ed8e904d798572042260e4c3aa09d77c2d297359f6055e78924468d3ea984956557ceccad1294a632732b2d80f14e7f301f321eb9837212a7db30fd72312d3a0c63ecd44aa83b7e72b65401b6d89c2c1b070a942588ba0ae2fa77c89ccbe7a55f487a16f26b2596477af567f11389f4748b920bb25467c65a39b3df6d3f4d6a1b0be0563ceed5043d839f8c3c9186169d2fc313c749b9feae01090a47e952e2350f2061a77d458341f1bd18566748ee4531ac10305a826962041f79f49d9a981cffe93630243d8851acf24aed8c7f6f66da678e7b36f703bc95fd1707eaf606d22f4897b83f4eb7911c9654b382d46736c7338a239eee8edcf694402438867b6c2b07c38702072fbec57dad334239aa2c7722087b785b131f0ec6337358ac91c1989a50e49eb33fedaa9df481017e83dc89d20d065016d2550400667f1aec4a57a82c12ee7301d5fca5c4d2c86ac2460e0bb510fd1df14809975926adfbc39bc7714dae764fa1dc919e5ca0a29748e5ffd805749b1f7db5ef5ac171d1754ba3d0b716f9714c2b72f25024efb08d211bbb734ebceedc80999237df48b957929e6e021829ce940aa5db7d6ff3e6b795fb3bd2d8a0ee1ae0bbcc68fd5281afa32a8f49153f534268197eeb0cbe88589e446608e106531745ebd220a15d069615e91493dec2a09044643556242baf5c15127183157063662fe45831f1b03e192236b67892736ce4c7f5b9539202df4a1be096d04caca519e4b7952417714f79344f2524a4c100da7c035c53b6e3d889e91e5ce51e30859a418cca4da38c48ab789fb879b4b78bf19706214e58af846a478d0f5432f0859e93caebcb404a79e4d121c14261a6fe543f5e23b184960e632523310e6c4dad555ce2b884ed8cae524dffd9948d2876bc422100a6a1ed236b3aaef8363fdbcbc62f8021a9d9e583a7dc6ad49a333b99c4a50e898a0d4ce1fa5a884cdf63ed8ba8a4abd3de66cc95e671b9bf1cfa055e0c1430ed8e829b3177c77d0ed12ed97e89e4543d67f6698969290a3012a267d38111e56775cbde2c26d92a230539efd5825a5a2795da2c79991b2f936ba9182a4ce892b96ca4b7fe0540ed60c69100b38eb5bab6f911edd388cd7116bf4708d19f8998ccdc10c134e005db9e12e05410f8a17e32b79c0897778bbf2b3b3e088adc0ecdeae110ef1e72fb5729153380c7d57cb1eaa1185e3975a0ea04db5e904da85e8876321394a5351b9bd1f47c5865d0a05157a731bd99634dbce39c10a73eb219f2beeaa1d1cd2c3c1e3e0b7c2ea081b547aaac44fbfa8b214750aad867267dd68922bdc98483b731c72ca892642de9c4799d60c49f98c3ec5969366e71bd50259eddf2df1a20cba3eba10f8953763879e59ad212a06e1c2bd3cea8697b1f7b8ab4fdde95f6a958e79303c9ba3b636491e41f3ba969d23464a5f2bbfb6ae1b1abb9e8ab24ef8f2f50ac4bfb8d7de6db22f00013aea9791501a87a481ed947a6f1526a0ce947db4701b8f51bac8f51cd25c183173185e1d23051eceea7120996f92da287e6e259eb43152a137365d5fb65016575634f0ad8367fbab03634f1a093043e7af055947b76d51427472a0d1d6289f3ce467470c2dd19230c7a9d721190b4b8e87498c7fd33a0d6bf2217a511a83e3f1d954f4a2f261ca2a5b3aeb56c027fcd180d1b0ca68fa6d8f23e37af165afc5432a7c55d4845e458b7b9ad74e6a9c9f3732646a6239ad439a5c25e66cfe9f14f783b497356b66e75b92b9a5b1afd9abbae687d68fae24193a3317afa8b6f683a72de61286aa8808e6ea1647d3fdcfe2b84a0ba61a8e25bce60582ca2ec166230b88b5349d80e1be316e7b3a7e68db141d2d9d9fd4a7d5f9877669fd4c04bf8676e18541b63fc37f323f43b6f80fb8c5d1dc2f109bb0d6e6d4dbc17115c3b98f812a9d453b47304b22268d5db2137a713281f8153e6815d6ebc83eba111b20ca4e122110bec4c59e4e20bc5d4d8e24a3f958bc71a8271eda579294796d9b739a06f5150f6092af204bbad678ae3a52f2328fa81e7ce32f1bf295640e6754c54d5c8dcd3c0b113e38a22d1bbf83312abeb1b618d97f9bc46faf0b1b81a99261b0ae1dbd8578dc308794ee7afd21d8d3790a61df139d78208f9d90c9f2713d2a57fb3a17ab41c7437944fd3320d552aca67a7e7ceafae67250abd1536924add5f68206fd54c6133b5d95f7c2370d1d6f85e022763adeee2d4307c10764227e42bc54dd8d8d45045c3dcb3e908d3b5893f5e6d01bf76bbd57b6a8ad4ba8c9a070583ac3ee7dfaab5ceeabb1527014537d8dbd4ada5385b9f847aa0bec0c4ce4d2c60338d7c16a3d979db427ef6c0a266d908b1fb693989333efa8dc80bce72b17f053a421c62ff1cba977885d71edef04f1f8a3cde64dc8bac288229c1b0a765a4c07f98941c50cdea0c9af6d82ffd452a9eee98c852e632495d5e466d784d8d5a2ac73cb2e3d3bbc5aa31af1ca55de78b3bf6208e1936554bc963724f7bb390c55918971c57185ee6fe524c830729f7827475b59ff6d7da2490fe20bc774a0589593ceef3b2fe95892c024ca5d46043f8d8dc2dd693acf107955b6c5ffc803845b04e1bc0c1da60d073f2bc2300bc5be224dc0f2fba3f162181d2d2a1269736cd9f23db684d76ed4daf0df06e53d5d85ac41f520971fdc5bbd5b54c1d3f632fb45da18564edc3e0487e5a951159b94c8dfb6e70de668b60e19907b3e98bd9a1c2b0912730b4f294a36585f90a3edd7c87d28af4394b5a829281d56ce105b3d05ee9ed2726f69dc0c955f1c1262cd2d542bddc3855bd80b74d87eec49c40df79536023f2eabd166e7d899533b7ebcdc233e8b4ebc983c378385c58bdf7a7d5e36bd502604b5f4e3b14562892c07274798ad922632b3ced37fb13fb3e1dcbfa0a315b22881ce956ef97b8f267e9783bf028af554d27d593ef3853a198b22c6dd8fad83da3159a7b17300d33b1e78cf2c9bbbe6c367218b91683e0c71316b9d7e793a7b738c947cf51e29ac2f3978a219179b24bab357eef4706564aeb813659baa8611139a6319177ca7c21976125538c9d7eea89f3382f421ad04d5518be9da70efacc7f1ff7c814b0b10f3487f1cde8d17961f64ee64a8948dd3ea6cc7acc48bd10feb6b120edab94df8c560427babf2c31f13abb43481d6361e4800b6af1e2c5e980df0d9710ab90c734510e2787a12d9c12fe1e32936d1bb2de1f062d4196553ce39b2e887262c59e5dbcfa4a0c3e9c64257a7863b4b7a17c6cc6f9db03113ae5d0c331c79247574da4dd70730eaa9dbf39b6ae55c56ac512dee7d0fb998ee661b1d1248af1feb0f3ea6f416c872e5a4689c1a2769dbf0b7bd680215b6034b041acb33c2f428d6b00bf9c7dc04f951731032e842eab6f5aba3f17d155ff428967714027447d45df784b1f17dfa0ebbc8001a2003dc940560e705910df44ca509db10ead417c4e8288ef8b8e07f4a7c046c268dd4360a760a8162984761ebc509abaaa0f4450d7296fc4b77a2302d6bda0c621442e7796425f7d0879e7200c0fea38d4df808e6e6cc0da6b639ae64487db78d3dee2daa0a4c46dee403b70cef1a1d6adda95b79cc2f0ad846d3e420fe79235b6330ceaa24230050f852b3247686d36862ce38da9efcccccb99935faef9b5fa9d5ba366321511bf60771ba100f806650b586afbb05eb5c08b89361e9a318656f809bc457448ac2ba4e6e779d933e39f43cccb0649d07a6c138fbf7c06f4916877b4f74c237c707db0f0077c82d7169d871d8d33ab502937884d8fe34d1e62e2eb2f972899e9b2ea95c14790710f7f6f03a9e9e7ea4bad42a8cf9ed37118d4fa346ff8810466fa75e6ef112e712aefc37e140950a2ad8b846fea265ab73c46ebb3e87c8f17f65f522481d4c733f014ca6eb7d2a62e7063c88dec5df41d1797f374f9597bb91274fe2370ea9b4525f050f27374528091bf29a8d1f5f01c8672220a35cefbe576ca9cf0daf2a5d07e93dcd46f90cd5397c53482af9d3ebcf1376ab527a03239e59990bf6e436b16fb276a27e692098f7dca330f19026555dba241f212d5e703db5647b6d65d2696142d294a85b956117ce80b7a30dd8383086506d19aac5aa5d76af98946808d7c0c48e83816cc479845e1a8ea030e707013be2676dd381cb6a8636a1b235ca706e6a5b4fbd2863172813eb2538f7167d711db44d08be3956858e610099cc0971865950fa4b4df6d1a12e758d4a237b2f0062386abbffc3cc0c4e02ab4e87bb8958343e7bc543693eda463f4a4bf37ffadf1dcbdb16b38f602073d2fe8b4447e659c509ccc961319f5f04432bb39de799a36d5f5e977952f1880c03a080203ea5324ee6b8c7fe8da05a93ba0e28cba980e34f2a4c34c6139f11928315d4370867afac5a69797c2b5d79e2cee331648291f338aab50462cfa09f8c7d1b5ab87e89eedad01742711d600ff4ea3db18dcfd9e6cf16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
