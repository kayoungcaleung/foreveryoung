<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>This is a test website, use the password (not so young at heart) to enter.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08d0e238da5200de50cbc717922b9ab15dbbf2fa361ab339a4a39f3edbe6a0fffa70a412891ec7c721f3e8b7f238d2afbc1faa23c0e98135aefe7a0300084cc1ddd730d4c7bd91307fa413cd2879ef4c646e1f444b1c337da253a080da3159b35d3046ba0d6a2062726caaaffedbae6b2529568e1a2b179c7057578f29d1826ea2fbeaa1d0d594f4a5fc66818b999a907947ed49754abd56c08a71502732bec2e1cec14de720fde7e1108584db85dd35e2e261308d1ed54a10c534c71545950d1e061de3ed90e690d4f69fd14fb077015f05d24a361bec2a26fc826242efc418143f9b5ba9878fd49b35ec1efbbf44bf5c0640e6f84c71c9b2e5ded10ef53df958bff548b5514c25826c33c95d2c939f701beec75a149d3ebd20ff6da49da51b6c0d884b3624231f3d7b11aef7f6b5bad8b32466be92fa098c461e9bcc8798901aa041caa5c9fcf36183b173ee799a0efb17a8a08ca6be2d364cf5dd0c43e3a1374f2b30212e740811be96ce902dc3a2d3f9a0af486d23d039d0f4882d05edaf9876b5666e8af19944f9ec8e05a76897dbad6a33b1ce84309868a7f7b4977c8ff0f39a45be37c0b1da192c1238e70a2f5a80cd39bd8ad16558e45aa1d408ab47c8eb7251b46dc6a7634db924f2b8ad2f3600c1b7388d4849beca9920115294f12051bc0402b4a004f4b592aec1fbe0e08605b75080388b2b5ebec85384d57e528df7c40f4fdff5e92d6e2b40aba21742e7c8b594a35950cb9ac94c50c39a7623f6b19b1d5e290f6c6cbc430d1df849c6754c104d16b05e41dfff0acf42b59875d7bd353601793607bb93d441b130103f2810f97892d36c57d0bd95bb4b5a320b2a2878daf1c11d7c19cd89a19b38853d4f836d67d69f58bff753507a6abb19c82ad6332925c6517792c5fb4c484c27e9be00a86cdb60c8f69db938d76afc49566ab3d3e477132310d9eea7f3f64f139cb8b0c150bcb4820cc3be113466670a5ef30b3e926bbaf2c57868c63ff6f4bd995d4f547f362cd90895499eb2671f13081bc6310b90ba9b79419f1e6f38469d2523492c6e790bbadf73d482c2905cccb4424689261da8401ad1da25f97ef8fa8082a97804ade3d98a0e1e7f31d63f2e82e4b2b7a5d4939e2b6b5a8b9d1d4dc08cc0d76ce5429d7e53e556408aeea83a869cb93a88096144c7322961b5a6d8d05ba5d57ae663e60c4d92068ed47e9ac6e1bd6bb59f991f54fa066501822c98426bb9277d36585acc693c3d081e8a167f6f7bcb99e8f7c4427f2b4f121a23ba5765799c0977514a575d5140568d6a92295dd3185edcf250cec330fd716e877d8f38e0349dbf97e939a80b41f31ca7a74be9db3b2002f8d5feb06c61f86c73b74b5d9f36ea363f3383810b7f743c28f29dd2d6cf9107fbb8b2b4e1271af1be14f5c0ce7776291b9e27f6d3015388f95b4b2bcdafa32fd49dc0c8e7eb3d738484f2fe1735959718383ae49a29d2f2fa5c71996cc3f6c9c896a37a037648c359b67a0f847c32b7fa0d3d9cc5985d9227ce29c600dee539dde32d2c574bb3ce4927b6c2111009353e5f484d5f5943a96a999e7e9bf0d4049bbb88a883b981208aa78728eff4e56635c625245b05c563910565e63b7c54d7ccacd3d09a767ce373786e30d63fac4b6d5f5699d908f7b73522b109aae471262b2fff276b9cd20d44739e40bfe21a4f80f52d0e0fade7d857e0e2ab9cba40c98ab99dadbe9b38a0823d28cca96ed077634a39b5f768f0a014e84b2561e5908db43aec8cdf8b18e7b8eae00e48d6c8dcd7cda5ba40713c8416176bd4930e451c6b14138546100c3ce2a69d75f993e55f7d3df011e808980eb3043b1425f1d61f542c7d405c6d32fbcb99a60c910e01506462aa27349194b88ee7d7910d364e56031bdf52b60010c820831d5e6c7829aa04e474d6fcc074544a80158ce743dceba15a9afd4af44176af7e7c2d85964a8601c38607a415120d4fe1c422e1025a5496de37e35b6a6487b153267930158fca1d0bc53d11303d8c13ec3849de9e5c7928232eff0a0a4699fc17f29ff3659927040d5f018e051b54ed3956a1a95b21d5f708d36cc8db3251f025e4e111946e02a3a26f0daf89dc76404e788e5f94ffc2c0e798b3f31563495cfe1e53104a09dd6c384e6523b846d02b91a980d44887b247db30e7ffcd5995a5df8d288d008b5746c3614fecc7e8277a76df360fb4ce6aa9ec9a3e519b52f4800bc43c28fd86de62ac9099eb5f129bd7b1a25f7ead5cbaa8cbf3952435d187cf2e13a650049fa106c713387deb8b00e6465de23dde84272a3283d190b4f874df25ce5d7c2fc61763de8f037e587ddab4907e20f6aef5455f6686d6322c35e2a75c89501bf03c0d8fc71c5b7c8c74ba9ca881a6c9b0562cf81da729f7907115f41fff9c0576a246ffbbe632c32f889ef51135c36069e6a2597bd96f1366235e53db197346affd5fbc81773839776ebf0fbfa896826c3aa4d661b8b60248c8735d8bca8f0c248132094a6f2ee555dbd83c2d667c502b7912e12c3b3975ca2f779f4dd55dea03dd94d687d5a4a1173140036278d29208e1067c19e51c3a39ea620a837d86e991fe7d752a81b17cad4d15e095c9656e86692c7102c96965dceae20a8ca692a03b39a9cac6cc5cada83a54ee5023c7ac534fb23f24653757aa43750f7fbf2edadcf52505203ac6cb7f8153e0bbde6173e52f4ab192c5f922aa92ea5a64426ca9dd0f82cd6fe9f0881025ceeb232bbcc0d6bec32f7685000d3e711d671f6f923a6913e9655e2f03e39d02610b2ba0294255fcab68d8c2dfaf07df1efea8a9407eb1583cb0bdb41b6a4ce58fbf6f327f5949f5456e486296571620d54a28d6bc46e1eeb8b928126ca6e1f32c237ecc62270075ef876540b44230df493b08bc3396fb2dc15f521bf639214dd787f8dc905d8dfc6f352da8769128ec4d7fcc2d3696287c4e71311a596a4f21efc11c8cac4fb9397995a5a1c280010c911820159d3468822a1b5e2c147a05305516372b76a532d195d4a9453b88354b0d03c14ad2cde619dd6115c42e4667060305cd565ac15cbcc343cc39a1b5e5e784f4c6827272fde83a6c2d14c262168eb5b7d2d798dc4674cbd31efd234ffff5e9fa96664568b7280ed29319c734b62511905f8e2c5b16c7de8a469a91759dcc86666da31810aff957d0d9c405202c5e03ad3fd6d66af143f5e6f01fbd0e4e6a9a4d7066aa3cbe950e790a9633c81bb5f38346428d2acb06e4b501d5ec283e2881484e0daedeb679ac9752fc32f93120afd51268d42bed93ef0c5deaf4d0ced99d57c91a78a0bb219b515dd6714acfa399bcc36fcaaba9f05507418066f7066629430c34d639b7907bf5c68b80c39a2cd9ed37f11bf6c183c27661f4cfe3e40df67dfb7167e4f6fa5e565adb1fc07e32fc1ca70273112f23c29990330079a8870790c295968febb69df9db68b746af2ea8bef5076a506c1328f67b14cb7378d7bee48b287974bfaba95047502124959168080a7fca4e6002f090db8fb3f535c9cb17744c97d23a7376d9be74a54f4008c341db464304f4fd376b134712f9e8838a249f9151ed58bfea716d8a05cfaeb573199e8a3f820d01df79949d36272b241f7ecfd6d2a9545f683b53cdf9570e0b9b03b80628e80810f69cf41fda593fe56a426ca0fb3aa4c9dee153f1ab13bf1e984e1868029d745ebf4df3a0159081611b365e8d08ed46b4bc32ad3937ab428de2dbe65a964bff0cfc9f9492c7569ba9cacce90b3d2c780f6264eed9a34c16b787d4343ae7b7816793314a02eedc4846779c0edc3f97a6db0b508440effa37ff20ec86ed2863745ed8db46b33836d275ff94cc20be0ee34cb878bc080d0f7ddf159a83a39add8f3da731a28a4228f2bd9d6803065409aa64e68f42252c41e40b5f043da5a989aac1b0c5e87425910c49cf98e0d814c62e9fed221be9d04e61394e9c210bd88b735502a58fb408383156e63436170e125dec4cedc37a372e5b63148953e2ef418dfe18314c73e3bf072dec1ea4702bb3941f61f8ab3184ac4df272169bd6b23692ba1eb5b85aeb5d84fe897ab593cfed83fce115c247f89e91351c387c74d6f38d75a9c10c0e7b365c1623faa37c13809830c57c19ee57637781915567a1ce4a3f8ab990285cc9b856350920cf942a35456ba8b278ecb74b7f62d56d7913aedaf339b5390f7cbf28128b4830f5f8e5e9eecacfbaa6c33f47da411a7d382ffbd2a72e6618e518211645e7dc79d100c600bb5b08eb81954b496b60b378eda571d397660530f27256f04dad5986603675056d3f46cabbf39962fa02c14059461c8d38ed2687b193199ca95441de95925dbac479f9500561a982928d47e8d81aa48136dbc23ea2d7463cd891d67482f2e42a7bcb9e4e5c7c39100d53ba7c48e353f101f7ba238477246de9532b8e899b3b38440bf6cbf80aa92ea048d52ceeb8f96ddc6e2480d2ff8d29e5e4526448032e3abff0fdce330bf26feb56c3f67be190adf7aa57b85543cfa576e14aa15ae3e1130211ca57c32c2c977075cdbfeb90b40c43d118a3e3434d4ef1b2e17bb1799f35829063b9a7907824c17eae8e147a729a499d5c69d72989b02f50eb2c740df891f43a05c280260e88749c646bdd7d5220075e54da7b3e3b0e4eb98372dff643907b9bf9996b38ce0af7d3e4ffa4204f9b34105a7ef18c4dc53d32e228d6b1713f3ef2f58787d512a9433d0bc64348cecbb15d95fc6cd6d303a67c6756c25680971524c61d27f45ea2877a5ecd47ac9b3fa0c9fa734b0c9f76994e322ab692f4364a1ce9e3f6ef642e8a914125b045065d2da0b9b60d271f54346e64f02149214d994ae3df68568cf18b3f214de291c0701c4ac624ddaeec147ec6042453d44921bac90584929b869c3069669977964a95f356c0db44aca0721262be3432f320d7b70d2efeb59708c829e6fa5129cf9f30dd1777a47966db51410f6daa684bf0c59614e06066b47347f96de7d4d61753b96641e3ca7c42663357e895857c15a6dc02e81a623039d0d23c9779a8f25e57a0917f104c63107108f960eb928a020a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
