<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c8c24bb44f970b5ae941b1a23c7305942b30d6580331a93c3ddf03fefcb2d3e61b8c75323a62d06195d713c4ff4078ce891e1d4ade43d89d7880613551f771f6b4601d9b78157015f02dd29e37011093aecae845bd944f957799bde98d9edac48aac0963a1dca00e79167d22fb7011cc4d3c1860ea5a760d3c6a103c3211baca216ad2f7c807ba8bd57cb26917b8950ae45f2eecccf4cd3e13d9e1925f403a10ed3eb2d5d1011972102b7a11ef2f6197d2a717d4cf600afd92d32adf5fd5d15d02b6b71cea5e568a1aebe48b979b41278ddac13b2308d9d81631d799e30e8cab6f7f94c7e0cd9db7f5d1276c84276827650bb2acc933827d47aeede3a459ca3738a41405182d0892cff1d46a1b7b5e858fdfd2314a923750e5154d7f9ff649a6c797874eab751bc37bbea8f89b1e83db7a3fd31ebcb1c4137c02005b1d2b93495f5d8df5f29702ba089127321319ad69a6b695eeb764b5738e7208a0592131da596e2a652d9f2d01aa29493ba8f6d935d34bf23f2a7a2382e017ad01032d75cdece0eca4effa0afd8a744558d17c2eb13660261b2be20ec1fcdc29b92ce464772f659d766f16f5e35160b1a5aaef6c3b2f1c99d86d3c5ab26c4c837eaaf14362ee30e54f0fd7442d803527ea79396beb7e49a796248fb98bc340297fda7bc6b8dfe84bb9f13d2409ec4cde89309ad5a2d2ab18138382b060efd6f2b6eabbe2ec1986e8e58cc5a4b5854d954b59539202002db47dbf15508c2333422b08077c0f78d3d0ec812ed8c78290b4c60bf15f0f4ca062efe32769149825480c5ef7603b42bc5524395229825627ad1ddba7c44910450c7ae2831c7d72f7078d619871a6acb14d188b09531635f40136910cbbdf848cff38171176ee6f5af467b8242684f7bbf82781721d0472bbdba4bade79b997397e82f4797fa1689f69d627d115d81647947887b6e4646c5177d544b2fcdbb74e9b7e15e4c4f8e6b0add0a2dd4a4248ac051fb91fc846a4582f02538595db33e6bd1ee0683170a1e70e69b1e15a1a883e668d62d3253b982fccbb1249f0d57f2e5f34d4fdd89e6cc569e7a6ef483e095a574e043e27a90d0066fc2b27f262c7671382dd04f720b0b4be91e38d8e15011a4f04e3895884f96325449035d8278ea9f907c8ce1c40c6141e5cf3463b2e037a92fa48ae72999eea10fe6db213e5671d8256e410db6fcebfedb79cb6047e19e757524002bc36bee13c14a27505f5dfa211861c6809221dab0f05d8d52c6a43b0da6e1a9c487be0cf678b78111184ec3d3f3548aa99b71a267c2a1370cb562877689a982328e63cc80b9d53bafad9c54bff51e15885aa85ef5cf010122c2a446d2d13acd7733f421a1d19bfda4edc1efc5b2f3c0befd155deeeae32b07b354aa2320c1ba4f16c8f9f687560596c2952d118bfeefd627742f1a72bb235df2359b7b5f59a1f33dc6cb6b781efaad48d55d193444d4abba04a3bb5bf107f88e294d6726466db2a6b83eabeafe587a1ff5b24b85da281825094b66dca715422ae6645511df411f28f2d174f81dc284a9c4e6c3e936d3e6d03b76483d1d9576a1254dd29e5d9ddd1d0afda024c0167807259e2fe5ebbb549740bb05ab17825652fbe087d1bd93bb95a5649367a5c44ecd79d1d44f10c3ee4b5a910da4cf174abaea1c13153378fca38beae8eeade8c149e270e45b59d4719e425007fe26d4df2e305cac59c43de0262f5e22602910a0f7990772d70ee5730d93c3c6bb6fe70760817b76c192cb1409b53ec382b3a17ff11fd0921b1ab0907952eb1974743462460d9c692ae97eea896aee859c42638003faf6f41172caa2378fc859c25e8ac9d5cd5342fa0b542dc68fd1e784b45976b8b11ae0432f499384c7f3a6a374563838f926da0c986c7b82aac79b879bd67f7ac1bdd7a78eca27c8176e2aaf776b66aa6796df809eeac8b51afba7ac6a5b0584566ed1c1332df334a97cedf72f402440cc9e3084f09346384292724de452d8ba8313a74b313d03525a733bbe807ab403f2575e06baebaccd41af20feec5c61361bb532f8c1c82772732a2e7147cd01e7c70d77105316b0e0c4303d7faa36c66f8540122ca81707d29dd89c840b190003bc8c9fa71bf68f21e835974497b033debd4b983fae22ccfba2b8b56607d058bcc54f2a921dfa98cf91c59d1cac07be86ececdc81b03a1e461a4aecd23a6e81e2e0afb05ee6e64b85f57cf4cff537330a612d6157386e82682a3f1953ba2056741095f82ad0e03d0c664359772543f6b539a65c2d753471c0c676078da90bf0fc3e0c5a260764263e468715a5f9a0372ec75f7c7f2a43e073e8b9f7bb73d2151272d5b4f7b2ee5147d618ad358a338ea1b0e3134be0c572da7cf93367c7d087d064328aa6ad8f6f25ef259f25467b26de003aafa4df64ffe48bdf56619ee0ebf4739e0ff4f8ef68b2df5a826bce8e3a44318787193afcecd44127eaed27a460716b26d6910048e9b468a8f67b7820510b85fe63b609fc8d91717823ead88f97bd7e8a763e80d54e15b6b278389286bc0bc3e807111d879b195810acd07b7de0756bfb7e7f0e0c9df701b963be82488949c066ec45edbd070499798c7aa33904c8e8ac36fb797b94fcc59773a9d6cfae010a323f077bbe49c378f7140d094ca884aaf80a20c116da53e1a0854b86c30ae9e3540d84c1819c4ca9fd9a7abc39fde0205bb13a6b561ff9ec3bce87da12350d1bec7b4b8230de2ebed0e965d41e841024d03b167c1a9d14b1161339169464fdc8de90df376a2996992652bbf1ebf0c683b776adfb98e19361bec1045d06d457ee272e89ac001a8b7cacf10c30214fc89dcc2207f4df45a7e320605bfa942449a1118f8b8c0d029cdfd7671db278c0e2b57f37df63d2e6a42add49c910db7405925df920d9821687bed37d21977e5466bc17c1b4575b46629ca5ae60058b40ab5fd5bbae1ddf1bb8a7c37d4dc8982ea35f5532a9787476350cf4e84e5d9723ea3448e504f056bdd9a06b4f7247b9360ac9b7095b610e87ae722e3c1a088c1e5bfb89bfcb0afe066a73be2d510eea2a67456a6831cac3e44ad12af15e76c68dec8e3c9d79e04677eecd4ac95faa567bd0a1ef07998f9d9c65e8e57db46ff11a05442dec8240dbc6b29f81168ad42a6feebce736f7a2c3686325f81b1ad730e88dd0325c67f29630e1b6f5744190cdcea78c077ad71c97a1500851a50e8ab49c3117cf243bfc4869f0cbb35868e667d92340e1b328ba528320cc08d297f805814513f005cc9f6e0b159f93f6bd4af65b3d029fd972551176af15d463dd746a5ea4397d948bee8254642a441cda62e1c0ca963c186efd4aec493a0914774219c6c532d6d028195d00260b0366dd7775dced4e3d2f9faf2a2081da58e83232eaff082447104c84871f25bc60d4be1a6d24dbe23e42bf7d317c978dc1cda251db9300616dfb0faa1d997791ba1b66e99207b0189d61e6992353837f59b0d0d932fdfd563ca8ec3e1506328b8f00efab08a75d8324a9cb3978a54f3cf30b82642b24a84669ac3e49ce3509bb9bcf17720c07b708df6e1f244c4e2a2694b759fdd8952886f5f769dd7ec34bd58f61ec874f71144dc08ca27f4b364174b51be5ef178ea77b4dc289617a652ad3cb2ee3f88f1d5fb4cb77ba39a8f22743a920e8286fa05b18a9b50dce709194024f3f2dd9d72b52844580d1da9d866d92f94117f68608e87a55733c514c6d21d9742f7695a44ff33c78d861842055723ebd0a9131a30371db748c6b7a0781e528620ce457521459f3bdf314741b89460f52df7ab51c32414ff21ceb1e6a3036e5a7f42fb18607d39f79d597004b7499d041ff322a62c63e141d890ab730e4b62ed3bedd3a6e047a2920a4371dd10bcee1d8e19d6b648e12940bc49f3d7da5141e770ab78aa54dde11a67d0687d1ebfb5572e06e74e45e58d09fc1183fdb2afb190f6e1001abc996b3b3d9e5edd1a3de5162471eda9fb0b7ba8003a26a9b24191fd17d928a4159ee6ff0b8174daf6039b7a6d72bda4b00d378c267a61fc9c34ec46cab8f3facf78f8c328903321079c87ae9f41e7b71adf962514557641926727ee0dd1cb49e496a6da2f5fdc24e291e477978beda017bfe91f0726bcd4c0f7c623b5520b9456d6a4997503b527ac9495b75203d70f436369d6eb087dc331a3ca0976ab5e4aab24404bb4719a0b0f2fe6c2c0b48917455298506977ab1114d57a12e90581fbeb384159200900476904649068d16ddbcdace59f3281da611c8fc025a5186c3e7da2c79b5481125706109e84cbb2823acd65fadc434394ed46ae945d83140a365bf2292d32098bc0ceb76462ed2819769547ce6f50bd2384b96ac10dbb6b8a0c111c959782175746cefbc710da755d693ebf3774aaac31db66017280c1b24760d5eed489478a56cd2b9b8ab50db6b597774592362128bdac6c2fa3e731e123faab8b9b2c9b5cf6382c04617cd5155aae58e781e870cc3be0d6bcecc88872431e68cc89ecc09966783fc86c2a3497744b584825c62c9e2ec9f997a5275f61cf67d13d9032d554f773eafe1d9b0134273d6f81cbf9002c5f7bcbdf217d8bd024e1482332d7ed29c92e1adf79e34245b6ea4f10300e5f89d82c5bc9eed9e3a7c341a36eec1f94ffbf1fef682de81178b0e1b79854c29a1a94a21e817128a3be3192013a62b7a88dc56da86ab991264a708e4f93f783c61833706984086c3c6aa7f1dd6a71a3093c2180abb9bd77ecfda56287965589511dd14017073a3d121a40fa46765e84c70cfbcfa859f76dd878370d6cd0d08c5da037982335732314c291545c1c752fbd1c27f3ae1ec4ecd5ae35948319a01678732afebf6da1a2e5bfcbf0a16ecd748d110fac49aaa6d914fc8bd19cbe3d78ed0dfacf27d43fbe66f171d4c9e85683a1f17dc64bba726d871c7fa9cc5f73f5a74af5e3b3ce83494240f21808e14c77cd0b0d782c6ee6bcfc1e3e5d5669477504f6341217c62fd988f1d6a6133d5e219a218078b980f16d650bd9b0d18470cfca87013bae21494bfcd1aee0b8fb54eef1ee12775a611937d068c262b9f09cc73a8039b0a2496a5f30e3f9d371c775e57e87170aa76b7239f992c11ba9dea1abd89a58f73d3e192eb18f6594e888c3e0ca29937df49f22d887d4c52e489a28106f5aa96e05e94fac140e95f1119a40112deaf166ccb5b4d3bfea6519c9e6a9560df8cca1a98f10b8b502672b90a8331e2638927cfd23c1eadfedf61e8033f1d58dda22acf5ac3a4735ec8e6b62c279dd0f47d4782f8c87721bc0d01a0247eedead4f66cb86a2d8ba8a9d1ab200cdabd6cfb97db3e192b8c6be69dd0765d23a1f055b469d3e0a43702f16a7ddbb8c1928a500df62a594c8b54dab6f7e61b258e5a4845fe2318b075660da89d9faa555ffa2593d581f1f7e787fd3587c3ec813620513c933ea188901fcd336ea33dbc5c536f7b59d7649fe81059f6ce1335256d7735aa2ab9cb957084d81f3c63fb5d752e7e7f112e245c9cab11ef4be1f1834cd16b7735e07e686bd295f8e25362aa5cdb7eecfc074c158d607cb760569aa09231b49202e245e37fd3a8c719e295eccfabcfc6791481e1e00f0717309240f330f9e7feaa290b06cb0d22cc6b908803e9a7daf9323abcbe702c3a875dbe6c21261e3954a481cb0512f70a8723875f1ead6e4268805aed0ea152d5d2c2ed4d35e2c827f86f5d456b8dff613f48a0926ae50eb6e1a8ebcb3091d43b83d8127eaf7fde269aaf5f2b68a5a65c8fc1083631fdd2229dd2aa231db6bc789a562a86c4a4c7c7f1f89de30fd58877278b371a55e66091f7e4bd9843afaa10cb44e69dfe9ec59be3de9f4edbc5229548a1a912802d571c1ac6eb5974eec7d4388d215d88956b74893042df8e33602818aa56487e17d8b226f186f604afb45147d6a6f90cdc7b814f16b8da813dc57914ec184ea7aa32b1cee8bcc5640340b3818e6d7ff7798107aa002fe0bab3056d043747d2dcd5dbf8aafc85f862c2d70aa466e32af61b3c5f99db33261aafee40bca233af45f289ea6ad27afdf28ce23399020f00254c111487c2d2404a4f6765fe815d41a4545b799e05ccf41cb8406c1c062e1f1b333ca84f98a2cc8d96fa659241cce0521b27bc822d5fa0f2b33a867037520c2c8c992ca438046414cf53dc5065593f911cfa228056d29747ab855aaf7bfd7c52ef85f06f8027c1d47d09479ba7198b164cf9fc13635ab5c0a00e8064f943438d868a9470e1ea7aabea8732001c3ecd28bcc560ad8ea0058c8a8628ab28233e91640f227337d2619dc1c4afbfd447b55df1c0fd476041b409389271fdd5eba25a373e2817fa743437690a12debac218c5b042d7f02e363878656c270094c1d11cfa04f6bb07abb9caeae715ba98cb0cb8b29476a97416b19659f36fb4154e058112787f64478b156d058acc8628f754646420ab1b9ad24933e935ddcea2a1bfd720a09b31a532c8aad6edfea89e2b2404930fa9eb771f918a909a081dc189f98349d532738ace59a238e85897d9d93a702a58f80645541b1bb72faa6c5e0c43f2414ea61f7c26cfdd48c31679f4ef97208058b7b55b2705eab4d02008f9c51dfc60b30556d16854fed71497c145c8f797772bf05ce82d18e534053de65d89cc1334f5d78e069fe0f4c859dfb997901125b5a2bdefa8f86a7b41be41983d6b73e8ab78a8f9bfabd65a53835dbf884aba661512c75c6fdf557d68245a7f65e977ca3ba3f291007f236cf18a23401419febe1d3a80c6079daafacb9ba60e11f2ed4696b3bb9080374dd2d0e16457d15bfeafd68dec82377ddcfe5178f26769b62d1ba92cf5c1186142e16ea021fca41aaf04b0d31d93c59807396980fd6c70f466f1cd1289e1377429f33cd3b034d16d8c3b415649ee879513df69a2fcbc2071bfbce7994112446e77dd629f2f00794cae65050bf4dd6af2b4b0ab453a42365e298a7b871d33605290c725121e42b2d4577e3acc53f2f43297988b21c5ed3333d55bbe1bfee75dfab933c6ab1e2f4dbfeef14cd88bf8b58fc07ca8b1295480ed32dec029df1d66081cf982127492467c6ba7e2ab8485d82956cfc265e6951a872718d7198dad091ec90dd49cdf893ea2c1b0efd49e693da1340ba2d2f040ef2e35ac2c529ef6477189e0f57a48dfa4927451937d529e550ce6d8f59de3b129b5383a3c2f16a7913b1b59db93996b15a3cb60998e88b7b194e02ebae3ea78096d4879156c7c1a47582a740ace471d329bbb1ed5c835296932c83a2b3b67aa7afc66aa01fb56b916b6e5eccd3280186603288ecd7314d9f05864382bfc0b9cf71a7a2e57bcace175e023c84fdb1ef65f2e45a6fc88f4722e553fede4c5a2b767d1be865008aa1d0660f575931276017ae4b35cf633896961b3fff0f78421157477cfa09f0fcd2d5e39f0eceebbc821ff4075f9223fd06cc12166c9ad88beca9dc045e18113613f1807e269e12e1ea3a8d217438c1ceaeaa33a72258eaf8dd5ab5993462c4a33ca0d1d01128f90cc9f32d6a00fe8d4b2c617ee5ebfb96178191133afe572e999110f1cfa4836f10054b47b870bcfd9835caecbf0c678a09bdcdd5a2d31ea0e42fc4ed903326d2835787c98ed502798de28a4f227fd5d106046a092fe3b84cdf186030739014bb05b9ede89036c2972e388b4f7f98e85a1d2687fc7061f64a916828a642ce543569fe71cbe15781c7e30bfe09ee7594045986d72222264eaa901f221a84e9f6406c91ec2f34cbb6ef956ca4a46b78ef19efb8301abee1f56555bb5c28127f07951df8dcad10d36a848ef1af7b586dd3cf1cb8e867812ba4980be674a97088e0ff3af68362a81cedae03afa058c7960bcb7feb6b82407e0636558f7413a06dd5362263e5c3529cd3f12a2cf33512760bccade86ed10170a96ccbd6fc3ba44f70593f1bb93209b86d74e7f8383ce76269c59ca91f8eea46feb801cfc794933e522293ba3802946f5476a1bb4c891ac5f36da77ed2ef0afeb64ca01767eaa80382eddd93e4c477cd89b8cf7ebd99f0bb10aafa9fdf900c73253e30e4d41b16f10ef19ea36250ed589d75c36ab080f9c805701c4b264d1f19745b399c922809f0548c3bd6b968f576aaa078ce6eee68fce1a8440de4df8d6996b90008bd82b688cefde736499d58ddd1b773f78b4c962ae5e89ec09aafccce801a8f1a34f04e72d41c095864255b38a131e497cca80d3a8dca7a9e16d994a5851cdf2ce2d6397f8562f69a2acae7d5080cf788f302e15ac8a9d07d2172eea92c0b60cb423e5c015f9404b090e60b6075ae2e49614bd623394aaeac706ce1042aa26e0b1b486329451882322c435ef75cc2b13e46f81622c975f7f7714ed1e0dde3eed2cf09d528ea08b222c0dcde96b7274b810d26d3064c1bc2bb0a50873f6dbe7317bbda3b760c5b3b3f75db8b14e40a1c8b0c279ff05fcf4461f4c2927233da8ba42f8c96f22502fc92ac7bfa5e76285dc305a3286dfce6802cff08887954fd3a1a3e4a5625f3307624744b5c29617ad23ff5795270568291e330beccfdf54d844c02918be864a36eb4e51866ddcd58ecdd2917dab22c494ff735285eab734035c94f9d09aa0fa6a6740c95a3f52b14813b11d85858cf81f25f77a6520f859ae6f18c1a367460dbace62c6f29bb690606be1897e8a1b7c6a8d4f9f625c28d557bfe94c42af863f46d3d6fa01fa645fcdcd1fc521fbcbe70a9c9a4e74139f318f12d447bc453c5e4c8ee8e17d1540dcf60f7f8636c7b263f077b1c055440d6b5c6a4d5acb88c7e568acb3a6b5cac3d23e12188b76f6deeca5c10cf0077d91cfe3bceecdbface56942bb198b081a607bf705b8c1c1a1c8159fbe48f75c700823775fbd6bbf961a1d85d977e0c5e09c0b6a9a84c79adadf9ac80102e905ba07b13597e2411bee31a58d6bd10957bcdd6021283ed8909c2ebbe5aa0bc7c91264ce844597ee930d778672e01c9284b9086c3560ffc04aaad72f6f70e63bd8f121de8b973c67d37f6c3293b13dfb60edec08a3c6de9ab76826e5f4a98ed2017a81514c37d59c5fa399a16c453d7a9259e743281ad13d7f73e8106666047e5df60fdc5c6d6f43b0e8934a669cdb6b6da37ef65a58cdc3a468672eb05745012a42dde3b0c8ee12594cc92fa3d57164d9f9173b1ec2655912abb063dd0cfbcdf273eebdb155cc832d1b0401bce17187c274e3a193c2212f09f22797193941e7530632d0d312fe097a1e1a0f3a1784e3e9a8dca82c178e57fc7f766542cf7eb51593b3e4fb8f2768b21d98bef1daf6d8df28da3cfee992993d4a5468e16395f2d213e0e341bf791a368e364e0ab8ee0f4755616dc43ff9ffc647aed68082993f5b6530306a88730f9153f143245af0edef6cdaee7a57243c5567532b751a836324cc5b9f221ced7d8b2f02940dce6a3c1882a341eeca97a6403921e3b3fd061c1b2ca537e8bf3b7dca22e255bd39662f1ca19df522680a5016f35a194bb71b1240314def460c16e89f3cbc6c3c1b100c11f4dcbf69a686bc41bbd2b83fbb775aa843618ebab5a8e24091e1f61f5bdce92ae426634bbfc4085331cb3519ef13afc0286bc693241572ad92751af7e7d159a022df9f4a0a10c28fc462b8e65199e77b46fc9e48830ad2df23b3d80a45dd52f9490d8f9206a3962b1896b57eb22d9d3fe87ba0844253c8e0645ef44b6e68d5281e877d09a5175c38df0afc288d744a8320fdbd9f917f912ec12c6f3418b38d9ac1b4c4c791d9ae2bdd055c58348d84b76b86097d8d0da2ba40592aa744a53dd82bce6fe025b86b9d2944c865df8d9d7fa0470ec1cd62abe1f6711dc69ab5d2ea96e1e664f6245002646ef8d3111857027af412030727312b1cf35099cef46f9b34d585eb25f2802d30c9aacf281de4e16b33275978eaf0c884754a586ed550ec2b48ac8b5a7e60e93bf19b688e93978ebb40ee3c5a2380eb6c8ec856db85e03f5b800f06543b2219c3b85ca1182b2c6b044f73adb3016ce34921ee9b35690a1066bb3958fed550788ee6264084e506d66052292c0d2c415fa06dfd7275731ed114240dc73c0078d220d9f21bb4a87da410095ba93720be618fc4accc820c06b4a5cb3b3d7e8b355e7deef316cc9937442b4dd83c7fb590bfa1d3916a4ad3d5ced84e2651346fd0d7c9d6b65e9d09bcf567f64b41e53aad9dbc027e881467c17c197e0b059bbd1fbf1ad05ec59fec96b606b8c025900efb6699f0375f0957c04e47045cb75d65047c9bb31d2f72e490f847f0e94b7ce93799c827dc9e176bebb99a5acc24a6b6a7e8fc9f09974049cd2cac3fbc9eecfe08c214212c9b53d3dd81bc44d2d669c54414811058670eb4185c6bf011072c7098d5ff82777157b34e8e5f119bb814d07332c76d1c998b283fe1b94f83dd5edc392d9434452f4e84f4aaefb1f83ec1dac58b24012af8aef744b392c195d90943635370b571ffb457189598040ccee1e0f0a733a5ef7fb4353a4b889d384ffb39dca5eaaa2c415ebab0f6a0c74414cbcd62063c53227b74d9ba67015a35838d9d1a024bf50c0c9fe927dae9d9e192dbe6f35eb938f2de27b504382a03f6ae3cde62af53507e1ec8cd361e8acea18f88807c0422053edaaa284ec86d2129ade86a5b66a18753ec3b581c23e166ce4e115eee3be0f85c62ddf651cb5976d360b4a2ff12405166870b518cdd1072efc8ce06d9edeb434fa039b0fa39aa43f7dd8fb296f0cfabc2d403d2854f4ea3133e1c12ba88513cff7cf20f38336047bb31be1f10f4fba9a968fbafc1c31f8b42352c50d4078794e6c565f1327124dcf8a9e5825c77d7346dc49e85372f0514be4febd6536beda50cdbd44b87dede5e347b41d933661107bdfe73083c18c8cbdb48432704e360c466b943d0d12b24d8f1da1f6a2c211c4125e75645dde2318e667c0160c70d1602fc4c0bedc1a1dec8c3bd0d8c4382dd797bc24921a52f45c250bdb133cc4a7d18277e385f0f57483ab6c542d924c6115abf0f86e4b0269a62abcbe0530c79d99cdaf1d8d7e80d8e4db2c6bd114fb9d1f3e7b92568502d65a1418ff5a3088246287549e25fdf6f6666a9783cefe0c11a44160ef5773ff17450500b19238a27a3c5917314578e55fa4b2bfa611512dfc1d1d19b84edbe1545f8cfea3dbb9c869ec007094c6a06f0635fe6853c55ea53e52e5ebf13efdc7049407c587cebb02b32dec3f914b56a5ff15d782df4d4acad8430047465bcc9bd39ef2041bf90805f5a5afe52af548fa4df3dd7a1d35f0f21f29e2e2709d04c2315ad0803b6b97058405723e289f3d84e7c5ed989777cbb7c5bb332c8ef7ed9f1f1211cea59cf82d6a304b5644daca864fc203a6d6e4629259326370af6f21a739a404ceca429cce2d02f5540ee7e593d75276f9c2eb1260a5e371d4743fe424fe6bb32a12bfbdef6db7e1e5aa16a3acf9998ffa932bc946faeb380e9b0a75fcf0aa267a4d7c6c0dd362d90d35be738fe1a49a77ff534e27f556287b8717b9ab2c569bc96bfe5e84920efe9960965b637124fad00cf72ef33959e5c9c25a06054b473269bf60a0fb349da8057059f617f2b7db7b4165fd1f6822aea5f98f613f6eae070ef6d1e282352a1a76820dff1e569bc13eb3e44f7f6bc06bf9d1070086a01310200d7263002e7124ab7cbb833e6215accfc0342ef9cfe073689d934604e3efa4f121c8d2a2040736f2aa70dd35ddcc1374fe5108dc9f8d31c53fc7fafe4329ff50d1ed06061cca76e1af0f0672f8852b32e1c880fe3226a513251f2876f8e79de70414d9e59bd9512d8d475d1cdfb1a8069731181bf1f61a930abfe4b23d645a1566f1f0b7475313a23e90dc92f85452371933e00c711847f26a5559865b17820afdfdba01920e583947156e8df202e8ce9f57e25e677b6c8531b6f3aaf45783acfeb43b3de45ba535e68f6dedef9cc1945e3f3c694848e8dcc534ce4213f24936512e944ade2a5b7f860943be6d23ce7565f41d3f6fe686df3b34412c4f55380528001dcca9bdd950c67620d760abfd44ccfe1d91130eb9004d9e8190ff1c702b4cb4c77615f2567d0dc8c944e729fcbb431f4bb1d4c49f14d5b1525b7187b819a996b049c345abc8760448e35063136ec1a241dbaba5766fe06b2836e195133a2c77fa4288667021f3f4023b98945ed7537bce9219a192fc2ac57315c9f10279a87ff46d8ecbb6357f2fd77fc7e635c31c7bd26001d5f674cf0d0701e78321a9a3e85796f72ee2be527b74c5d957adbe707132f29848962a2bb8dc9b161196bcf97dad0c79fe8aa79ca9869fc1ca4f4d223b3b51f4df2bed356b1c2e327b0d02833b1909588f8bea850f5dde05d8f4cc828c5838cfab473f981d8fa53693fa59e58232e2d20f725aaf67b279efa7107ee47aa219fec1d8964ed82fa7ece27439c50e526401aa929e5a77b66b411d62ac818cbea2581a289f8ca9293816b985cd3ada056d4f94eff915c5062b8dff229d05ab0a17916f5598137792fcd172c1d4ae197ff6f03609dc9fae816ba965cfb5052efd3dcbfbae6c80a1ea8054116351d7d4f75c41797039ab577aca453dfd86472f8701031d2aa3458d2ce02562ea827805b26571a49f8436bb872c9928582c5885cb18afeffa57faa3c073a67bbe26ef117c73d36965c8ac8c4574aaf42072b73cef40036b6568fbfe0be2d8e139ea611f01579623c15fdad3836574830a19c97ed145708afc9076f9d13b7c1bd01b4025662d08d78a22d69117c227d26051f4daab892abe66e13090d9a542cdfb108497070e88e93c2b35888c880cff40c35a8f2ab85c7de84193cb8ded879a187ce31123c8737d9e42038f4dbafd2b33fe1452080d315d056766f25b0e87107c15f2b7ecf83ebab4d421495906bbe287769d34b41950014ab88679fc54d8d938671021adffb652a4dc6d7c11577c55f6fa0d2636bb0dfef77d935faff5fe9097b86ae28ce865af313a73b5653a241a2a42d39695afe8089db87bd4b1d61122713610634bda0f019991c0fefe7da1ea7e7f16f5e591060a94abdb39f97aad70f186af6cc9b71b90d8685b6ec0d2a2afb932daafee3aff8f10ca5e3db48a2431852bb90aa92d36900a3cbe1f068d611069ed0d40b0857523a416cad612007041dac869a64f1710f141ebde52f0628af8ade1fdc711908c30d2a1d225b4f0a7b161c653b394f3815512b8aaf983e8816f49120698629c3291b7b65240fd264b5c373ccff57bb59e34b650664e0f78fa48f5f676322ddbea7774db2251341b38b9a1cd18000ed384eefa202f82d255be4a4d65a72c8091cfb5d4024266736d4434949a7478f229ffa01770a90b6af00521ad9d0e35f2cb70ecb47438ad47b590d6450a895d1b9d7ab1f7293a7ac1281da6d5181ff3167c814bb3a96cb75f73ee91abb724f0e5e6ffeb5821bac86ebed3487615927879927a21b11cb016c49b159812bd46f4513f093c59373ac608e9dbaf6c030598d625993d9697283ca26321bb72c703073b20a50a79c83c8397e9623071811d93fbe61277071e67385c0b0c61e295f794ed6c8a4bb8e4b36ba3cd74cd16c97cd630aca034e1acdf98599be00db47e576fe68c5d820663ffe84159271f2d4a0c505549e6163574c524280ad70c6768d6a51095eb5fc8986369f07be83c4ffbbc63cd9b5c6a7a86cd026c33fa7ce55901e0544db62c53c58bbb20ad5f3f4ffc9a45e6bdd1294c5b54c6a12e5fb7d4dd79a0838d1c5abd9ce87894c732a07cb8f0400e38ef94385b0b41897f961be0c7d4e7c4fe242e0b5ba5ec08c7b6746f559c9f645a6a9b74031d9b6defd862225cfbaf20faac1f4c78d1b3f90cc5444ff26ee1afacfe70b62f39de908adfb770bb1a0a30c75af794855ed9f83f72a4afe591e805530ee31fe50f3e60516713001f2bd3437dff5955a94758e1256ab24853bf8af3938a6ad4e3b03219f4a10d19a37b6710e252b60a029556287d532a53ae95a5ff849c26c3cc9f5b93886dbea044b1a21a9aee217e1f0560b186f84dd1ef4f4dcf0f8b6dad3ae3b5ad011dfc687a4e656b9f147fd561b0ba24c5b8efcf8a717b53487f5904095a467dfd00065352876ac1ba8c08c4116af0246649e8db98c9e7f3203c4fbd577ad451c0420c37feae633db193807d0b670ff8df51fc590509881ce4ed563a15f7bde9a419a116c2a26b73bc1102474aa431302f6f6d67a9cfd1f283799f5cee0a4450d407d544ac6e59fd8530244a8aaba06070dc11120fe0b5bd29ef4d3b69966c9eb4c6c4ae736bc0045ea5226516cbab4744f4c65216bcd816bdb669e0000526741692f432106ea9e148af62991af6e8636d6331921f04e3fae75cd7f5a655c225e8a2b3df6733d8fc23fb1973e6ae786f8b80d2721684b6c2cf26f8f3c35d6fe4c4394b0756731ee7fd63a8051457c93c279a55c3204047abda04c7d04b83ba7c0a37ecfee12c2062e5ea9297e5da354d176017ca25e0d8dbfcb26c70c888194d060dc1954d1cfe413f37387591e2258264d9e200f068e0f755b536c8a4d61c08ca4cdeb7dcb0226a57657379f8ae15c2bda8510b43027b359c912685e79e301fb7aa71a6eb681eb162d35d93f75310a3951eef00b08b8ab894a60ee3899f91c1034efc51cdd943a2d9d8201a91a9b4925cd1690ed3c57ecae8f745b81b61faddafe2393f367a32e016e0c8747f5856c0d456e013f356f76953969d44064b3c9523512501ffec265c697e2cda35163638a80c420c148bc86fd7fd917ecddcfbfb12f5716edb9053d8431656ebab535ad1c699c2e52f86cacff63d7e52787c1eb60dc007f823d6abba0ee1dd75ee063706237577516f6268bc05ce3442ada19b5f71b9cfa15001891983c7f9c2a04245bab9f670456343ec6650f0b815aae2033476d7d1b50ceeea83a80b2c88c01d69e49256b63b2cc97401a8e88a60ede4f3ae89ec82f0f8b3c3f907751b4ab5bf9a17a35ac63d211b21ef8d6d1f095cb1be7129a41801dc0c31daf5999054da1dc2dd40c24ca695f10e8b70d28a7f5285b514b572585b838f8cb91b0fed481c0cfe2244959f8b36d8ce69094fd0d8a7d2a3130ac9523a2638e2560e5880366b86fda2f645873fe583cae0bb63efa1984c19769457f21b0c831e5eb6fb040890455c93ff3f0f86d15356ae7ba4142cc9c0dd3f87c8ce19fbb6080dfe93d27a9ac4bd3c41b7dcf9ac6a72dcbd216ae342c7ede5cc44f3e53e820d7212db75d47df3fbb79261903bd6f5e45abd5adaaa83b927861112d28852748f24b80b7a3257661a8be26e97aa2b5951924a968dd5a947bc03f2809e7385354c236747ceeeaa5a59f396b9ba42919e27c01fb7ae848aa0c6bced1fa5eec40f9cdcf710f42eaf09af3bbb7eff6d66b6170d9c757277efdb6fb5f1135c84f5a89fa3cb5555915dbaeb9f46a0cc4fa65913a4ff1b4b4c19b958e1a9724c677deb26ca27d53415436d2afba8e44e9b8d216c8593b354e6f8e14724d19f8d7c0a0482172819a659631a447ac7f55e7b8267214b2c6fec5e9b94d470c5cb8f70ac460631b7e8e18012a1472ead6fa79e1a874aecd2a64f166c891c717b0a22b243e479882933fc2ccf3e87eec25ae6c0d44ceb6c550c3b7634a5138169fe5cbba32792e23f0129e194de644a817d2c26b18511d89ef471caf72aea9d523441f8f58d431eeee2c15b25cfac6836cd1878c0958fc9cbd5a76b3b005412b8b3a7a49f8c0ff154b4945917c540d988d40526689084972031aa40ea40d817eb1a53dedcac22bcaf61935a150232da350bc6ed66312a45665fad7e5b4b14e8bc934b8bb69d12e7b36361f23e6be505ce3c73fc0c3edd42b25aa8a2f142c60854817a33241c0c51ead7c5cc9f8c4c3036f9c3be3c76ffdfc7b091505f731eeee263ca9550121de670cdd08f6b7eb67f744e029a96fe6b3e5c41e1ed45794f508770c8a3e82d64aa70896ef70736cd90f601965905e7ec92ff5a5c4b0a1698f173a6107bd445776656a8b4aa3a04fd123818182cf2268cbbbbbe9b28aa32a2d12142f2bb67507b5da3fa4b1e1daf76d79d227f1f86b66bfddec6fe3fa0d34b68f96d954fd4cb7e497814e4b12d635e8b357346d4d7f650a41a1958f0a0d89b806def89a68c0fdf3ff8c2240f7a3edfb2b60dcc96b2cbe605f3eb7be6d362af21d819d58811a261e46164039a7dc05101853aeab5d88f902e97a9d9457382f5418e601d81c52ac2c7ed9602e90e96fd4b5de3348c650ee2631f126339a1b08ad04444ceb8b6ded0c16f90915e5ce735b2cc9ae89f44fc1fe3d3fa9de476ad5344e258269bc4577aeb5ad0ffa99fc6788f31c82c7a27542284bf020dee5ae5e613bdb12f1f9b834989a6dcabe6d2ace4aa003eab0fbe552e930ab6f84d57b03b1dfb291c633ca95869ef6c74a18d0eb9c913bfc7e1259f91f09bb426866749565f2fdb084a04f45565457e41f8cbdfa35b9b49935cebd2e5314fff33c7130180fd5a983879f5db0eb1e2be0242f38e823050b65cbad859469e0d3d644e98835e16bc382f0cc00121cbd184271631f8feeeebafe15ddf68c491eccec8db40bd6401ff3568b231e8c4296ef91bba2cd9e1540eed3954b5d13d28765e63676ee7f793da3f68ebcddc3dd9050cdb5c823144ea5b81436dfc95f30f440fb5f04109346e524541a51f515e1c2306390a8c10a767f055340e245070429c6e05812c3dcf85a19a1670206b7763c16cace30ca43121d5f4b8b3851468317da93512abc51fa9cd143c4fa990bd61d66b1f894035f61c573aaab656208e64b4a4bd8cebb3669364590111fa6f6e0f69ee5ab3d938cc1acdb9bf9bfa80d5aa197442a4273c0849787d78597d29d6b43bcdbd1bfe017f3fbae352b9bee2fdeba4a7a716e53ffbd54fdaa552190473ccc1ef58d114e5bbcbbadb4a11838fe10f7f503d2e7efccd1e46bc69587460d7586d725eab8654489c1171afe3df7ca2107c0325d08dfb5eb2f289a84b782ad0fcfbded49e676e34ca118266f929d34ad573974790cce406a649fc3882feee6de54dad8abf46b1b51a2b886dbfd633e5dfae95f06512e2b414186e52ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
