<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>The password is youngatheart, but with Calvin's last name</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0dc63bdd85cda0cb64818dfaa0238f5945e3e0fe56793651c1275b38d93bfba75564663e3f45e7db5b8e21172abd6c16b3c52bf6ceb26a82f3891cf0ee94b8401334fbe4045ee137efbc34af283def8be6fed559574709b229b5d9a90bd0f7cdda2756ad8c9d407e39c543e3db6ed151d488c8f5200af6a18ef34e258c93a548781065e578ca413e7200130e9b76f4637f3725333375448eccf49e0b4346de8f9f07627df1978c5cbce6429ec6951c68cd71b9dba87f33539c06d5042e61cfac9907185000fb925608bfc58f95b2ab6499996e86c28c8f7bc3c14ae5dc2e5f69a4fa887589f70f8701acff865dd484b3f0682c8ee5e6a618322504011528b4211ae9c3d77b94c9fee47b2e3af2755f3218ada8a2769e430fccd31a492cccb285f735d33c2eca23e19e7a60ce4a0e516004a8287c9d1cf141c125f54bcf7e4252d944c73ec6be9b7a5808168937b3726de730c9400f42ae968dba7ae5f3836582bf0b243367bd29ff272ffe8af217f4cd759dc1da5152174c241c7be687e97d140af312906dbcaa251695f792cee8864256847bf28134036967721767df8655a0b5f5fbc3bbce880ea9b61db0b0dbbdbb2cf16ab7cba25d120b26499be1f358cf811e10d62a4db63fc5d5bd93a840f688c8d772b17dd7afab801837b5ac5d554ad11bd42bfd0ee7118538075488d0ed941b2cb12bedbfd8190c73c8ad9f68e5664bba60bf5e109494c1e975d29d5e1bd6d7d18cf501524d9c77437f9440e7405d73fd6a12e7906b1bd8d8dc531d4dcd12ebfabeb9af9fa27b21ede0a06786da96347045f2531ce391cb701cdcaecb1d8f1ff63d6b61918b34f7676e1e43b04496accf6057bfdf325cd9ae3b8cfa822a162aa7284724f99338cc71c7b5c07812f51da3d75eeed28dffcd5197a7e17477aa3a3afd1181fa1536db8727fc9bc5ce398c255db796d7db1896085e3408b2f15d315051501d344137b86a72787918a8c81bf1fba1e6ae7a8b8dd93b6640009b540957478c03f92bc1ba4f0a466c727ada14c1320a76ef281a1abcd0a9a02b9b5076e71bb125eba4bc5fde3bcc9900216b8515bbf1c9dd516fe0dad2cc0c0d277d620d7a614a8731e3f24a5c5dcedd360adedf6624b0b6b68dc1b62e6ec5dda329ff9dc2c37fd989a96a43f5f381b0eb09dcafe15077ac11402cb98d16fc7113327131eab8d2db8746292d0fd143823426a9dbd3bace0734862e7d902d6e5326c6176664da369313b259e121a61a0ce6ae9a123f373252e51852bfebc122a46997b4fb7c3abb4a29647d3b2f88cd3a1a1012b9d8e496ba4eff03a0dc72d3e8bdcac528909aca9db40899678425653fdb024e9974c01020269a3314a3f1cadc48292763cd4f52ed47085eeb4a309f1bce2f5d922dec641f34991a6ff96d3f80697923a93dc892b5135e83022951f812be7b07ee0d5a0fee048d0bd5ac370617f0531f87b0bb9b2ddaa88fd877deb923abaef141da10f831565422fd2774f10f6925075bf6c3de5431ae5f0cf31c4f7b3807557f7b750ff8908829dfba84f634c604ded3afefdf404fc3d2bc966da230793b6e2d8ba74ffb5ef551b182fb311246eb76202724e6b0de32591c483846c2383089e14a9be55ac7f9101493ceffa2dcf9810f93802367745e98c3ee389bdac2dd671e126fe88c9ebd60686322bfb8da1069cb487e52a51e441acf727d7dbdc609d8fbf56d1186213b411694ea4304e970e9d8c783b9fcff9aef8cff18ed4d52c5561ef08efa1495132b482e1d6ad8547f3e361bc60d1f7ee744059915f29dde04f090b10b8dde50f1f608ac37b3e3146746b25c224f3a2dbc2c5dda301e998b7466c5ae864d6b277792800ff609ddaafc09ce02fdbaf9e89b5c5dcf5996d0fe775b16b06c03e04e24e6dfdbaa8167c89d993a709d3a37d27d544a3af883e9e5d47d5675e2db9d3dba973a409bee696ed3d2d782ce7978d773db54d6159480a83020522aec72981dd63d8653889080d616d9d86d1a9d7c8179f19cffc2b3c7ca63c8dc8664739c0f6aef39e5c04861fdede395912dc0b73d3e4eba276043934d0496b3885ab139248aec0513f5a6f5d0ad1a4c6190b8b0f5ba1eb3794ace523044d2d832684e4f6f72bfafbb13f07b8706a4bc774eaa879bd833a03a4f5a1f3179321948e79e70aaee816cec0a9e594ef9c9b2985683fd34f5618b031589b6ae3e5b4f56f584f242b525e0733b477b46ea41b61ae47c7a0327547ff7866735ae72998943dad37fbbffaf2818392e73afab6cf5611f61294ada3a2907dcc44cd531ada0e01586693a309391af14c7ef55f8d694ecb8461490b8e0384a0fc1992fe331efbcadbff6f6bf75a7bb90a308b263735041569dd5573deeca30124adc29a49a622ca739e285be42aaa02a264b26ee86527ea50037442754535ec535f4adcaae0f1d299bfb39a1c93099c9bf62f660da6b3576e532594a99ec9832a4e7d84994cbf320e4e04bebfea4723174afb5eac66c03cd0e85f07440d648a449f490ac03e8909e4871359f525c4ecae410297aa26bfb776c84a8b047361dbfe3d8dcfad3b24fa5794d817c6401199361db2cfe096b732b43abfc166a2216711c45aaa33e5116d75a22d7cfc0796182a969b5afcc5bfc771e6c70c809f254f85b9d7628646f817db691b86b724d1d5a891e09a4fcb39ad495094edeae9bb4c8d83e025368f639010766fabaa61aeef3b2c59ade7e23fc944f882d64233539b6f995c283031bdc83a754cb313a003adeb22197493aeec2f60d9c3469f8fb261fd0d4c785c996216a511fb45a011d4a8185716120ad4cca48bafceffba421eb3b22d3482f6997fd5be51bec13bdc378a34b7c8af11b09483d7bdc7b66463f09323896426d1f639670b76af7c8b475e344673ded3055f7ce7031e195bca467f24b2fdbf134d5995fc4b54c165f2666f81d2e06ae664ffce250c6d976c1853786a2f010b06d1db4694d7ed5eb9925edeeafa95fb428bf6d73a088b79371fd03241f78de756125e3ca7d9ff841e7fd6312407e175189c85c949dce5797f09038446f56b1cb0cb685e45a98878c06a75109d1f74543331efe0fbe8a12ec739fb63186df1e5414e2cedb187a5e6f62f15e41f41636483b4bd497a63a8a3800f90a23e8d397ffeea457d9bfc13ac56cdd89527c262fad0252ce852842fad0e4c1c5e641b37c99198d5eeb26269f38978f95783755e16eebf81e62eb9ba506e0302311bf0b7f48b0ed420bb6f3933fdf733636eb0703965c476c427de0599e72dbeb17c6d8b598729d83dba1a2e84c6b80b7cbc9c1ec0149fa5173a7369025dd02e93e2be89cd073a64692d0a85983cc00aa7f1a0f99ccea29586326ccadbc1461c184e516e65b8ea04b751d4a89d2013a8cb667a2083c524bc1f915f526296a405cf7eca131c24e366a1a8addeda3486e2843f074f27cbd05d2920760e0101b46613c07a7b8f41474137f003d412469e6a5a232ed7579dd2dd3dc36934ee4ee8f32c7cce0a1feece9a3ec92c544662f9dea6944442454d726403be57588289297a7b973c3d7e73e813e660beb600eab60e0a22967bc042cf794e99eecab3a876173ba316ffe69290151eecc566ba4bf941a693b4a2bd0e5576812183de9d3cf66d9e1ac5a944f98af7faca51ac973260a1883d31a35bed85101777a06e454434d2aaea6d5af9d63659c894c02e6e7cc4346f0fa1a0a2ea6ffaf6bad8788e1045edb93adf15c5c67c22ebeef02c7c96ea67182955bdee910499cf1e9da13190867ea065c75ef1a81e7717f79d21ef2188cb7c4c4e0a44cf3ec96a5bdae4f40ba958e944f346afc75552c2d9570bbe4b7781ebf620c6a15038efae0ecf52288019191ba36c5d67a3dbfbeb7f7ae8bce43183f276e5d8c4b4f37379004c05ff068577c3ffcd09b34932efb32f62663867887590db77eef7095b002b80cba1d19e52b1aace2b4d92bee19e9a8c18e30216896f49a6fcee61a4775885f466888a6f7094d8573595a1a0417e8a036abbaa8a82e51089480b0e864af1a103070aca2df77135980431c564c70a931f525353b5516be30e253e4e29854a960e967dd4c5622a69a59029ad7c4371e8df7450e3f0921403f77d4f09f70194ceae577a07202c8b984fc0839bf78468c3c7d93aff4e884f830fdb65e759e660d22610fd204f2c80ca29d98afeba4a9f80ef26673f5ae4e3f1d8cea0a17af1b6db8fb01eec2e759a0a90967958bcd81fffa248abe3ff8d22066600dbeef235120c10e99bc28857c1345ac578c1e11f1fe34ac20ae0cf8e5b34566fe92e089fc0f9cefc1ace40d2fcdc5013984cae872b83c90c7604bfb52bab389cd1c44caad3f50fe21d5f0e4dd13cbcdb81048015a21288220d06f04afc02c56b24970e4f4ef6154cca42d4499aefc70936d97e0bc2a273f9a6af2890a7f99ae83eae8a27b3248291c95705ef24df98b6a5dfb2aa6b4228a2f8e86c80f21307f6d63ccc956e21444a3ac081a494218933d23d66b9ea7c8f5d30103aca2d3cefd38c37a78e32fc2148bfccc72542c144fd91b6898e7173d4eab481f293957013ef0fdf97c9d48699068c60215fd85842c7c2fbcde328f9e718ea0b568f92c91b9292e3dbbf938f12380d304ee74895430fc501abbd8ab5f1d08b393de9552098b4c14a380bdacfb4cbac49cff5b8f3371d58cc9150f2668d6fb8d7ac31c8b8f462f2e03b8b9beeeb4c50225eccbb23644790d64ac4b1ba3a5f9c1dea35dc750690fb9a7c765f6ac15db04664a2b0a4c8dfdf3dd2cfe17cb31c238fc2141b90415ce4453f866da7e7dbc792917f2a4bee189c9f3b9148edc218fc69fac281396c802b0ab87a5ec74a64ab042dd69c37880e412ad205632fb70cf29979880c21b9d9e36a759972d0577e439abd885b20b77248839f488475a7c9fc970fe235d98764083a98c984dc228bf708f7ba79dd17310ed88f84a3369dd6499d8db77fc11cc0abb97258f882f48d5e4775a67b377ada0efcb77f1d0544e8fa5e35b3b439ecaea9535f165a6b6dbeb0637e6b03aa332a14634ed68456580c051d4a71762d423c0e58287d06ba250e81ca51653886db1d000b28999ced0605dc76d753a729854165f11488b9b2fe5b0d819f6752ce4996599460d324c3df3cef26b363acfadedf5c9729ad7ebbe9564adadfc6144cae6552f211db0998f5b40f95c9eddf79f13a2402e52b1ae14b0e0c01829466d258a759f8043d47c88f8b2decbf0b2060abc3874a7e516a20a6ba31487e6a5db21379722cea99df352e9842322b254493a41f016098c12c00f67c3587471c8c91c84c5ab0cadb91074345e5a21c243b91075985bc233d9d04edd08f746f797e16a3e428aa6e1d9be1aa66c8db136527e8ced1fba8c973baaab4046fbf744acc3d427c452476a55288e570f06a7ed6ef2e4b40b000cff8e99b97cb0ee8f078d17d4bf208995a8d558d55f4cf32b1ab836d347f7f42143dec17719062de4aa05b3afadd3104d171af78bbeb3e90d9a56a76fef4ff04039e64ecfa9deb42dcd1832d97cfa7538201654ec279348af27ed0fb81e3542995fd8b2cd31ca803b4d8a493addd0a30d8012617dfe580a6a6bea3188763de75161e55ea83bb5175fc509cc6b6d572afecb2c05e5bc5e48356553017eccdabbb7eb350e3897b370a99815e04b73932e90300ea94ea0ac022785b832f645b42054173d727f8e56a8dabc38ee4cce6103126d388188d3340432938c192a126140c14264a35e784128cfa0000fa4836fef9663b99eda3fbde04fb803ace5da2df375755da9425229244343c6adef04eb879b8af24a0ba339409267d15abe545fdedc48a7bf985a254575a0911c06fc18bb6c7f57dcecfb3363537d41027b9bda0b2473fe283f275e29b158298865a6d7ba71b40327beb9752df4d3d99b5c296315e35f0aa32f13eaeb1e125d56c60c3e2e05f654728e5174278a314d4be695ee6b2dbbd401bb11fe049930f5649aa9f077dd03a60219da91967eae5be959e0ec42348d9fa1bd8a9968ca0036400815bf8134d7f13b1efe11d34d0f2cdc299c2cd3d80abd8b7e6bc4307e336b6fcc682d92df5170b9efc1c46a2d56749b9e44ddf2043571877f18ae6aff1853e71ddc426e19e0b63ba2ede728f70a86cd12646a3965e9ea4e9ea53942b431e54df7d968f29d7bd454bdf7b75b16ce36cac440a1d74086fbb781fd41777ac3c86c4b01053be85b6bc119383d9ec6f1d24158b62fb9e90fac00e1a0ec9e66bf2c8e2d25b5988ec409bc8cd54b792b22f59551b57c1d36c7767071a797933b92ad67f109ad117e025088b99f2003c6bd959b847ce429287ada39bba93557f70d121921210382b85468b749a2ebe8c676783953cc849428f04c69a880cc8e4fcda6a5b470d771bb48596f2437c756e7aea6eccb5d18c050cad8d117cb94e43e350bea00d13e5144619cbb01c6c86a74f92c5eed93505392bdf3137f38ea603c044259b1a6afbaa9da98aeb615fb5d773801024cd9afcd81618a284284719787a2d67d33e5f30dd05f0f971499411814d0d525cbe7d01170a5092473863574c51b483ff7bf8d714d1502841dda80ec5160f77a7626f554935d1a98059a570c01b00107c42df90e05e7fbfa3bb70ada87f3a94e2cc256b0297ee0ff754b05a418c0ce631264e3e25a96ae7865e50dae4d2de9f91e4905f70db2a8359c590750ab798ff05c92a3540e64eb47e37584a3b332ae45682476539e906c2169f93b208406b76a29d1e5b6986954f199b6785cd833b0d78fe3473200b1b519aa05da4f670a8410e2f2cefb0dbeea915f4807131a26e313d695d7b017a0743b69573a7307f0d85f37e742c1dd7d734067545c77e07b1289e2119cf16f3a82ad27ccddb53797879a1b664babd28f170ce5a8466b5165a108d098d8c4a32d0f37ce809e3b737499c976d84e16de70c6035947667eb0f1fe3f8d089308f809674da170f74fc8bf5abe11f088da9e7075fd52c892fecf99a38d03eeb188655ba9b35a30d1d121134ccf66e7599578deea40800bfc0f49e5ff12a322cea57f9d74f6b4b565b688f95db0e3a5c483238c1193246dd2a65fe33b5b5ea7238ba742e4bcdc04833c3229d41e4b44156c738ee82bc9b0b46f33a3ed84f634b6a4f2f00e641a0ba8413f1ea89ffa5044c4c27a5562b187b8aadf7da2f954e1bfd76c66ff733055588e533882ffc1b09a7668d1cb7ce7a0d5d1fe6768f07a40bba97f0716fd409333cfa20bc6a5f7d9832060daa134d06f6aedb04be9256b61965a9295effde3b124abdaeec944dfb6f79738522e6226a3ec26ae010856cd5d0cdd6a84a97b973a07ada8143e956bcb4bb9a10b37143c53e11f0e59c8507130bd2949539712b8a43584dcbb8b789fa8701cb1092dc4159385129e8661a60c300da02b96b4434fb0159d1d13ef06646338327afdad2243eab8487139417c6bd166190a000c91ea0e3554748703b3bedbd19f77641fc63d436dac8a84c1e9491d832a8190faa238d8a976af28c1fe340bde50c18929bc0e65bb5b62241aac1e946011755419e82dddf27d7313fd69cdd7bfa856f21e5cc3069aa180b1dcb11c64a69dd3d2b860de686a286589c51fded4e82cd9e7f60a03510af6443ea8f8f78bc9c33525aea26845f2b66668fd225ed0914b3097d8b09171b24751b49a1b9b63d354be949076e70a10c59eec438073198c32856963daaacc2503bbc648756aa6a3cc609513006ee1264731ea636ff43f763118b68fb9fdd061bacff452b367b59f25d954c72f00c656911fcb73d0ebb2450a9e97936478d2ff656493802826ec97725bde037fe9722f73347089e4150b55485b524cb3dd02cb30a28e7bc5739a793486c14ac280cc75d601a0209c2d7e3a5033d51f9f036175b885908a54b1af5e3d5a760e15c6e84c43e52cc4b6d16ada7dc3260acea1fb3ea6d810d74b7cc6ede1cc020a79f2e656b693dca8bee0d1b2d62c148f4fa2d31fb6ca6039861c9a9c3444888977b83a255c331a05bb5b2c887e6853dd7a40613116ecdbf3250f60b42c86a9ba38e47890be188e7d2bc576f19faa4734992436ab444c632b0ec83f8ff250df8d580aa5287255d541cffd6664c30bcdc13d8bf55e3f73d384b39fc4fca63ed617ab0719f592d098a806a0bd4bbf83d538f4529084fa05793e2ae35b39784a4d3d9c70c58fe5d8d2f8cb5cf9dda9ba03804ac41d45a34ad8ecb4a13dad5c7010ef1ffb9ad53ee26c26049e4734fc772391a9021a31413e8af60a6a22fae9c3e07820c94a3dbe7f2b980d4bce194f14fbe0108fc7fc93a0bcfb382755d49adf54d94e6f8ccf64c1eb84ad4700e43ebf156c39986baa1a435079b8e0eb54989e60731eca6e3b499a946977bdf5cbb80a06bb0652fe3afa85ed00a7cadb5fc431b9b2bd592cfa53553c3ff1e9ff94ca3df66acea6b2f40cc8d3bd383db359b9b382017465319c9410f88efed603c8816e0f0f68c877e527d98cc15e39bb11485df2244f93b7e096fb7474118f9de7fc96fe55311bc770f37be32e2637dfe7a29c6ca1eccc6dd70562cf1f26b5df05df4c3beb3816556a3391af0a68d0fb01cb6b5d55b4b341734bea41332ea13db8e789b4dc38ce0f405c166fb7a7ef87992faf7a65d93aecfc794ec1943e2b6e97adfe85753b85a37fc0a854f986f35af45e0152119d2e42dd4c8a4dbd4d8357e74825beb2b62cfeb87b1aaa2c55b88adbf8027cbc1a6151a39790c545b66c44e3abb11d5ae697dd8a7ce2068807771dcad205322b10bd268758c1f54b34205e9b5841a984840868e0c07554109d51f5d4e1c03b106f54426922819284398ab0889136495fd9a38aa0e5f2cd65e8cbe80462a049d75b3cf4e678c5e0158876954585dd4fd0fc8655078b2a1097601e09b0c6727297d1391c31e88e23ecc14ad7754e28127c0674843bad829b0385adfc7557864a0800b2f6f85c7a948ca4b8c87f41e80262b7ebb34baed3200ceec86c10ff17c4fdf83e257e8b514ae3062a1b3527aef407f9b90886500cf1b8fd3921eb2f3b4d547345b75640689801430851690c6d06e1c392061e464f4f53a47d36d659256eac761fce398238ed1711f78dee21e2cf7a6b714fc8ffc5970afc808f262ede41268b0f6dd65a20c9d055f692c9dca5765356ca307d96ac9e7d4eaa4cf4a97c348a5f944b2830209746dbf94c100b897b61faa61f8752a605f6fb188c90f29e0016c152d7d47ba56a03d4dc66aa3eeca924059f9b8276af3b17b83c77007387ef31001c03437249ae67a4d00c45c3a3a674863620bd71de29c870614b7fdbe7fe899846fb32358d9d45d3491fcb74fe16fd8fd341228d697079a9c9c1b8d7b2704583a9ab0907de826b1c84a85835b39cc52ded0512e3013a0c496d2ae29501f4e8ca5a0108da3a31b623ecbe65566bd595b3e63cff32774a7603b01c2a05b260110f65d24b305adf4821ed2c3c36f96df39d25db3adfb6de412fc7e73751951529923d1e487ecb33b236c2ef2e7256cb0845e6853c0c63205f485edfcbc51cd8ca758dbd09fed7886029856e7341b97b92634679b3e4ba7ec9725e9619afc8c236544b4ab72e8edc5e4938ed35a4d4f6e4f19e6d72f69f5859a6beab25fcedf6d2d233cf5780e254b5bd614f71a0c2b385ae27f62d95cafb5a69646b5cb7fcc396b3d657077260b37f9aefb39df60db2ddd72829081a577bb076ac57dd00ea793c13211021c4c3825ec84d253e66511a124fbd6699bad55fb0ae363b4a295ed9712e1e7c3d5592b9c24486f4c4db7bc6a115e823249e4ccd3c77fc78c3a414979e39a9db8949d1bd87cf11c7defb30e3a486021ed35a10dccc2e8c5a054c7ef47fedca6012bbd4f3a17420b30cc1be75a99d77a907d2da4e4e0721fdfd85987b0c573da49838853a6278f447b8c21ce28449de202b08e16e173c4af5a72d8743431dbd3783e84d7499b409fb76dc14b4498f31585025e6382973c8de90073273d3a68039ac5130292e75e407fd3ed4029004af7e211c8a34f476ce554c9121593e179259f2afcf14196ed1078c159f6f39ce27cb5573899dcd906d1a74eae9977ec1731948e72b70172083631a3eb3085e937d22ccf6ed0453e6e3145dc2e871ee6d8b9cb03388763c3c97140ca725fe8bfa907c019004450df9983d2ef66cd401b9634ea4db7ca18a5d9be4aff1dfc0ec491284b7598ef8d4728fc7607f154995fe3496087bd646986e4ad7d878591e0f519fdd5d9f0414056e4430f21949ff8d468db5f67f944317dbcee05913413726968fdacd7da5b27a8f2dea97a9cc24cb49b6c1ad30baefe112ed4daffe755d3cb70c0fcb8cce098b9f06694129fdb4b60176ed5e7eb4d2956acc4923d11b9259d4adbd1488c1d411da2ec89481fbc4d4adfd0cf778e40c1e795ba5762a3cde4d610a1b627b28a81a96a9887ccd196d182027c670a6dc4f996bec3099e4ab8dcc686eb1617f9b061be33c8e0a342ca17e2da670e82838ab3dd6550f74118867d87099db60dd9208d6431e865ad606ebf5e7cd066dfcba21796139236cb9dfd9eb64bd14ab97d5f715fb8ad09ab3e382f628d8e586bb0a4d699d7f8a3c5bc3343a43cd46316c1a0296f95fe9388d21923447045e83c0559348c3e2783a1e7fbcf257c13922aea9bcc7658d54d5047bd209e7c12e137484e1b6161521a12ee0ce2331dce917cc231d5ccb0beb5e9ba90099637c24bac2ea3289e2eb5b1c176776808d8723fd3694926e2f4937dc934d4be57e16f68b59a8748d3140d355deeeb7ee6de0d40f7f25a6c24769ce86929d818b46d4ad6607d5d766d83000677395aeff4c083ab6d9c3b027dc70722a9046ea9fe098450382da682e8a86f2b424bf4b5d80c83c9090617f3b3bacd4ed6d01207a63116dbd1f8054b3cf5a7c1818e9e64824b5c598379a8ef6ddf6f786776ed9cb53a02d0fda09bba92805256f7c18815ebdf96aef10b03d106720a0f074bad4fac33df7b3251cd7570840a6cc2282d4918b23b151be63685e0c52cb8ca3e2cb54c6fbdf55ea3e4ae8af290fcd6af0e6af0cf7cdea9310f7bb70434f60a6f954bfd69742ab48c2ae7b936bb17220ec9dfb49e1c5d1d2ffe4d03343f9e824e96597c5c812ae6647ac173f7940b2f5acb4fe2cd69a153e5bc75c51dfad45d2b8a1599055b7ff5e6219598b44c39d791039225dfe29b1cdffcda426070d8b18a33f226a6d304c6bbb9829f97a1f19330765566ad8487f012e695eee498c60c58c8d518cfa3a9c70a43307de6a4a3012999e5f22c4acc9210a12aa167b4c4be9ee82ace8b73c79cfc3c63b4af198d01f4c8336844db3ac832f4b71368ee83c985a174e67f8779ca4768860ca5cc0d91230db3d408c6d72d336f61e3fc142043463c34b57da662a31bb54425e860b90c65ef37b6d1b22d83d3a150f08679a5baa57ed7f639a3587b8eab5b28fa984adb0b675601d61e96e09efe6e5b5c2c81a98f51c69376c1936f49382038680444132850bfd536907aeb91092809e0c666f5c12d4d3b6ec6b18cce233c80ac0ee38b035a6a055703985d174ea88b208cc16307e9bda821dc27a57dff20152af269ce480b49429812839104eb36342ef0a0d34dcd1fc9d414ded7552618b84968af60a4df137ab02a346df5e01959e736a89e76136bb35c8b138b35a58d6a8c3b67bf83fd7681478214b916ee4b4b36ddff1dab2d66252314bb179d9cd3d5e552306787e5cbffc70847d18a5989c3f6ca00ace2f51d7f0c2ba9faf465c95b8577263c5706484c991028a320a306790f0d27be8bb8be9d5e3719f6d98f1f117bb1c5a90f5e6e165c328c07ab5fe5381651f7a174b0bebe3bff25bf7181c9b3772d9ea216dcf8858da97353cf510a677720a2a3eff936bed5e46ad2b3fcd4b5baecbe98c9b490f437f32bbbc9fc662b9248c6af09c2bef2be5d2a5f03acd69f20e21f88bbb42a7fa79109c956e9df0c2efbaee1b96a739e4bbf9603eafac44872220d47c267ee8193ddbe33c3bed9e75fbd72a62f23a1165e0c909a6fcd8e1c9fdd633e915a09b01fa6c044b21bc04054fc49a95b344fe6978b78a015e7b924990a48141340a0f35bc64da28bebcdd0b8af4b4e3b52f110d54cb9a9d1b417ddc467086266c69b12d9f9cd8b9c3aa87aaa16a212ab2e896e37692b10dc61d3f01bf2e952726adc6f0f91e22e22cfa2d729bae04899be2500eaa8306a0ac67bdebdffa77c23190bb04fb9b93199072df56a74a96cce119c25403dcd29332738bb77de46147a5938d9b6636e90c89aba5cf3f06f8d9c23235cc924be09b1fe5d26e74bef915ab9d3f139f116633d640020dbdad26a158afcd6c7f8029b75edce15e6adc5b61459e23ad211039b25c46f563836ff65b83aa5c67eef03b18ad76edc656b345694e3aa3a0e18f8121da6076e3955665a1b1c9289d6089f18742643d37f72a9644879fcb28055d878047cbecc9c3afd31dc77b854bfbd8d951918b4327ec3ce499ced8c822338131e40ef4d4bab9cbe454e57b997660cae1a67ff0a4fdbaa03ef6623e125ee51b00e99c0a2d403f22308134a55c113146534386d0878b4d745e1cb2b385925ca7322ce71cc99c4d01a5642af81444dd2bf59c32f53ea0fdb12fade54fb3c4a0bcae919b41b324f2ee37106dd5cf8b5e0bf8ac30d91bc13b32a8b2103e0237c3d6a04292944c1d1fd6314aebf98d569215ee303ba43d14162b34b9e609d74d84085b38c0b4acfcec409100b0b882250742c1bb8ac07c3e27faa00d0b0a255292ff5f8260e13f9bc79bc0b66a5e0f355a082954f294ae4e5e834cc6f3d32e20ea11cd794455e4c2c643a2d7bd6354d2768f5b1b653198d4eec51bcea1e9594878557e4655a2f37332596d24fa6fad7a2acdc72a5344bb78856696965fa0dface1052d7534d47951073cc3d6e035941147e015dcb56c7a33eb27adebd0d45c20c8f50696f96064e3e127208e8d89510d7f67bc8fc99aa59cda1bcf67ede66f85bf0569c57ac02dadd02e2b287eeb67b593972ead8c2eb5811978c04c4133b0b963e335805a96bcb0ac7d4d8fbdd6b52a0b5eeb059d9c72bc80de179813b24d60fcb961fea5b227d88b1dbdd762277cee1f5aa40e2e48a604d549e55cbc0bcbffe46e2a8dac152aa63784d49a47947fb3267a227786513cd5befd1976ba0a81ccb2d710df127db65ffd73e7af41062372515ce5092cd0808d03638552dad3c06fa97fbdce058b338006771793005c308ab9858f19c9bf4fe0ed3e0565aaa31e560bad25e0887c33a7500e3cd27551aac80b13b22c55b8d8a427ad2473fdd4cf954e2376774d94244535947a148a4a76d076b282e6dc16fedd5e06bf4167cfff5bff6ee9e8c1055de9c647aba4112ce22b7ab495b7992edc3ea81fdd31258c8edf2ada9f0f7866c367655adc8748adbe5a8ad4593f51e6b032e396c74fa89e3e1f6ceec7e2d16bf9520daa2eb7e36a784c98ea9cec6dc0f1714a63f327b8a9c95ef52f45da2a87f87fcdac4aa5eb6be7ce0c8b7f06f18edcb604c9d1da73d3f9d1013ead920069d0fabc6e0627a9293a4b3a3214d2f34d02ed2b473d2e6811614e4892fe93efe9d2f8a7e8cfc153c5aa7ba431077a875320703923a616978c1ee822d4834fd570f7e3c0dd1394bbd378e63e9ca0d84368cc54d40f9db3b647238748acdcd5a67b112194a2885d4e6641ad3da41e16fe621aaae7ed9e73309cbed1e106f2908964a723f3499db6d291b0f9497f9234f7958c5827b840a6b4462cc6c143445b10becc492ddaac5a203399dd53761a1248bdf31d415fb92b6e1e55934c244cad0ea85ca38fe5d962407e7ae6f69f807d5d9918d47c336d2dfb8b4ae909ec5423adbb0a895b325919da2c77b911d835284f189f7377b111a18a0771d01623c33232c98d0ec2f8864c983a9cf94a620d183105de088802d2b4d0df4a5d891cfb1c02cfd5c403f0740ca97a19f8fcc68736f41247e7d7dc694831820ef84c822a35cf15cebd40b5d68e13d7e339538f56fc3a24f7a35d0bc7101c49e35b110626436ac637e4753a52cac0658947d8cd89629a8e32688d3f37523ca70c622ebfcf570cff0a12ee0f10c2727553ee0caeec8f3782a1c767ce7425cac90e542bddd389d0af3930848f0e1ad8c965c45a677d3555b1b5c897eb213b70179e224ab7725f33beaf09224fc09b4d2c603d9a1d737e786aaef9811dd7c7442ed0af3a26bd19f588457eca0018e4e7a048bdf2fc3f9308832e9786c2e5279fb268f92ffa1d2e40ced3137e8764e02ce267582bfb4d742b3dc258155947603c6b4bbb0eb2c0b9e996d5cbc06868e7acd8c11f796a2754f11c40561773561a6746789c5d8929e40fb1e632347cdccbb751917a786a414c78cb6f4210edcf40b9aace882d9ec3910683bdb02896b4b4843772269cf17df184c2196867bb1f48c8608148f59a1d0aeb2a44c77d9045571f72b69b60d7264ee90c0295de9a313d8a92c3df6cf35a2968a0d15f7272f4c2fa90a8cff9ea324b62137e3f34fbab69bb801f2b64c8a0aded1fa764c844391bb51f010a3f17f7e72f02d61148c5396e306b8593b7c553594a30426caccb39d5c222d5b90056d642faedf2e927118aa0bcfbaa9ca1fa0830b368a9cd95b8168c65be6b2b52f4fead204120a43e38b9d5f664538a53f7357e409d290676d2bdeba66b016c857974a22183bde6cd563cde276a89dba21231112dde50adc00e5937f9359a0b011b7b76c3b4f17956b96f49f552d5d90b9419d747c80aa03da7d59993506211c04cc482b1de428c63f9e67be675018ac332b2952e8df02d8f2d3888b3e0409d90ad64226e38abe48b4ae32b9f75a6620973ebfe3797955c0a056036584df139ea1909876f8d2a200cf0c3e076e6824b7a0951cf1335685478c574ba8d7bb44f5b9d8926638f571f9e82cfc8392baf646a5baf16aa474b120e10415e4d0347ef9142c223ef56cae8ed19263fe44fe75057ac3787e1cf5e7831e644665ae7173f54a87c86712245c7ca61e9fd14ec14b21ad83bafd9f6fb8c1bf5b668265cd81c96cbb06abbec0846aeda466e471d1f046e0eba4e41e05248c082dacf6cfff67d37ecbba34a0dd655268fdd95d3a124eab04e37754ad8e898ba6990ddf4d4099a512fd29d4fe4b234cf8c21cae4c044358fc1aa5e00706b30b012deafe64e0b4b058e97bc948027ab0038cf7b19b9820c152ef5740bc8c9ec4a63e6dc4dfe0474aba0503e1edb4227f99eeaa55eb40e85132d959e7d7c0268d6770cd92efb5a66d2de34cb538e65798ff7186e1ab44930e0d695a51d0ebadaab89f268f940967d08d41c3e0d2e955be152451089db7d2edd741c39a9c84fc8298c7c4a7d60b86d56621779bc48b0815ae6841c7b9300ab43e7d46ed8e868781cfe39e553cdd03e9df30b56373631f518c107ed2f9a9b90077e85b23ce6ab548d03015c81e4cdfcdeaea3e80547238dee76ea739c7131b41a119b7c1d8a4b8b959f4a3c7e7da71afca0e4e6a9f2f5db26345fd1feb7bb4927f403a2411fc81dcd0ab42683c0c9febe57b888005a9e8a8721c1694c7493cbabca081c630e5fc361250778c71d1c86c47be6861322cf191c0df250de98a1079ea0c086e086c499f984aff130dc2e8ffdea0de0e1cc6a63e3e0132ec1235c92a7c3ee931d88b1a9049f461f3c69e57a7cb9a6d00133093c534d83eecf60da42ed848e09f455c5dcabcb89e70a1385b1c9a8dc51cb339ee5c8f2f67e7100788847669f96dfeab547feae783e1bae5836497c41e1658c7f21a31a6e3da2bbc4df3d1023b702016e2dd514897f21019c6b4ac2192a0decf6a28e446b0793fb9728825f74f19bc63881ad59479ebcee525089fadc3528e2ff7b3816c6be448154dc8a2577047d4361825d60d9fca45e1881784b4d1b22fe228c940c2223e8729827f3ac7b4a603db8aee259cf14c9c90a41319d4d1ad2fadc85fed95b8e789dc8f3c86f2e834a87067818a6749b837631c850cc5b533f164c2207d4bf0ca1805b5052ffeaa1aa0d8337f75da0775a9118f1bd34e25052169f4aec2d3edb4f3def5f67c949903a6c2a55d4bdd7accbee23f55efd0b9a43b9af7c5ff67b24036f7485077ae2e770af2dce40520a043a2c66c71761bbc4b0666fe2dcba6a0825d652289fc02869552cbfef2db6f948008faffbd4c2e22d2ff585259cedcf217514a7bdba840acae0716e530929de8ee7b4a71de44dd9b8ee7ca56b7ca73dc62c8ee9b377d3d1a4c4a48b3c59eb7dbb4b822749c7f37eaa39c148b504a32ecce80ae4a95be1c766e6c78405a44784bca2f8212c2b4a25bce4df6d52a9770f2015148be1adb2091e853f33f310e0362552bfa51e5de16ade25763292987b94eca557f6bbbe6d1fdf36f778764a9f98a9701c4e1169ec80574adf43f3c69aa98f2524b535cabe7276552918a600f0302399b1e29ecbff24790a762c2b68cc09992881798e016ca27500dfdc3d7a6e4bb558b1be31e97725e654622ae1db4440f2f3029cd4d073d0ea03e9e46975f9d9f67f032c3864acb148f596697376eaf5282cffe0640cdf09f8db3c16753bbfa7aeaecb5b0e9ca635b2794405ef11bcabb92fac090797d02b265aec64dd1b147b4da9a6badec3cac36e560ab959964a2cc78045336d4d59b200ee2bf9af06e55247aef259ce3270a89a18bc7b49fedddc3f6c2f48cc119ad15be3fc7d588f7a08bed0c60c41456be23bc58bfef0478390dd1b1a88900a88c031efa829510b371a3ec8a7dd4f4bf8f29e231ab1df6cc82b970777ef7a7d47cdc4a685b247dbfdb717bfd5bfa739cbdcf765d83e1343dcf1236d96e5ec54eb36fdf7f1ef1b6e5df883d3f114ec784fac29135f73cc3e6cff457ac9539684e4a1e1289c6e91e468009444cf589a0e0b3e39334a0c3763d7e58add3e3f76aac1a8e55d7eb2523c9126249e019abd11817fd5e4ac2b8849b32f7263808f6c6f9995c32f02864831690fb80d032255a7c70759b0610ec8334f249e743274889c586f91a56ab79b6786efd6fdc3acf18afdc5afe27f6dbd16756990f8e38446fa07d3f8ce01c923b3643e3139b37935821eba114424276398438551e8249a0f1ab75ed8fd215e9427fe4bcab538b3a54c0497b88f5d6ba0835d0fb299bebf9dfe6307d3b2a55681e1529123dbd09df479a37dce2ec0ba8951d194577d2200bf787e2a01e1e1c16e41561ce97b8979040251ab3e875ddc4ebe7374c63eb7a57f42e5fc794027694e04a18307f8a524ee53d182269d74f288b7a93f4eecfa7e172371a0dabe7968a210aa2affc45f4a7eb09a300ca1ed223d2e8d8b0c547286cfef378a3eadf3a7baa1c30addca97543945ac586f6636bba73a3333900d98b360cf7c373adbc85d5e7757428e2ef7dbc06c4bdb05e61312c80f684951bef9dabb78efe2ef290eb1919050cd831d64f8a353504e3b738348b04fdb1fbda88e113300e32d9d02240aa0a77b2950d68cb912a7b15752a4529fb909e7d3b2b930f49e680e0fbd54dab9d180c5259f97848d94f539ec18a960e6f32a2cedfb93175d3b968739f17c25ed1f2b2688c1ef044122c63cc89c91e75f76e1e7fca8d0da36a221a05cf5d0a8b675946ec2bff762d36a3b3010ca8b428969e99e4c0735444dc2ac51ae794a4025dea9b62e103d26bd92f0e69a522b9d62712da2f4f8909ff833706bb48f5691310cdbf0fa869a468f86ddf81e7a4688f27bc12c2ac216f5a805b901efd70c82d2ef6849f8d661143594d84ba90f2d2516a6b2aee3609967ea178240a2f29f59e12fc04efa7a68ebaceae2c26cf714b1c428569c1c8497be75f351ae46afb5ae107df2fa843df5f08d6d50bddaa7777caf00cd1037e6ca4c3bb79c4ab9b61bc903b4953bfc640a734fe10bad767c5e8ed5980c1c00765c806c8d6dba5fbf714f55bb368d8575d49f620ee7d2cfbc74ad17c962d1c0816f50f392f010b1ffa1a5c19df61e36348fbd61620aed855e14ddb484aa116bbb71fdf7cb5ad622b578df46013ea6e6ccbc20","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80ee84f534b2f0e657b75d135b75eaa8"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
